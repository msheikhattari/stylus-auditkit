#![feature(prelude_import)]
//! The Stylus SDK.
//!
//! The Stylus SDK makes it easy to develop Solidity ABI-equivalent Stylus contracts in Rust.
//! Included is a full suite of types and shortcuts that abstract away the details of Solidity's storage layout,
//! method selectors, affordances, and more, making it easy to *just write Rust*.
//! For a guided exploration of the features, please see the comprehensive [Feature Overview][overview].
//!
//! Some of the features available in the SDK include:
//! - **Generic**, storage-backed Rust types for programming **Solidity-equivalent** smart contracts with optimal
//! storage caching.
//! - Simple macros for writing **language-agnostic** methods and entrypoints.
//! - Automatic export of Solidity interfaces for interoperability across programming languages.
//! - Powerful **primitive types** backed by the feature-rich [Alloy][alloy].
//!
//! Rust programs written with the Stylus SDK can **call and be called** by Solidity smart contracts
//! due to ABI equivalence with Ethereum programming languages. In fact, existing Solidity DEXs can list Rust
//! tokens without modification, and vice versa.
//!
//! [overview]: https://docs.arbitrum.io/stylus/reference/rust-sdk-guide
//! [alloy]: https://docs.rs/alloy-primitives/latest/alloy_primitives/
#![doc(
    html_favicon_url = "https://arbitrum.io/assets/stylus/Arbitrum_Stylus-Logomark.png"
)]
#![doc(html_logo_url = "https://arbitrum.io/assets/stylus/Arbitrum_Stylus-Logomark.png")]
#![warn(missing_docs)]
#![no_std]
#[prelude_import]
use core::prelude::rust_2021::*;
#[macro_use]
extern crate core;
extern crate compiler_builtins as _;
extern crate alloc;
pub use alloy_primitives;
pub use alloy_sol_types;
pub use hex;
pub use keccak_const;
pub use stylus_proc;
#[macro_use]
pub mod abi {
    //! Solidity ABIs for Rust types.
    //!
    //! Alloy provides a 1-way mapping of Solidity types to Rust ones via [`SolType`].
    //! This module provides the inverse mapping, forming a bijective, 2-way relationship between Rust and Solidity.
    //!
    //! This allows the [`prelude`][prelude] macros to generate method selectors, export
    //! Solidity interfaces, and otherwise facilitate inter-op between Rust and Solidity contracts.
    //!
    //! Notably, the SDK treats `Vec<u8>` as a Solidity `uint8[]`.
    //! For a Solidity `bytes`, see [`Bytes`].
    //!
    //! [prelude]: crate::prelude
    use crate::{storage::TopLevelStorage, ArbResult};
    use alloy_sol_types::SolType;
    use core::borrow::BorrowMut;
    pub use bytes::{Bytes, BytesSolType};
    pub use const_string::ConstString;
    mod bytes {
        use crate::{
            abi::{AbiType, ConstString},
            util::evm_padded_length,
        };
        use alloc::vec::Vec;
        use alloy_sol_types::{
            abi::token::PackedSeqToken, private::SolTypeValue, SolType, SolValue,
        };
        use core::ops::{Deref, DerefMut};
        /// Represents a [`bytes`] in Solidity.
        ///
        /// [`bytes`]: https://docs.soliditylang.org/en/latest/types.html#bytes-and-string-as-arrays
        pub struct Bytes(pub Vec<u8>);
        #[automatically_derived]
        impl ::core::fmt::Debug for Bytes {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Bytes", &&self.0)
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Bytes {
            #[inline]
            fn clone(&self) -> Bytes {
                Bytes(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Bytes {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Bytes {
            #[inline]
            fn eq(&self, other: &Bytes) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Bytes {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Bytes {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Bytes {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Bytes,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for Bytes {
            #[inline]
            fn cmp(&self, other: &Bytes) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        impl From<Bytes> for Vec<u8> {
            fn from(value: Bytes) -> Self {
                value.0
            }
        }
        impl From<Vec<u8>> for Bytes {
            fn from(b: Vec<u8>) -> Self {
                Self(b)
            }
        }
        impl Deref for Bytes {
            type Target = Vec<u8>;
            fn deref(&self) -> &Vec<u8> {
                &self.0
            }
        }
        impl DerefMut for Bytes {
            fn deref_mut(&mut self) -> &mut Vec<u8> {
                &mut self.0
            }
        }
        impl AsRef<[u8]> for Bytes {
            fn as_ref(&self) -> &[u8] {
                &self.0
            }
        }
        impl AsMut<[u8]> for Bytes {
            fn as_mut(&mut self) -> &mut [u8] {
                &mut self.0
            }
        }
        /// Provides a corresponding [`SolType`] for an [`abi`] [`Bytes`].
        ///
        /// [`abi`]: crate::abi
        pub struct BytesSolType;
        impl SolTypeValue<Self> for Bytes {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                self.0.tokenize()
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                32 + evm_padded_length(self.len())
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                self.0.eip712_data_word()
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                self.0.abi_encode_packed_to(out)
            }
        }
        impl SolType for Bytes {
            type RustType = Bytes;
            type Token<'a> = PackedSeqToken<'a>;
            const ENCODED_SIZE: Option<usize> = None;
            const SOL_NAME: &'static str = "bytes";
            #[inline]
            fn valid_token(_: &Self::Token<'_>) -> bool {
                true
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                Bytes(token.0.into())
            }
        }
        impl SolValue for Bytes {
            type SolType = Self;
        }
        impl AbiType for Bytes {
            type SolType = Self;
            const ABI: ConstString = ConstString::new("bytes");
            const EXPORT_ABI_ARG: ConstString = Self::ABI
                .concat(ConstString::new(" calldata"));
            const EXPORT_ABI_RET: ConstString = Self::ABI
                .concat(ConstString::new(" memory"));
        }
    }
    mod const_string {
        //! Provides [`ConstString`], a mechanism for string operations in `const` contexts.
        use core::{
            fmt::{Debug, Display},
            ops::Deref,
        };
        /// Maximum length of a [`ConstString`] in bytes.
        pub const MAX_CONST_STRING_LENGTH: usize = 1024;
        /// Represents a string with a bounded length at compile time.
        /// This allows something approximating string operations in `const` contexts.
        pub struct ConstString {
            /// The signature's text encoding. Must be valid UTF-8.
            data: [u8; MAX_CONST_STRING_LENGTH],
            /// The length of the string in bytes.
            len: usize,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ConstString {
            #[inline]
            fn clone(&self) -> ConstString {
                ConstString {
                    data: ::core::clone::Clone::clone(&self.data),
                    len: ::core::clone::Clone::clone(&self.len),
                }
            }
        }
        /// Copies data from `source` to `dest` in a `const` context.
        /// This function is very inefficient for other purposes.
        const fn memcpy<const N: usize>(
            mut source: &[u8],
            mut dest: [u8; N],
            mut offset: usize,
        ) -> [u8; N] {
            if offset > dest.len() {
                {
                    ::core::panicking::panic_fmt(format_args!("out-of-bounds memcpy"));
                };
            }
            while !source.is_empty() {
                dest[offset] = source[0];
                offset += 1;
                (_, source) = source.split_at(1);
            }
            dest
        }
        impl ConstString {
            /// Creates a new [`ConstString`] equivalent to the empty string.
            pub const fn new(s: &str) -> ConstString {
                let mut data = [0u8; MAX_CONST_STRING_LENGTH];
                data = memcpy(s.as_bytes(), data, 0);
                ConstString { data, len: s.len() }
            }
            /// Creates a new [`ConstString`] from a decimal number.
            /// For example, the number 42 maps to "42".
            pub const fn from_decimal_number(mut number: usize) -> ConstString {
                let mut data = [0u8; MAX_CONST_STRING_LENGTH];
                let digits = number.checked_ilog10();
                let digits = match digits {
                    Some(digits) => digits as usize + 1,
                    None => 1,
                };
                if digits > MAX_CONST_STRING_LENGTH {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("from_decimal_number: too many digits"),
                        );
                    };
                }
                let mut position = digits;
                while position > 0 {
                    position -= 1;
                    data[position] = b'0' + (number % 10) as u8;
                    number /= 10;
                }
                Self { data, len: digits }
            }
            /// Selects a [`ConstString`] depending on the condition.
            pub const fn select(
                cond: bool,
                true_value: &str,
                false_value: &str,
            ) -> Self {
                match cond {
                    true => Self::new(true_value),
                    false => Self::new(false_value),
                }
            }
            /// Clones a [`ConstString`] in a `const` context.
            pub const fn const_clone(&self) -> Self {
                Self {
                    data: self.data,
                    len: self.len,
                }
            }
            /// Concatenates two [`ConstString`]'s.
            pub const fn concat(&self, other: ConstString) -> ConstString {
                let mut new = self.const_clone();
                new.data = memcpy(other.as_bytes(), new.data, self.len);
                new.len += other.len;
                new
            }
            /// Converts a [`ConstString`] to a slice.
            pub const fn as_bytes(&self) -> &[u8] {
                self.data.split_at(self.len).0
            }
            /// Converts a [`ConstString`] to an equivalent [`str`].
            pub const fn as_str(&self) -> &str {
                unsafe { core::str::from_utf8_unchecked(self.as_bytes()) }
            }
        }
        impl Deref for ConstString {
            type Target = [u8];
            fn deref(&self) -> &Self::Target {
                self.as_bytes()
            }
        }
        impl Display for ConstString {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                f.write_fmt(format_args!("{0}", self.as_str()))
            }
        }
        impl Debug for ConstString {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                f.write_fmt(format_args!("{0:?}", self.as_str()))
            }
        }
    }
    mod impls {
        use super::{AbiType, ConstString};
        use alloc::{string::String, vec::Vec};
        use alloy_primitives::{Address, FixedBytes, Signed, Uint};
        use alloy_sol_types::sol_data::{
            self, ByteCount, IntBitCount, SupportedFixedBytes, SupportedInt,
        };
        impl<const N: usize> AbiType for FixedBytes<N>
        where
            ByteCount<N>: SupportedFixedBytes,
        {
            type SolType = sol_data::FixedBytes<N>;
            const ABI: ConstString = ConstString::new("bytes")
                .concat(ConstString::from_decimal_number(N));
        }
        impl<const BITS: usize, const LIMBS: usize> AbiType for Uint<BITS, LIMBS>
        where
            IntBitCount<BITS>: SupportedInt<Uint = Self>,
        {
            type SolType = sol_data::Uint<BITS>;
            const ABI: ConstString = ConstString::new("uint")
                .concat(ConstString::from_decimal_number(BITS));
        }
        impl<const BITS: usize, const LIMBS: usize> AbiType for Signed<BITS, LIMBS>
        where
            IntBitCount<BITS>: SupportedInt<Int = Self>,
        {
            type SolType = sol_data::Int<BITS>;
            const ABI: ConstString = ConstString::new("int")
                .concat(ConstString::from_decimal_number(BITS));
        }
        impl AbiType for u8
        where
            IntBitCount<8>: SupportedInt<Uint = Self>,
        {
            type SolType = sol_data::Uint<8>;
            const ABI: ConstString = ConstString::new("uint")
                .concat(ConstString::from_decimal_number(8));
        }
        impl AbiType for i8
        where
            IntBitCount<8>: SupportedInt<Int = Self>,
        {
            type SolType = sol_data::Int<8>;
            const ABI: ConstString = ConstString::new("int")
                .concat(ConstString::from_decimal_number(8));
        }
        impl AbiType for u16
        where
            IntBitCount<16>: SupportedInt<Uint = Self>,
        {
            type SolType = sol_data::Uint<16>;
            const ABI: ConstString = ConstString::new("uint")
                .concat(ConstString::from_decimal_number(16));
        }
        impl AbiType for i16
        where
            IntBitCount<16>: SupportedInt<Int = Self>,
        {
            type SolType = sol_data::Int<16>;
            const ABI: ConstString = ConstString::new("int")
                .concat(ConstString::from_decimal_number(16));
        }
        impl AbiType for u32
        where
            IntBitCount<32>: SupportedInt<Uint = Self>,
        {
            type SolType = sol_data::Uint<32>;
            const ABI: ConstString = ConstString::new("uint")
                .concat(ConstString::from_decimal_number(32));
        }
        impl AbiType for i32
        where
            IntBitCount<32>: SupportedInt<Int = Self>,
        {
            type SolType = sol_data::Int<32>;
            const ABI: ConstString = ConstString::new("int")
                .concat(ConstString::from_decimal_number(32));
        }
        impl AbiType for u64
        where
            IntBitCount<64>: SupportedInt<Uint = Self>,
        {
            type SolType = sol_data::Uint<64>;
            const ABI: ConstString = ConstString::new("uint")
                .concat(ConstString::from_decimal_number(64));
        }
        impl AbiType for i64
        where
            IntBitCount<64>: SupportedInt<Int = Self>,
        {
            type SolType = sol_data::Int<64>;
            const ABI: ConstString = ConstString::new("int")
                .concat(ConstString::from_decimal_number(64));
        }
        impl AbiType for u128
        where
            IntBitCount<128>: SupportedInt<Uint = Self>,
        {
            type SolType = sol_data::Uint<128>;
            const ABI: ConstString = ConstString::new("uint")
                .concat(ConstString::from_decimal_number(128));
        }
        impl AbiType for i128
        where
            IntBitCount<128>: SupportedInt<Int = Self>,
        {
            type SolType = sol_data::Int<128>;
            const ABI: ConstString = ConstString::new("int")
                .concat(ConstString::from_decimal_number(128));
        }
        impl AbiType for bool {
            type SolType = sol_data::Bool;
            const ABI: ConstString = ConstString::new("bool");
        }
        impl AbiType for Address {
            type SolType = sol_data::Address;
            const ABI: ConstString = ConstString::new("address");
        }
        impl AbiType for String {
            type SolType = sol_data::String;
            const ABI: ConstString = ConstString::new("string");
            const EXPORT_ABI_ARG: ConstString = Self::ABI
                .concat(ConstString::new(" calldata"));
            const EXPORT_ABI_RET: ConstString = Self::ABI
                .concat(ConstString::new(" memory"));
        }
        impl<T: AbiType> AbiType for Vec<T> {
            type SolType = sol_data::Array<T::SolType>;
            const ABI: ConstString = T::ABI.concat(ConstString::new("[]"));
            const EXPORT_ABI_ARG: ConstString = Self::EXPORT_ABI_RET;
            const EXPORT_ABI_RET: ConstString = T::ABI
                .concat(ConstString::new("[] memory"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<T: AbiType, const N: usize> AbiType for [T; N] {
            type SolType = sol_data::FixedArray<T::SolType, N>;
            const ABI: ConstString = T::ABI
                .concat(ConstString::new("["))
                .concat(ConstString::from_decimal_number(N))
                .concat(ConstString::new("]"));
            const EXPORT_ABI_ARG: ConstString = Self::ABI
                .concat(ConstString::select(T::CAN_BE_CALLDATA, " calldata", " memory"));
            const EXPORT_ABI_RET: ConstString = Self::ABI
                .concat(ConstString::new(" memory"));
            const CAN_BE_CALLDATA: bool = T::CAN_BE_CALLDATA;
        }
        impl AbiType for () {
            type SolType = ();
            const ABI: ConstString = ConstString::new("()");
        }
        impl<
            A: AbiType,
            B: AbiType,
            C: AbiType,
            D: AbiType,
            E: AbiType,
            F: AbiType,
            G: AbiType,
            H: AbiType,
            I: AbiType,
            J: AbiType,
            K: AbiType,
            L: AbiType,
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType
        for (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                A::SolType,
                B::SolType,
                C::SolType,
                D::SolType,
                E::SolType,
                F::SolType,
                G::SolType,
                H::SolType,
                I::SolType,
                J::SolType,
                K::SolType,
                L::SolType,
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(A::ABI)
                .concat(ConstString::new(","))
                .concat(B::ABI)
                .concat(ConstString::new(","))
                .concat(C::ABI)
                .concat(ConstString::new(","))
                .concat(D::ABI)
                .concat(ConstString::new(","))
                .concat(E::ABI)
                .concat(ConstString::new(","))
                .concat(F::ABI)
                .concat(ConstString::new(","))
                .concat(G::ABI)
                .concat(ConstString::new(","))
                .concat(H::ABI)
                .concat(ConstString::new(","))
                .concat(I::ABI)
                .concat(ConstString::new(","))
                .concat(J::ABI)
                .concat(ConstString::new(","))
                .concat(K::ABI)
                .concat(ConstString::new(","))
                .concat(L::ABI)
                .concat(ConstString::new(","))
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(A::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(B::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(C::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(D::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(E::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(F::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(G::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(A::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(B::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(C::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(D::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(E::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(F::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(G::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            B: AbiType,
            C: AbiType,
            D: AbiType,
            E: AbiType,
            F: AbiType,
            G: AbiType,
            H: AbiType,
            I: AbiType,
            J: AbiType,
            K: AbiType,
            L: AbiType,
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType
        for (B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                B::SolType,
                C::SolType,
                D::SolType,
                E::SolType,
                F::SolType,
                G::SolType,
                H::SolType,
                I::SolType,
                J::SolType,
                K::SolType,
                L::SolType,
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(B::ABI)
                .concat(ConstString::new(","))
                .concat(C::ABI)
                .concat(ConstString::new(","))
                .concat(D::ABI)
                .concat(ConstString::new(","))
                .concat(E::ABI)
                .concat(ConstString::new(","))
                .concat(F::ABI)
                .concat(ConstString::new(","))
                .concat(G::ABI)
                .concat(ConstString::new(","))
                .concat(H::ABI)
                .concat(ConstString::new(","))
                .concat(I::ABI)
                .concat(ConstString::new(","))
                .concat(J::ABI)
                .concat(ConstString::new(","))
                .concat(K::ABI)
                .concat(ConstString::new(","))
                .concat(L::ABI)
                .concat(ConstString::new(","))
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(B::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(C::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(D::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(E::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(F::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(G::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(B::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(C::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(D::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(E::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(F::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(G::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            C: AbiType,
            D: AbiType,
            E: AbiType,
            F: AbiType,
            G: AbiType,
            H: AbiType,
            I: AbiType,
            J: AbiType,
            K: AbiType,
            L: AbiType,
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType
        for (C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                C::SolType,
                D::SolType,
                E::SolType,
                F::SolType,
                G::SolType,
                H::SolType,
                I::SolType,
                J::SolType,
                K::SolType,
                L::SolType,
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(C::ABI)
                .concat(ConstString::new(","))
                .concat(D::ABI)
                .concat(ConstString::new(","))
                .concat(E::ABI)
                .concat(ConstString::new(","))
                .concat(F::ABI)
                .concat(ConstString::new(","))
                .concat(G::ABI)
                .concat(ConstString::new(","))
                .concat(H::ABI)
                .concat(ConstString::new(","))
                .concat(I::ABI)
                .concat(ConstString::new(","))
                .concat(J::ABI)
                .concat(ConstString::new(","))
                .concat(K::ABI)
                .concat(ConstString::new(","))
                .concat(L::ABI)
                .concat(ConstString::new(","))
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(C::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(D::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(E::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(F::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(G::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(C::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(D::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(E::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(F::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(G::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            D: AbiType,
            E: AbiType,
            F: AbiType,
            G: AbiType,
            H: AbiType,
            I: AbiType,
            J: AbiType,
            K: AbiType,
            L: AbiType,
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                D::SolType,
                E::SolType,
                F::SolType,
                G::SolType,
                H::SolType,
                I::SolType,
                J::SolType,
                K::SolType,
                L::SolType,
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(D::ABI)
                .concat(ConstString::new(","))
                .concat(E::ABI)
                .concat(ConstString::new(","))
                .concat(F::ABI)
                .concat(ConstString::new(","))
                .concat(G::ABI)
                .concat(ConstString::new(","))
                .concat(H::ABI)
                .concat(ConstString::new(","))
                .concat(I::ABI)
                .concat(ConstString::new(","))
                .concat(J::ABI)
                .concat(ConstString::new(","))
                .concat(K::ABI)
                .concat(ConstString::new(","))
                .concat(L::ABI)
                .concat(ConstString::new(","))
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(D::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(E::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(F::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(G::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(D::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(E::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(F::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(G::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            E: AbiType,
            F: AbiType,
            G: AbiType,
            H: AbiType,
            I: AbiType,
            J: AbiType,
            K: AbiType,
            L: AbiType,
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                E::SolType,
                F::SolType,
                G::SolType,
                H::SolType,
                I::SolType,
                J::SolType,
                K::SolType,
                L::SolType,
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(E::ABI)
                .concat(ConstString::new(","))
                .concat(F::ABI)
                .concat(ConstString::new(","))
                .concat(G::ABI)
                .concat(ConstString::new(","))
                .concat(H::ABI)
                .concat(ConstString::new(","))
                .concat(I::ABI)
                .concat(ConstString::new(","))
                .concat(J::ABI)
                .concat(ConstString::new(","))
                .concat(K::ABI)
                .concat(ConstString::new(","))
                .concat(L::ABI)
                .concat(ConstString::new(","))
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(E::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(F::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(G::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(E::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(F::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(G::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            F: AbiType,
            G: AbiType,
            H: AbiType,
            I: AbiType,
            J: AbiType,
            K: AbiType,
            L: AbiType,
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                F::SolType,
                G::SolType,
                H::SolType,
                I::SolType,
                J::SolType,
                K::SolType,
                L::SolType,
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(F::ABI)
                .concat(ConstString::new(","))
                .concat(G::ABI)
                .concat(ConstString::new(","))
                .concat(H::ABI)
                .concat(ConstString::new(","))
                .concat(I::ABI)
                .concat(ConstString::new(","))
                .concat(J::ABI)
                .concat(ConstString::new(","))
                .concat(K::ABI)
                .concat(ConstString::new(","))
                .concat(L::ABI)
                .concat(ConstString::new(","))
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(F::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(G::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(F::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(G::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            G: AbiType,
            H: AbiType,
            I: AbiType,
            J: AbiType,
            K: AbiType,
            L: AbiType,
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                G::SolType,
                H::SolType,
                I::SolType,
                J::SolType,
                K::SolType,
                L::SolType,
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(G::ABI)
                .concat(ConstString::new(","))
                .concat(H::ABI)
                .concat(ConstString::new(","))
                .concat(I::ABI)
                .concat(ConstString::new(","))
                .concat(J::ABI)
                .concat(ConstString::new(","))
                .concat(K::ABI)
                .concat(ConstString::new(","))
                .concat(L::ABI)
                .concat(ConstString::new(","))
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(G::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(G::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(H::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            H: AbiType,
            I: AbiType,
            J: AbiType,
            K: AbiType,
            L: AbiType,
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                H::SolType,
                I::SolType,
                J::SolType,
                K::SolType,
                L::SolType,
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(H::ABI)
                .concat(ConstString::new(","))
                .concat(I::ABI)
                .concat(ConstString::new(","))
                .concat(J::ABI)
                .concat(ConstString::new(","))
                .concat(K::ABI)
                .concat(ConstString::new(","))
                .concat(L::ABI)
                .concat(ConstString::new(","))
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(H::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(H::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(I::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            I: AbiType,
            J: AbiType,
            K: AbiType,
            L: AbiType,
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                I::SolType,
                J::SolType,
                K::SolType,
                L::SolType,
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(I::ABI)
                .concat(ConstString::new(","))
                .concat(J::ABI)
                .concat(ConstString::new(","))
                .concat(K::ABI)
                .concat(ConstString::new(","))
                .concat(L::ABI)
                .concat(ConstString::new(","))
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(I::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(I::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(J::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            J: AbiType,
            K: AbiType,
            L: AbiType,
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                J::SolType,
                K::SolType,
                L::SolType,
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(J::ABI)
                .concat(ConstString::new(","))
                .concat(K::ABI)
                .concat(ConstString::new(","))
                .concat(L::ABI)
                .concat(ConstString::new(","))
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(J::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(J::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(K::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            K: AbiType,
            L: AbiType,
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (K, L, M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                K::SolType,
                L::SolType,
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(K::ABI)
                .concat(ConstString::new(","))
                .concat(L::ABI)
                .concat(ConstString::new(","))
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(K::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(K::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(L::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            L: AbiType,
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (L, M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                L::SolType,
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(L::ABI)
                .concat(ConstString::new(","))
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(L::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(L::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            M: AbiType,
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (M, N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                M::SolType,
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(M::ABI)
                .concat(ConstString::new(","))
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(M::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(M::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            N: AbiType,
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (N, O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                N::SolType,
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(N::ABI)
                .concat(ConstString::new(","))
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(N::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(N::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            O: AbiType,
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (O, P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                O::SolType,
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(O::ABI)
                .concat(ConstString::new(","))
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(O::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(O::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            P: AbiType,
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (P, Q, R, S, T, U, V, W, X) {
            type SolType = (
                P::SolType,
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(P::ABI)
                .concat(ConstString::new(","))
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(P::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(P::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            Q: AbiType,
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (Q, R, S, T, U, V, W, X) {
            type SolType = (
                Q::SolType,
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(Q::ABI)
                .concat(ConstString::new(","))
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(Q::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(Q::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            R: AbiType,
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (R, S, T, U, V, W, X) {
            type SolType = (
                R::SolType,
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(R::ABI)
                .concat(ConstString::new(","))
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(R::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(R::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<
            S: AbiType,
            T: AbiType,
            U: AbiType,
            V: AbiType,
            W: AbiType,
            X: AbiType,
        > AbiType for (S, T, U, V, W, X) {
            type SolType = (
                S::SolType,
                T::SolType,
                U::SolType,
                V::SolType,
                W::SolType,
                X::SolType,
            );
            const ABI: ConstString = ConstString::new("(")
                .concat(S::ABI)
                .concat(ConstString::new(","))
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(S::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(S::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<T: AbiType, U: AbiType, V: AbiType, W: AbiType, X: AbiType> AbiType
        for (T, U, V, W, X) {
            type SolType = (T::SolType, U::SolType, V::SolType, W::SolType, X::SolType);
            const ABI: ConstString = ConstString::new("(")
                .concat(T::ABI)
                .concat(ConstString::new(","))
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(T::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(T::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<U: AbiType, V: AbiType, W: AbiType, X: AbiType> AbiType for (U, V, W, X) {
            type SolType = (U::SolType, V::SolType, W::SolType, X::SolType);
            const ABI: ConstString = ConstString::new("(")
                .concat(U::ABI)
                .concat(ConstString::new(","))
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(U::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(U::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<V: AbiType, W: AbiType, X: AbiType> AbiType for (V, W, X) {
            type SolType = (V::SolType, W::SolType, X::SolType);
            const ABI: ConstString = ConstString::new("(")
                .concat(V::ABI)
                .concat(ConstString::new(","))
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(V::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(V::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<W: AbiType, X: AbiType> AbiType for (W, X) {
            type SolType = (W::SolType, X::SolType);
            const ABI: ConstString = ConstString::new("(")
                .concat(W::ABI)
                .concat(ConstString::new(","))
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(W::EXPORT_ABI_ARG)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(W::EXPORT_ABI_RET)
                .concat(ConstString::new(", "))
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
        impl<X: AbiType> AbiType for (X,) {
            type SolType = (X::SolType,);
            const ABI: ConstString = ConstString::new("(")
                .concat(X::ABI)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_ARG: ConstString = ConstString::new("(")
                .concat(X::EXPORT_ABI_ARG)
                .concat(ConstString::new(")"));
            const EXPORT_ABI_RET: ConstString = ConstString::new("(")
                .concat(X::EXPORT_ABI_RET)
                .concat(ConstString::new(")"));
            const CAN_BE_CALLDATA: bool = false;
        }
    }
    #[doc(hidden)]
    pub mod internal {
        //! This module provides functions for code generated by `stylus-sdk-proc`.
        //! Most users shouldn't call these.
        use crate::{abi::AbiType, console, msg, ArbResult};
        use alloc::{vec, vec::Vec};
        use alloy_primitives::U256;
        use alloy_sol_types::SolType;
        use core::fmt;
        pub trait EncodableReturnType {
            fn encode(self) -> ArbResult;
        }
        impl<T> EncodableReturnType for T
        where
            T: AbiType + alloy_sol_types::private::SolTypeValue<<T as AbiType>::SolType>,
        {
            #[inline(always)]
            fn encode(self) -> ArbResult {
                Ok(<(<T as AbiType>::SolType,) as SolType>::abi_encode(&(self,)))
            }
        }
        impl<T, E: Into<Vec<u8>>> EncodableReturnType for Result<T, E>
        where
            T: AbiType + alloy_sol_types::private::SolTypeValue<<T as AbiType>::SolType>,
        {
            #[inline(always)]
            fn encode(self) -> ArbResult {
                match self {
                    Ok(result) => result.encode(),
                    Err(err) => Err(err.into()),
                }
            }
        }
        #[inline(always)]
        pub const fn digest_to_selector(digest: [u8; 32]) -> [u8; 4] {
            let mut selector = [0u8; 4];
            selector[0] = digest[0];
            selector[1] = digest[1];
            selector[2] = digest[2];
            selector[3] = digest[3];
            selector
        }
        #[allow(unused)]
        pub fn deny_value(method_name: &str) -> Result<(), Vec<u8>> {
            if msg::value() == U256::ZERO {
                return Ok(());
            }
            {};
            Err(::alloc::vec::Vec::new())
        }
        #[allow(unused)]
        pub fn failed_to_decode_arguments(err: alloy_sol_types::Error) {
            {};
        }
        pub trait AbiResult {
            type OkType;
        }
        impl<O, E> AbiResult for Result<O, E> {
            type OkType = O;
        }
        impl<T: AbiType> AbiResult for T {
            type OkType = T;
        }
        pub fn write_solidity_returns<T: AbiResult>(
            f: &mut fmt::Formatter,
        ) -> fmt::Result
        where
            T::OkType: AbiType,
        {
            let abi = T::OkType::EXPORT_ABI_RET.as_str();
            if abi == "()" {
                Ok(())
            } else if abi.starts_with('(') {
                f.write_fmt(format_args!(" returns {0}", abi))
            } else {
                f.write_fmt(format_args!(" returns ({0})", abi))
            }
        }
    }
    /// Executes a method given a selector and calldata.
    /// This trait can be automatically implemented via `#[external]`.
    /// Composition with other routers is possible via `#[inherit]`.
    pub trait Router<S>
    where
        S: TopLevelStorage + BorrowMut<Self::Storage>,
    {
        /// The type the [`TopLevelStorage`] borrows into. Usually just `Self`.
        type Storage;
        /// Tries to find and execute a method for the given selector, returning `None` if none is found.
        /// Routes add via `#[inherit]` will only execute if no match is found among `Self`.
        /// This means that it is possible to override a method by redefining it in `Self`.
        fn route(storage: &mut S, selector: u32, input: &[u8]) -> Option<ArbResult>;
    }
    /// Provides a mapping of Rust to Solidity types.
    /// When combined with alloy, which provides the reverse direction, a two-way relationship is formed.
    ///
    /// Additionally, `AbiType` provides a `const` equivalent to alloy's [`SolType::sol_type_name`].
    pub trait AbiType {
        /// The associated Solidity type.
        type SolType: SolType<RustType = Self>;
        /// Equivalent to [`SolType::sol_type_name`], but `const`.
        const ABI: ConstString;
        /// String to use when the type is an interface method argument.
        const EXPORT_ABI_ARG: ConstString = Self::ABI;
        /// String to use when the type is an interface method return value.
        const EXPORT_ABI_RET: ConstString = Self::ABI;
        /// Whether the type is allowed in calldata
        const CAN_BE_CALLDATA: bool = true;
    }
}
#[macro_use]
pub mod debug {
    //! Debug-only items for printing to the console.
    //!
    //! ```no_run
    //! use stylus_sdk::console;
    //! use stylus_sdk::alloy_primitives::address;
    //! extern crate alloc;
    //!
    //! let arbinaut = address!("361594F5429D23ECE0A88E4fBE529E1c49D524d8");
    //! console!("Gm {}", arbinaut); // prints nothing in production
    //! ```
}
pub mod block {
    //! VM affordances for inspecting the current block.
    //!
    //! See also [`contract`](crate::contract), [`crypto`](crate::crypto), [`evm`](crate::evm),
    //! [`msg`](crate::msg), and [`tx`](crate::tx).
    //!
    //! ```no_run
    //! use stylus_sdk::block;
    //!
    //! let number = block::number();
    //! ```
    use crate::hostio::{self, wrap_hostio};
    use alloy_primitives::{Address, B256, U256};
    /// Gets the basefee of the current block.
    pub fn basefee() -> U256 {
        unsafe { BASEFEE.get() }
    }
    pub(crate) static mut BASEFEE: hostio::CachedOption<U256> = hostio::CachedOption::new(||
    {
        let mut data = B256::ZERO;
        unsafe { hostio::block_basefee(data.as_mut_ptr()) };
        data.into()
    });
    /// Gets the unique chain identifier of the Arbitrum chain.
    pub fn chainid() -> u64 {
        unsafe { CHAINID.get() }
    }
    pub(crate) static mut CHAINID: hostio::CachedOption<u64> = hostio::CachedOption::new(||
    unsafe { hostio::chainid() });
    /// Gets the coinbase of the current block, which on Arbitrum chains is the L1 batch poster's
    /// address.
    pub fn coinbase() -> Address {
        unsafe { COINBASE.get() }
    }
    pub(crate) static mut COINBASE: hostio::CachedOption<Address> = hostio::CachedOption::new(||
    {
        let mut data = Address::ZERO;
        unsafe { hostio::block_coinbase(data.as_mut_ptr()) };
        data.into()
    });
    /// Gets the gas limit of the current block.
    pub fn gas_limit() -> u64 {
        unsafe { GAS_LIMIT.get() }
    }
    pub(crate) static mut GAS_LIMIT: hostio::CachedOption<u64> = hostio::CachedOption::new(||
    unsafe { hostio::block_gas_limit() });
    /// Gets a bounded estimate of the L1 block number at which the Sequencer sequenced the
    /// transaction. See [`Block Numbers and Time`] for more information on how this value is
    /// determined.
    ///
    /// [`Block Numbers and Time`]: https://developer.arbitrum.io/time
    pub fn number() -> u64 {
        unsafe { NUMBER.get() }
    }
    pub(crate) static mut NUMBER: hostio::CachedOption<u64> = hostio::CachedOption::new(||
    unsafe { hostio::block_number() });
    /// Gets a bounded estimate of the Unix timestamp at which the Sequencer sequenced the
    /// transaction. See [`Block Numbers and Time`] for more information on how this value is
    /// determined.
    ///
    /// [`Block Numbers and Time`]: https://developer.arbitrum.io/time
    pub fn timestamp() -> u64 {
        unsafe { TIMESTAMP.get() }
    }
    pub(crate) static mut TIMESTAMP: hostio::CachedOption<u64> = hostio::CachedOption::new(||
    unsafe { hostio::block_timestamp() });
}
pub mod call {
    //! Call other contracts.
    //!
    //! There are two primary ways to make calls to other contracts via the Stylus SDK.
    //! - [`Call`] with [`sol_interface!`][sol_interface] for richly-typed calls.
    //! - [`RawCall`] for `unsafe`, bytes-in bytes-out calls.
    //!
    //! Additional helpers exist for specific use-cases like [`transfer_eth`].
    //!
    //! [sol_interface]: crate::prelude::sol_interface
    use alloc::vec::Vec;
    use alloy_primitives::Address;
    pub use self::{
        context::Call, error::Error, error::MethodError, raw::RawCall, traits::*,
        transfer::transfer_eth,
    };
    pub(crate) use raw::CachePolicy;
    mod context {
        use crate::storage::TopLevelStorage;
        use super::{
            CallContext, MutatingCallContext, NonPayableCallContext, StaticCallContext,
        };
        use alloy_primitives::U256;
        use cfg_if::cfg_if;
        /// Enables configurable calls to other contracts.
        pub struct Call<S, const HAS_VALUE: bool = false> {
            gas: u64,
            value: Option<U256>,
            storage: S,
        }
        #[automatically_derived]
        impl<S: ::core::fmt::Debug, const HAS_VALUE: bool> ::core::fmt::Debug
        for Call<S, HAS_VALUE> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Call",
                    "gas",
                    &self.gas,
                    "value",
                    &self.value,
                    "storage",
                    &&self.storage,
                )
            }
        }
        #[automatically_derived]
        impl<S: ::core::clone::Clone, const HAS_VALUE: bool> ::core::clone::Clone
        for Call<S, HAS_VALUE> {
            #[inline]
            fn clone(&self) -> Call<S, HAS_VALUE> {
                Call {
                    gas: ::core::clone::Clone::clone(&self.gas),
                    value: ::core::clone::Clone::clone(&self.value),
                    storage: ::core::clone::Clone::clone(&self.storage),
                }
            }
        }
        impl<'a, S: TopLevelStorage> Call<&'a mut S, false>
        where
            S: TopLevelStorage + 'a,
        {
            /// Similar to [`new`], but intended for projects and libraries using reentrant patterns.
            ///
            /// [`new_in`] safeguards persistent storage by requiring a reference to a [`TopLevelStorage`] `struct`.
            ///
            /// Recall that [`TopLevelStorage`] is special in that a reference to it represents access to the entire
            /// contract's state. So that it's sound to [`flush`] or [`clear`] the [`StorageCache`] when calling out
            /// to other contracts, calls that may induce reentrancy require an `&` or `&mut` to one.
            ///
            /// ```no_run
            /// use stylus_sdk::call::{Call, Error};
            /// use stylus_sdk::{prelude::*, evm, msg, alloy_primitives::Address};
            /// extern crate alloc;
            ///
            /// sol_interface! {
            ///     interface IService {
            ///         function makePayment(address user) payable returns (string);
            ///     }
            /// }
            ///
            /// pub fn do_call(
            ///     storage: &mut impl TopLevelStorage,  // can be generic, but often just &mut self
            ///     account: IService,                   // serializes as an Address
            ///     user: Address,
            /// ) -> Result<String, Error> {
            ///
            ///     let config = Call::new_in(storage)
            ///         .gas(evm::gas_left() / 2)        // limit to half the gas left
            ///         .value(msg::value());            // set the callvalue
            ///
            ///     account.make_payment(config, user)   // note the snake case
            /// }
            /// ```
            ///
            /// [`StorageCache`]: crate::storage::StorageCache
            /// [`flush`]: crate::storage::StorageCache::flush
            /// [`clear`]: crate::storage::StorageCache::clear
            /// [`new_in`]: Call::new_in
            /// [`new`]: Call::new
            pub fn new_in(storage: &'a mut S) -> Self {
                Self {
                    gas: u64::MAX,
                    value: None,
                    storage,
                }
            }
        }
        impl<S, const HAS_VALUE: bool> Call<S, HAS_VALUE> {
            /// Amount of gas to supply the call.
            /// Values greater than the amount provided will be clipped to all gas left.
            pub fn gas(self, gas: u64) -> Self {
                Self { gas, ..self }
            }
            /// Amount of ETH in wei to give the other contract.
            /// Note: adding value will prevent calls to non-payable methods.
            pub fn value(self, value: U256) -> Call<S, true> {
                Call {
                    value: Some(value),
                    gas: self.gas,
                    storage: self.storage,
                }
            }
        }
        impl<S, const HAS_VALUE: bool> CallContext for Call<S, HAS_VALUE> {
            fn gas(&self) -> u64 {
                self.gas
            }
        }
        impl<'a, T> CallContext for &'a T
        where
            T: TopLevelStorage,
        {
            fn gas(&self) -> u64 {
                u64::MAX
            }
        }
        impl<T> CallContext for &mut T
        where
            T: TopLevelStorage,
        {
            fn gas(&self) -> u64 {
                u64::MAX
            }
        }
        impl<'a, T> StaticCallContext for &'a T
        where
            T: TopLevelStorage,
        {}
        impl<'a, T> StaticCallContext for &'a mut T
        where
            T: TopLevelStorage,
        {}
        unsafe impl<T> MutatingCallContext for &mut T
        where
            T: TopLevelStorage,
        {
            fn value(&self) -> U256 {
                U256::ZERO
            }
        }
        impl<T> NonPayableCallContext for &mut T
        where
            T: TopLevelStorage,
        {}
        impl<S> StaticCallContext for Call<S, false> {}
        impl<S> NonPayableCallContext for Call<S, false> {}
        unsafe impl<S, const HAS_VALUE: bool> MutatingCallContext
        for Call<S, HAS_VALUE> {
            fn value(&self) -> U256 {
                self.value.unwrap_or_default()
            }
        }
    }
    mod error {
        use alloc::vec::Vec;
        use alloy_sol_types::{Panic, PanicKind, SolError};
        /// Represents error data when a call fails.
        pub enum Error {
            /// Revert data returned by the other contract.
            Revert(Vec<u8>),
            /// Failure to decode the other contract's return data.
            AbiDecodingFailed(alloy_sol_types::Error),
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Error {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Error::Revert(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Revert",
                            &__self_0,
                        )
                    }
                    Error::AbiDecodingFailed(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "AbiDecodingFailed",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Error {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Error {
            #[inline]
            fn eq(&self, other: &Error) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (Error::Revert(__self_0), Error::Revert(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Error::AbiDecodingFailed(__self_0),
                            Error::AbiDecodingFailed(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl From<alloy_sol_types::Error> for Error {
            fn from(err: alloy_sol_types::Error) -> Self {
                Error::AbiDecodingFailed(err)
            }
        }
        /// Encode an error.
        ///
        /// This is useful so that users can use `Error` as a variant in their error
        /// types. It should not be necessary to implement this.
        pub trait MethodError {
            /// Users should not have to call this.
            fn encode(self) -> Vec<u8>;
        }
        impl MethodError for Error {
            #[inline]
            fn encode(self) -> Vec<u8> {
                From::from(self)
            }
        }
        impl<T: SolError> MethodError for T {
            #[inline]
            fn encode(self) -> Vec<u8> {
                SolError::abi_encode(&self)
            }
        }
        impl From<Error> for Vec<u8> {
            #[allow(unused)]
            fn from(err: Error) -> Vec<u8> {
                match err {
                    Error::Revert(data) => data,
                    Error::AbiDecodingFailed(err) => {
                        {};
                        Panic::from(PanicKind::Generic).abi_encode()
                    }
                }
            }
        }
    }
    mod raw {
        use crate::{
            contract::{read_return_data, RETURN_DATA_LEN},
            hostio, tx, ArbResult,
        };
        use alloy_primitives::{Address, B256, U256};
        use cfg_if::cfg_if;
        /// Mechanism for performing raw calls to other contracts.
        ///
        /// For safe calls, see [`Call`](super::Call).
        #[must_use]
        pub struct RawCall {
            kind: CallKind,
            callvalue: U256,
            gas: Option<u64>,
            offset: usize,
            size: Option<usize>,
            #[allow(unused)]
            cache_policy: CachePolicy,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RawCall {
            #[inline]
            fn clone(&self) -> RawCall {
                RawCall {
                    kind: ::core::clone::Clone::clone(&self.kind),
                    callvalue: ::core::clone::Clone::clone(&self.callvalue),
                    gas: ::core::clone::Clone::clone(&self.gas),
                    offset: ::core::clone::Clone::clone(&self.offset),
                    size: ::core::clone::Clone::clone(&self.size),
                    cache_policy: ::core::clone::Clone::clone(&self.cache_policy),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for RawCall {
            #[inline]
            fn default() -> RawCall {
                RawCall {
                    kind: ::core::default::Default::default(),
                    callvalue: ::core::default::Default::default(),
                    gas: ::core::default::Default::default(),
                    offset: ::core::default::Default::default(),
                    size: ::core::default::Default::default(),
                    cache_policy: ::core::default::Default::default(),
                }
            }
        }
        /// What kind of call to perform.
        enum CallKind {
            #[default]
            Basic,
            Delegate,
            Static,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for CallKind {
            #[inline]
            fn clone(&self) -> CallKind {
                match self {
                    CallKind::Basic => CallKind::Basic,
                    CallKind::Delegate => CallKind::Delegate,
                    CallKind::Static => CallKind::Static,
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for CallKind {
            #[inline]
            fn default() -> CallKind {
                Self::Basic
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for CallKind {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for CallKind {
            #[inline]
            fn eq(&self, other: &CallKind) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        /// How to manage the storage cache, if enabled.
        #[allow(unused)]
        pub(crate) enum CachePolicy {
            #[default]
            DoNothing,
            Flush,
            Clear,
        }
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::clone::Clone for CachePolicy {
            #[inline]
            fn clone(&self) -> CachePolicy {
                match self {
                    CachePolicy::DoNothing => CachePolicy::DoNothing,
                    CachePolicy::Flush => CachePolicy::Flush,
                    CachePolicy::Clear => CachePolicy::Clear,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::default::Default for CachePolicy {
            #[inline]
            fn default() -> CachePolicy {
                Self::DoNothing
            }
        }
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::marker::StructuralPartialEq for CachePolicy {}
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::cmp::PartialEq for CachePolicy {
            #[inline]
            fn eq(&self, other: &CachePolicy) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::cmp::Eq for CachePolicy {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::cmp::PartialOrd for CachePolicy {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CachePolicy,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::cmp::Ord for CachePolicy {
            #[inline]
            fn cmp(&self, other: &CachePolicy) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[repr(C)]
        struct RustVec {
            ptr: *mut u8,
            len: usize,
            cap: usize,
        }
        #[automatically_derived]
        impl ::core::marker::Copy for RustVec {}
        #[automatically_derived]
        impl ::core::clone::Clone for RustVec {
            #[inline]
            fn clone(&self) -> RustVec {
                let _: ::core::clone::AssertParamIsClone<*mut u8>;
                let _: ::core::clone::AssertParamIsClone<usize>;
                *self
            }
        }
        impl Default for RustVec {
            fn default() -> Self {
                Self {
                    ptr: core::ptr::null_mut(),
                    len: 0,
                    cap: 0,
                }
            }
        }
        impl RawCall {
            /// Begin configuring the raw call, similar to how [`std::fs::OpenOptions`][OpenOptions] works.
            ///
            /// ```no_run
            /// use stylus_sdk::call::RawCall;
            /// use stylus_sdk::{alloy_primitives::address, hex};
            ///
            /// let contract = address!("361594F5429D23ECE0A88E4fBE529E1c49D524d8");
            /// let calldata = &hex::decode("eddecf107b5740cef7f5a01e3ea7e287665c4e75").unwrap();
            ///
            /// unsafe {
            ///     let result = RawCall::new()       // configure a call
            ///         .gas(2100)                    // supply 2100 gas
            ///         .limit_return_data(0, 32)     // only read the first 32 bytes back
            ///     //  .flush_storage_cache()        // flush the storage cache before the call (available in `reentrant`)
            ///         .call(contract, calldata);    // do the call
            /// }
            /// ```
            ///
            /// [OpenOptions]: https://doc.rust-lang.org/stable/std/fs/struct.OpenOptions.html
            pub fn new() -> Self {
                Default::default()
            }
            /// Configures a call that supplies callvalue, denominated in wei.
            pub fn new_with_value(callvalue: U256) -> Self {
                Self {
                    callvalue,
                    ..Default::default()
                }
            }
            /// Begin configuring a [`delegate call`].
            ///
            /// [`DELEGATE_CALL`]: https://www.evm.codes/#F4
            pub fn new_delegate() -> Self {
                Self {
                    kind: CallKind::Delegate,
                    ..Default::default()
                }
            }
            /// Begin configuring a [`static call`].
            ///
            /// [`STATIC_CALL`]: https://www.evm.codes/#FA
            pub fn new_static() -> Self {
                Self {
                    kind: CallKind::Static,
                    ..Default::default()
                }
            }
            /// Configures the amount of gas to supply.
            /// Note: large values are clipped to the amount of gas remaining.
            pub fn gas(mut self, gas: u64) -> Self {
                self.gas = Some(gas);
                self
            }
            /// Configures the amount of ink to supply.
            /// Note: values are clipped to the amount of ink remaining.
            /// See [`Ink and Gas`] for more information on Stylus's compute-pricing model.
            ///
            /// [`Ink and Gas`]: https://developer.arbitrum.io/TODO
            pub fn ink(mut self, ink: u64) -> Self {
                self.gas = Some(tx::ink_to_gas(ink));
                self
            }
            /// Configures what portion of the return data to copy.
            /// Does not revert if out of bounds, but rather copies the overlapping portion.
            pub fn limit_return_data(mut self, offset: usize, size: usize) -> Self {
                self.offset = offset;
                self.size = Some(size);
                self
            }
            /// Configures the call to avoid copying any return data.
            /// Equivalent to `limit_return_data(0, 0)`.
            pub fn skip_return_data(self) -> Self {
                self.limit_return_data(0, 0)
            }
            /// Performs a raw call to another contract at the given address with the given `calldata`.
            ///
            /// # Safety
            ///
            /// This function becomes `unsafe` when the `reentrant` feature is enabled.
            /// That's because raw calls might alias storage if used in the middle of a storage ref's lifetime.
            ///
            /// For extra flexibility, this method does not clear the global storage cache by default.
            /// See [`flush_storage_cache`] and [`clear_storage_cache`] for more information.
            ///
            /// [`flush_storage_cache`]: RawCall::flush_storage_cache
            /// [`clear_storage_cache`]: RawCall::clear_storage_cache
            pub fn call(self, contract: Address, calldata: &[u8]) -> ArbResult {
                let mut outs_len = 0;
                let gas = self.gas.unwrap_or(u64::MAX);
                let value = B256::from(self.callvalue);
                let status = unsafe {
                    match self.kind {
                        CallKind::Basic => {
                            hostio::call_contract(
                                contract.as_ptr(),
                                calldata.as_ptr(),
                                calldata.len(),
                                value.as_ptr(),
                                gas,
                                &mut outs_len,
                            )
                        }
                        CallKind::Delegate => {
                            hostio::delegate_call_contract(
                                contract.as_ptr(),
                                calldata.as_ptr(),
                                calldata.len(),
                                gas,
                                &mut outs_len,
                            )
                        }
                        CallKind::Static => {
                            hostio::static_call_contract(
                                contract.as_ptr(),
                                calldata.as_ptr(),
                                calldata.len(),
                                gas,
                                &mut outs_len,
                            )
                        }
                    }
                };
                unsafe {
                    RETURN_DATA_LEN.set(outs_len);
                }
                let outs = read_return_data(self.offset, self.size);
                match status {
                    0 => Ok(outs),
                    _ => Err(outs),
                }
            }
        }
    }
    mod traits {
        use alloy_primitives::U256;
        /// Trait for calling other contracts.
        /// Users should rarely implement this trait outside of proc macros.
        pub trait CallContext {
            /// Amount of gas to supply the call.
            /// Note: values are clipped to the amount of gas remaining.
            fn gas(&self) -> u64;
        }
        /// Trait for calling the `view` methods of other contracts.
        /// Users should rarely implement this trait outside of proc macros.
        pub trait StaticCallContext: CallContext {}
        /// Trait for calling the mutable methods of other contracts.
        /// Users should rarely implement this trait outside of proc macros.
        ///
        /// # Safety
        ///
        /// The type must contain a [`TopLevelStorage`][TLS] to prevent aliasing in cases of reentrancy.
        ///
        /// [TLS]: crate::storage::TopLevelStorage
        pub unsafe trait MutatingCallContext: CallContext {
            /// Amount of ETH in wei to give the other contract.
            fn value(&self) -> U256;
        }
        /// Trait for calling the `write` methods of other contracts.
        /// Users should rarely implement this trait outside of proc macros.
        ///
        /// Note: any implementations of this must return zero for [`MutatingCallContext::value`].
        pub trait NonPayableCallContext: MutatingCallContext {}
    }
    mod transfer {
        use crate::call::RawCall;
        use alloc::vec::Vec;
        use alloy_primitives::{Address, U256};
        /// Transfers an amount of ETH in wei to the given account.
        /// Note that this method will call the other contract, which may in turn call others.
        ///
        /// All gas is supplied, which the recipient may burn.
        /// If this is not desired, the [`call`](super::call) function may be used directly.
        ///
        /// ```ignore
        /// transfer_eth(recipient, value)?;                 // these two are equivalent
        /// call(Call::new().value(value), recipient, &[])?; // these two are equivalent
        /// ```
        #[cfg(not(feature = "reentrant"))]
        pub fn transfer_eth(to: Address, amount: U256) -> Result<(), Vec<u8>> {
            RawCall::new_with_value(amount).skip_return_data().call(to, &[])?;
            Ok(())
        }
    }
    /// Static calls the contract at the given address.
    pub fn static_call(
        context: impl StaticCallContext,
        to: Address,
        data: &[u8],
    ) -> Result<Vec<u8>, Error> {
        #[cfg(not(feature = "reentrant"))]
        {
            RawCall::new_static()
                .gas(context.gas())
                .call(to, data)
                .map_err(Error::Revert)
        }
    }
    /// Delegate calls the contract at the given address.
    ///
    /// # Safety
    ///
    /// A delegate call must trust the other contract to uphold safety requirements.
    /// Though this function clears any cached values, the other contract may arbitrarily change storage,
    /// spend ether, and do other things one should never blindly allow other contracts to do.
    pub unsafe fn delegate_call(
        context: impl MutatingCallContext,
        to: Address,
        data: &[u8],
    ) -> Result<Vec<u8>, Error> {
        RawCall::new_delegate().gas(context.gas()).call(to, data).map_err(Error::Revert)
    }
    /// Calls the contract at the given address.
    pub fn call(
        context: impl MutatingCallContext,
        to: Address,
        data: &[u8],
    ) -> Result<Vec<u8>, Error> {
        #[cfg(not(feature = "reentrant"))]
        {
            RawCall::new_with_value(context.value())
                .gas(context.gas())
                .call(to, data)
                .map_err(Error::Revert)
        }
    }
}
pub mod contract {
    //! VM affordances for inspecting the contract itself.
    //!
    //! See also [`block`](crate::block), [`crypto`](crate::crypto), [`evm`](crate::evm),
    //! [`msg`](crate::msg), and [`tx`](crate::tx).
    //!
    //! ```no_run
    //! use stylus_sdk::contract;
    //!
    //! let balance = contract::balance();
    //! ```
    use crate::{
        hostio::{self, wrap_hostio},
        types::AddressVM,
    };
    use alloc::vec::Vec;
    use alloy_primitives::{Address, U256};
    /// Reads the invocation's calldata.
    /// The [`entrypoint`](macro@stylus_proc::entrypoint) macro uses this under the hood.
    pub fn args(len: usize) -> Vec<u8> {
        let mut input = Vec::with_capacity(len);
        unsafe {
            hostio::read_args(input.as_mut_ptr());
            input.set_len(len);
        }
        input
    }
    /// Writes the contract's return data.
    /// The [`entrypoint`](macro@stylus_proc::entrypoint) macro uses this under the hood.
    pub fn output(data: &[u8]) {
        unsafe {
            hostio::write_result(data.as_ptr(), data.len());
        }
    }
    /// Copies the bytes of the last EVM call or deployment return result.
    /// Note: this function does not revert if out of bounds, but rather will copy the overlapping portion.
    pub fn read_return_data(offset: usize, size: Option<usize>) -> Vec<u8> {
        let size = size.unwrap_or_else(|| return_data_len().saturating_sub(offset));
        let mut data = Vec::with_capacity(size);
        if size > 0 {
            unsafe {
                let bytes_written = hostio::read_return_data(
                    data.as_mut_ptr(),
                    offset,
                    size,
                );
                if true {
                    if !(bytes_written <= size) {
                        ::core::panicking::panic(
                            "assertion failed: bytes_written <= size",
                        )
                    }
                }
                data.set_len(bytes_written);
            }
        }
        data
    }
    /// Returns the length of the last EVM call or deployment return result, or `0` if neither have
    /// happened during the program's execution.
    pub fn return_data_len() -> usize {
        unsafe { RETURN_DATA_LEN.get() }
    }
    pub(crate) static mut RETURN_DATA_LEN: hostio::CachedOption<usize> = hostio::CachedOption::new(||
    unsafe { hostio::return_data_size() });
    /// Gets the address of the current program.
    pub fn address() -> Address {
        unsafe { ADDRESS.get() }
    }
    pub(crate) static mut ADDRESS: hostio::CachedOption<Address> = hostio::CachedOption::new(||
    {
        let mut data = Address::ZERO;
        unsafe { hostio::contract_address(data.as_mut_ptr()) };
        data.into()
    });
    /// Gets the balance of the current program.
    pub fn balance() -> U256 {
        address().balance()
    }
}
pub mod crypto {
    //! VM-accelerated cryptography.
    //!
    //! See also [`block`](crate::block), [`contract`](crate::contract), [`evm`](crate::evm),
    //! [`msg`](crate::msg), and [`tx`](crate::tx).
    //!
    //! ```no_run
    //! use stylus_sdk::crypto;
    //! use stylus_sdk::alloy_primitives::address;
    //!
    //! let preimage = address!("361594F5429D23ECE0A88E4fBE529E1c49D524d8");
    //! let hash = crypto::keccak(&preimage);
    //! ```
    use alloy_primitives::B256;
    /// Efficiently computes the [`keccak256`] hash of the given preimage.
    ///
    /// [`keccak256`]: https://en.wikipedia.org/wiki/SHA-3
    pub fn keccak<T: AsRef<[u8]>>(bytes: T) -> B256 {
        alloy_primitives::keccak256(bytes)
    }
}
pub mod deploy {
    //! Deploy other contracts.
    //!
    //! Currently this module only supports low-level contract creation via [`RawDeploy`],
    //! but work is being done to introduce high-level deployment patterns.
    pub use raw::RawDeploy;
    mod raw {
        use crate::{
            call::CachePolicy, contract::{read_return_data, RETURN_DATA_LEN},
            hostio,
        };
        use alloc::vec::Vec;
        use alloy_primitives::{Address, B256, U256};
        /// Mechanism for performing raw deploys of other contracts.
        #[must_use]
        pub struct RawDeploy {
            salt: Option<B256>,
            offset: usize,
            size: Option<usize>,
            #[allow(unused)]
            cache_policy: CachePolicy,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RawDeploy {
            #[inline]
            fn clone(&self) -> RawDeploy {
                RawDeploy {
                    salt: ::core::clone::Clone::clone(&self.salt),
                    offset: ::core::clone::Clone::clone(&self.offset),
                    size: ::core::clone::Clone::clone(&self.size),
                    cache_policy: ::core::clone::Clone::clone(&self.cache_policy),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for RawDeploy {
            #[inline]
            fn default() -> RawDeploy {
                RawDeploy {
                    salt: ::core::default::Default::default(),
                    offset: ::core::default::Default::default(),
                    size: ::core::default::Default::default(),
                    cache_policy: ::core::default::Default::default(),
                }
            }
        }
        impl RawDeploy {
            /// Begin configuring the raw deploy.
            pub fn new() -> Self {
                Default::default()
            }
            /// Configure the deploy to use the salt provided.
            /// This will use [`CREATE2`] under the hood to provide a deterministic address.
            ///
            /// [`CREATE2`]: https://www.evm.codes/#f5
            pub fn salt(mut self, salt: B256) -> Self {
                self.salt = Some(salt);
                self
            }
            /// Configure the deploy to use the salt provided.
            /// This will use [`CREATE2`] under the hood to provide a deterministic address if [`Some`].
            ///
            /// [`CREATE2`]: https://www.evm.codes/#f5
            pub fn salt_option(mut self, salt: Option<B256>) -> Self {
                self.salt = salt;
                self
            }
            /// Configures what portion of the revert data to copy in case of failure.
            /// Does not fail if out of bounds, but rather copies the overlapping portion.
            pub fn limit_revert_data(mut self, offset: usize, size: usize) -> Self {
                self.offset = offset;
                self.size = Some(size);
                self
            }
            /// Configures the call to avoid copying any revert data.
            /// Equivalent to `limit_revert_data(0, 0)`.
            pub fn skip_revert_data(self) -> Self {
                self.limit_revert_data(0, 0)
            }
            /// Performs a raw deploy of another contract with the given `endowment` and init `code`.
            /// Returns the address of the newly deployed contract, or the error data in case of failure.
            ///
            /// # Safety
            ///
            /// Note that the EVM allows init code to make calls to other contracts, which provides a vector for
            /// reentrancy. This means that this method may enable storage aliasing if used in the middle of a storage
            /// reference's lifetime and if reentrancy is allowed.
            ///
            /// For extra flexibility, this method does not clear the global storage cache.
            /// See [`StorageCache::flush`][flush] and [`StorageCache::clear`][clear] for more information.
            ///
            /// [flush]: crate::storage::StorageCache::flush
            /// [clear]: crate::storage::StorageCache::clear
            pub unsafe fn deploy(
                self,
                code: &[u8],
                endowment: U256,
            ) -> Result<Address, Vec<u8>> {
                let mut contract = Address::default();
                let mut revert_data_len = 0;
                let endowment: B256 = endowment.into();
                if let Some(salt) = self.salt {
                    hostio::create2(
                        code.as_ptr(),
                        code.len(),
                        endowment.as_ptr(),
                        salt.as_ptr(),
                        contract.as_mut_ptr(),
                        &mut revert_data_len as *mut _,
                    );
                } else {
                    hostio::create1(
                        code.as_ptr(),
                        code.len(),
                        endowment.as_ptr(),
                        contract.as_mut_ptr(),
                        &mut revert_data_len as *mut _,
                    );
                }
                RETURN_DATA_LEN.set(revert_data_len);
                if contract.is_zero() {
                    return Err(read_return_data(0, None));
                }
                Ok(contract)
            }
        }
    }
}
pub mod evm {
    //! Affordances for the Ethereum Virtual Machine.
    //!
    //! See also [`block`](crate::block), [`contract`](crate::contract), [`crypto`](crate::crypto),
    //! [`msg`](crate::msg), and [`tx`](crate::msg).
    //!
    //! ```no_run
    //! use stylus_sdk::evm;
    //!
    //! let gas = evm::gas_left();
    //! ```
    use crate::hostio::{self, wrap_hostio};
    use alloc::{vec, vec::Vec};
    use alloy_primitives::B256;
    use alloy_sol_types::{abi::token::WordToken, SolEvent, TopicList};
    /// Emits an evm log from combined topics and data.
    fn emit_log(bytes: &[u8], topics: usize) {
        unsafe { hostio::emit_log(bytes.as_ptr(), bytes.len(), topics) }
    }
    /// Emits an EVM log from its raw topics and data.
    /// Most users should prefer the alloy-typed [`raw_log`].
    pub fn raw_log(topics: &[B256], data: &[u8]) -> Result<(), &'static str> {
        if topics.len() > 4 {
            return Err("too many topics");
        }
        let mut bytes: Vec<u8> = ::alloc::vec::Vec::new();
        bytes.extend(topics.iter().flat_map(|x| x.0.iter()));
        bytes.extend(data);
        emit_log(&bytes, topics.len());
        Ok(())
    }
    /// Emits a typed alloy log.
    pub fn log<T: SolEvent>(event: T) {
        let mut topics = [WordToken::default(); 4];
        event.encode_topics_raw(&mut topics).unwrap();
        let count = T::TopicList::COUNT;
        let mut bytes = Vec::with_capacity(32 * count);
        for topic in &topics[..count] {
            bytes.extend_from_slice(topic.as_slice());
        }
        event.encode_data_to(&mut bytes);
        emit_log(&bytes, count);
    }
    /// This function exists to force the compiler to import this symbol.
    /// Calling it will unproductively consume gas.
    pub fn pay_for_memory_grow(pages: u16) {
        unsafe { hostio::pay_for_memory_grow(pages) }
    }
    /// Gets the amount of gas remaining. See [`Ink and Gas`] for more information on Stylus's compute pricing.
    ///
    /// [`Ink and Gas`]: https://developer.arbitrum.io/TODO
    pub fn gas_left() -> u64 {
        unsafe { u64::from(hostio::evm_gas_left()) }
    }
    /// Gets the amount of ink remaining. See [`Ink and Gas`] for more information on Stylus's compute pricing.
    ///
    /// [`Ink and Gas`]: https://docs.arbitrum.io/stylus/concepts/stylus-gas
    pub fn ink_left() -> u64 {
        unsafe { u64::from(hostio::evm_ink_left()) }
    }
}
pub mod msg {
    //! VM affordances for inspecting the current call.
    //!
    //! See also [`block`](crate::block), [`contract`](crate::contract), [`evm`](crate::evm),
    //! [`msg`](crate::msg), and [`tx`](crate::tx).
    //!
    //! ```no_run
    //! use stylus_sdk::msg;
    //!
    //! let call_value = msg::value();
    //! ```
    use crate::hostio::{self, wrap_hostio};
    use alloy_primitives::{Address, B256, U256};
    /// Whether the current call is reentrant.
    pub fn reentrant() -> bool {
        unsafe { REENTRANT.get() }
    }
    pub(crate) static mut REENTRANT: hostio::CachedOption<bool> = hostio::CachedOption::new(||
    unsafe { hostio::msg_reentrant() });
    /// Gets the address of the account that called the program. For normal L2-to-L2 transactions
    /// the semantics are equivalent to that of the EVM's [`CALLER`] opcode, including in cases
    /// arising from [`DELEGATE_CALL`].
    ///
    /// For L1-to-L2 retryable ticket transactions, the top-level sender's address will be aliased.
    /// See [`Retryable Ticket Address Aliasing`] for more information on how this works.
    ///
    /// [`CALLER`]: https://www.evm.codes/#33
    /// [`DELEGATE_CALL`]: https://www.evm.codes/#f4
    /// [`Retryable Ticket Address Aliasing`]: https://developer.arbitrum.io/arbos/l1-to-l2-messaging#address-aliasing
    pub fn sender() -> Address {
        unsafe { SENDER.get() }
    }
    pub(crate) static mut SENDER: hostio::CachedOption<Address> = hostio::CachedOption::new(||
    {
        let mut data = Address::ZERO;
        unsafe { hostio::msg_sender(data.as_mut_ptr()) };
        data.into()
    });
    /// Get the ETH value in wei sent to the program.
    pub fn value() -> U256 {
        unsafe { VALUE.get() }
    }
    pub(crate) static mut VALUE: hostio::CachedOption<U256> = hostio::CachedOption::new(||
    {
        let mut data = B256::ZERO;
        unsafe { hostio::msg_value(data.as_mut_ptr()) };
        data.into()
    });
}
pub mod prelude {
    //! Common imports for Stylus contracts.
    //!
    //! Included are all the proc macros and common traits.
    //!
    //! ```
    //! use stylus_sdk::prelude::*;
    //! ```
    pub use crate::storage::{Erase, SimpleStorageType, StorageType, TopLevelStorage};
    pub use crate::stylus_proc::*;
    pub use crate::types::AddressVM;
}
pub mod storage {
    //! Solidity compatible storage types and persistent storage access.
    //!
    //! The Stylus node software is composed of two, fully-composable virtual machines.
    //! - The Stylus VM, which compiles WASM contracts built with SDKs like this one.
    //! - The Ethereum Virtual Machine, which interprets EVM bytecode from languages like Solidity and Vyper.
    //!
    //! Though these two VMs differ in execution, they are backed by the same EVM State Trie.
    //! This means that Stylus contracts have access to the same, key-value based persistent storage
    //! familiar to Solidity devs.
    //!
    //! Because this resource is foreign to Rust, this module provides standard types and traits for
    //! accessing state when writing programs. To protect the user, the Stylus SDK safeguards storage access
    //! by leveraging Rust's borrow checker. It should never be possible to alias Storage without `unsafe` Rust,
    //! eliminating entire classes of errors at compile time.
    //!
    //! Storage Operations are also cached by default, ensuring that efficient usage is clean and auditable.
    //!
    //! For a walkthrough of this module's features, please see [The Feature Overview][overview].
    //!
    //! [overview]: https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#storage
    use crate::hostio;
    use alloy_primitives::{
        Address, BlockHash, BlockNumber, FixedBytes, Signed, Uint, B256, U256,
    };
    use alloy_sol_types::sol_data::{ByteCount, SupportedFixedBytes};
    use core::{cell::OnceCell, marker::PhantomData, ops::Deref};
    pub use array::StorageArray;
    pub use bytes::{StorageBytes, StorageString};
    pub use map::{StorageKey, StorageMap};
    pub use traits::{
        Erase, GlobalStorage, SimpleStorageType, StorageGuard, StorageGuardMut,
        StorageType, TopLevelStorage,
    };
    pub use vec::StorageVec;
    mod array {
        use super::{Erase, StorageGuard, StorageGuardMut, StorageType};
        use alloy_primitives::U256;
        use core::marker::PhantomData;
        /// Accessor for a storage-backed array.
        pub struct StorageArray<S: StorageType, const N: usize> {
            slot: U256,
            marker: PhantomData<S>,
        }
        impl<S: StorageType, const N: usize> StorageType for StorageArray<S, N> {
            type Wraps<'a> = StorageGuard<'a, StorageArray<S, N>> where Self: 'a;
            type WrapsMut<'a> = StorageGuardMut<'a, StorageArray<S, N>> where Self: 'a;
            const REQUIRED_SLOTS: usize = Self::required_slots();
            unsafe fn new(slot: U256, offset: u8) -> Self {
                if true {
                    if !(offset == 0) {
                        ::core::panicking::panic("assertion failed: offset == 0")
                    }
                }
                Self { slot, marker: PhantomData }
            }
            fn load<'s>(self) -> Self::Wraps<'s> {
                StorageGuard::new(self)
            }
            fn load_mut<'s>(self) -> Self::WrapsMut<'s> {
                StorageGuardMut::new(self)
            }
        }
        impl<S: StorageType, const N: usize> StorageArray<S, N> {
            /// Gets an accessor to the element at a given index, if it exists.
            /// Note: the accessor is protected by a [`StorageGuard`], which restricts
            /// its lifetime to that of `&self`.
            pub fn getter(&self, index: impl TryInto<usize>) -> Option<StorageGuard<S>> {
                let store = unsafe { self.accessor(index)? };
                Some(StorageGuard::new(store))
            }
            /// Gets a mutable accessor to the element at a given index, if it exists.
            /// Note: the accessor is protected by a [`StorageGuardMut`], which restricts
            /// its lifetime to that of `&mut self`.
            pub fn setter(
                &mut self,
                index: impl TryInto<usize>,
            ) -> Option<StorageGuardMut<S>> {
                let store = unsafe { self.accessor(index)? };
                Some(StorageGuardMut::new(store))
            }
            /// Gets the underlying accessor to the element at a given index, if it exists.
            ///
            /// # Safety
            ///
            /// Enables aliasing.
            unsafe fn accessor(&self, index: impl TryInto<usize>) -> Option<S> {
                let index = index.try_into().ok()?;
                if index >= N {
                    return None;
                }
                let (slot, offset) = self.index_slot(index);
                Some(S::new(slot, offset))
            }
            /// Gets the underlying accessor to the element at a given index, even if out of bounds.
            ///
            /// # Safety
            ///
            /// Enables aliasing. UB if out of bounds.
            unsafe fn accessor_unchecked(&self, index: usize) -> S {
                let (slot, offset) = self.index_slot(index);
                S::new(slot, offset)
            }
            /// Gets the element at the given index, if it exists.
            pub fn get(&self, index: impl TryInto<usize>) -> Option<S::Wraps<'_>> {
                let store = unsafe { self.accessor(index)? };
                Some(store.load())
            }
            /// Gets a mutable accessor to the element at a given index, if it exists.
            pub fn get_mut(
                &mut self,
                index: impl TryInto<usize>,
            ) -> Option<S::WrapsMut<'_>> {
                let store = unsafe { self.accessor(index)? };
                Some(store.load_mut())
            }
            /// Determines the slot and offset for the element at an index.
            fn index_slot(&self, index: usize) -> (U256, u8) {
                let width = S::SLOT_BYTES;
                let words = S::REQUIRED_SLOTS.max(1);
                let density = Self::density();
                let slot = self.slot + U256::from(words * index / density);
                let offset = 32 - (width * (1 + index % density)) as u8;
                (slot, offset)
            }
            /// Number of elements per slot.
            const fn density() -> usize {
                32 / S::SLOT_BYTES
            }
            /// Required slots for the storage array.
            const fn required_slots() -> usize {
                let reserved = N * S::REQUIRED_SLOTS;
                let density = Self::density();
                let packed = (N + density - 1) / density;
                if reserved > packed {
                    return reserved;
                }
                packed
            }
        }
        impl<S: Erase, const N: usize> Erase for StorageArray<S, N> {
            fn erase(&mut self) {
                for i in 0..N {
                    let mut store = unsafe { self.accessor_unchecked(i) };
                    store.erase()
                }
            }
        }
    }
    mod bytes {
        use super::{
            Erase, GlobalStorage, Storage, StorageB8, StorageGuard, StorageGuardMut,
            StorageType,
        };
        use crate::crypto;
        use alloc::{
            string::{String, ToString},
            vec::Vec,
        };
        use alloy_primitives::{U256, U8};
        use core::cell::OnceCell;
        /// Accessor for storage-backed bytes.
        pub struct StorageBytes {
            root: U256,
            base: OnceCell<U256>,
        }
        impl StorageType for StorageBytes {
            type Wraps<'a> = StorageGuard<'a, StorageBytes> where Self: 'a;
            type WrapsMut<'a> = StorageGuardMut<'a, StorageBytes> where Self: 'a;
            unsafe fn new(root: U256, offset: u8) -> Self {
                if true {
                    if !(offset == 0) {
                        ::core::panicking::panic("assertion failed: offset == 0")
                    }
                }
                Self {
                    root,
                    base: OnceCell::new(),
                }
            }
            fn load<'s>(self) -> Self::Wraps<'s> {
                StorageGuard::new(self)
            }
            fn load_mut<'s>(self) -> Self::WrapsMut<'s> {
                StorageGuardMut::new(self)
            }
        }
        impl StorageBytes {
            /// Returns `true` if the collection contains no elements.
            pub fn is_empty(&self) -> bool {
                self.len() == 0
            }
            /// Gets the number of bytes stored.
            pub fn len(&self) -> usize {
                let word = Storage::get_word(self.root);
                let slot: &[u8] = word.as_ref();
                if slot[31] & 1 == 0 {
                    return (slot[31] / 2) as usize;
                }
                let word: U256 = word.into();
                let len = word / U256::from(2);
                len.try_into().unwrap()
            }
            /// Overwrites the collection's length, moving bytes as needed.
            ///
            /// # Safety
            ///
            /// May populate the vector with junk bytes from prior dirty operations.
            /// Note that [`StorageBytes`] has unlimited capacity, so all lengths are valid.
            pub unsafe fn set_len(&mut self, len: usize) {
                let old = self.len();
                if (old < 32) == (len < 32) {
                    return self.write_len(len);
                }
                if (len < 32) && (old > 32) {
                    let word = Storage::get_word(*self.base());
                    Storage::set_word(self.root, word);
                    return self.write_len(len);
                }
                let mut word = Storage::get_word(self.root);
                word[31] = 0;
                Storage::set_word(*self.base(), word);
                self.write_len(len)
            }
            /// Updates the length while being conscious of representation.
            unsafe fn write_len(&mut self, len: usize) {
                if len < 32 {
                    Storage::set_uint(self.root, 31, U8::from(len * 2));
                } else {
                    Storage::set_word(self.root, U256::from(len * 2 + 1).into())
                }
            }
            /// Adds a byte to the end.
            pub fn push(&mut self, b: u8) {
                let index = self.len();
                let value = U8::from(b);
                if index < 31 {
                    return unsafe {
                        Storage::set_uint(self.root, index % 32, value);
                        self.write_len(index + 1);
                    };
                }
                if index == 31 {
                    let word = Storage::get_word(self.root);
                    unsafe { Storage::set_word(*self.base(), word) };
                }
                let slot = self.base() + U256::from(index / 32);
                unsafe {
                    Storage::set_uint(slot, index % 32, value);
                    self.write_len(index + 1);
                };
            }
            /// Removes and returns the last byte, if it exists.
            /// As an optimization, underlying storage slots are only erased when all bytes in
            /// a given word are freed when in the multi-word representation.
            pub fn pop(&mut self) -> Option<u8> {
                let len = self.len();
                if len == 0 {
                    return None;
                }
                let index = len - 1;
                let clean = index % 32 == 0;
                let byte = self.get(index)?;
                let clear = |slot| unsafe { Storage::clear_word(slot) };
                if len == 32 {
                    let word = Storage::get_word(*self.base());
                    unsafe { Storage::set_word(self.root, word) };
                    clear(*self.base());
                }
                if len > 32 && clean {
                    clear(self.index_slot(len - 1).0);
                }
                if len < 32 {
                    unsafe { Storage::set_byte(self.root, index, 0) };
                }
                unsafe { self.write_len(index) };
                Some(byte)
            }
            /// Gets the byte at the given index, if it exists.
            pub fn get(&self, index: impl TryInto<usize>) -> Option<u8> {
                let index = index.try_into().ok()?;
                if index >= self.len() {
                    return None;
                }
                unsafe { Some(self.get_unchecked(index)) }
            }
            /// Gets a mutable accessor to the byte at the given index, if it exists.
            pub fn get_mut(
                &mut self,
                index: impl TryInto<usize>,
            ) -> Option<StorageGuardMut<StorageB8>> {
                let index = index.try_into().ok()?;
                if index >= self.len() {
                    return None;
                }
                let (slot, offset) = self.index_slot(index);
                let value = unsafe { StorageB8::new(slot, offset) };
                Some(StorageGuardMut::new(value))
            }
            /// Gets the byte at the given index, even if beyond the collection.
            ///
            /// # Safety
            ///
            /// UB if index is out of bounds.
            pub unsafe fn get_unchecked(&self, index: usize) -> u8 {
                let (slot, offset) = self.index_slot(index);
                unsafe { Storage::get_byte(slot, offset.into()) }
            }
            /// Gets the full contents of the collection.
            pub fn get_bytes(&self) -> Vec<u8> {
                let len = self.len();
                let mut bytes = Vec::with_capacity(len);
                for i in 0..len {
                    let byte = unsafe { self.get_unchecked(i) };
                    bytes.push(byte);
                }
                bytes
            }
            /// Overwrites the contents of the collection, erasing what was previously stored.
            pub fn set_bytes(&mut self, bytes: impl AsRef<[u8]>) {
                self.erase();
                self.extend(bytes.as_ref());
            }
            /// Determines the slot and offset for the element at an index.
            fn index_slot(&self, index: usize) -> (U256, u8) {
                let slot = match self.len() {
                    33.. => self.base() + U256::from(index / 32),
                    _ => self.root,
                };
                (slot, (index % 32) as u8)
            }
            /// Determines where in storage indices start. Could be made `const` in the future.
            fn base(&self) -> &U256 {
                self.base
                    .get_or_init(|| crypto::keccak(self.root.to_be_bytes::<32>()).into())
            }
        }
        impl Erase for StorageBytes {
            fn erase(&mut self) {
                let mut len = self.len() as isize;
                if len > 31 {
                    while len > 0 {
                        let slot = self.index_slot(len as usize - 1).0;
                        unsafe { Storage::clear_word(slot) };
                        len -= 32;
                    }
                }
                unsafe { Storage::clear_word(self.root) };
            }
        }
        impl Extend<u8> for StorageBytes {
            fn extend<T: IntoIterator<Item = u8>>(&mut self, iter: T) {
                for elem in iter {
                    self.push(elem);
                }
            }
        }
        impl<'a> Extend<&'a u8> for StorageBytes {
            fn extend<T: IntoIterator<Item = &'a u8>>(&mut self, iter: T) {
                for elem in iter {
                    self.push(*elem);
                }
            }
        }
        /// Accessor for storage-backed bytes
        pub struct StorageString(pub StorageBytes);
        impl StorageType for StorageString {
            type Wraps<'a> = StorageGuard<'a, StorageString> where Self: 'a;
            type WrapsMut<'a> = StorageGuardMut<'a, StorageString> where Self: 'a;
            unsafe fn new(slot: U256, offset: u8) -> Self {
                Self(StorageBytes::new(slot, offset))
            }
            fn load<'s>(self) -> Self::Wraps<'s> {
                StorageGuard::new(self)
            }
            fn load_mut<'s>(self) -> Self::WrapsMut<'s> {
                StorageGuardMut::new(self)
            }
        }
        impl StorageString {
            /// Returns `true` if the collection contains no elements.
            pub fn is_empty(&self) -> bool {
                self.0.is_empty()
            }
            /// Gets the number of bytes stored.
            pub fn len(&self) -> usize {
                self.0.len()
            }
            /// Adds a char to the end.
            pub fn push(&mut self, c: char) {
                for byte in c.to_string().bytes() {
                    self.0.push(byte)
                }
            }
            /// Gets the underlying [`String`], ignoring any invalid data.
            pub fn get_string(&self) -> String {
                let bytes = self.0.get_bytes();
                String::from_utf8_lossy(&bytes).into()
            }
            /// Overwrites the underlying [`String`], erasing what was previously stored.
            pub fn set_str(&mut self, text: impl AsRef<str>) {
                self.erase();
                for c in text.as_ref().chars() {
                    self.push(c);
                }
            }
        }
        impl Erase for StorageString {
            fn erase(&mut self) {
                self.0.erase()
            }
        }
        impl Extend<char> for StorageString {
            fn extend<T: IntoIterator<Item = char>>(&mut self, iter: T) {
                for c in iter {
                    self.push(c);
                }
            }
        }
    }
    mod map {
        use crate::crypto;
        use super::{
            Erase, SimpleStorageType, StorageGuard, StorageGuardMut, StorageType,
        };
        use alloc::{string::String, vec::Vec};
        use alloy_primitives::{Address, FixedBytes, Signed, Uint, B256, U160, U256};
        use core::marker::PhantomData;
        /// Accessor for a storage-backed map.
        pub struct StorageMap<K: StorageKey, V: StorageType> {
            slot: U256,
            marker: PhantomData<(K, V)>,
        }
        impl<K, V> StorageType for StorageMap<K, V>
        where
            K: StorageKey,
            V: StorageType,
        {
            type Wraps<'a> = StorageGuard<'a, StorageMap<K, V>> where Self: 'a;
            type WrapsMut<'a> = StorageGuardMut<'a, StorageMap<K, V>> where Self: 'a;
            unsafe fn new(slot: U256, offset: u8) -> Self {
                if true {
                    if !(offset == 0) {
                        ::core::panicking::panic("assertion failed: offset == 0")
                    }
                }
                Self { slot, marker: PhantomData }
            }
            fn load<'s>(self) -> Self::Wraps<'s> {
                StorageGuard::new(self)
            }
            fn load_mut<'s>(self) -> Self::WrapsMut<'s> {
                StorageGuardMut::new(self)
            }
        }
        impl<K, V> StorageMap<K, V>
        where
            K: StorageKey,
            V: StorageType,
        {
            /// Where in a word to access the wrapped value.
            const CHILD_OFFSET: u8 = 32 - V::SLOT_BYTES as u8;
            /// Gets an accessor to the element at the given key, or the zero-value if none is there.
            /// Note: the accessor is protected by a [`StorageGuard`], which restricts its lifetime
            /// to that of `&self`.
            pub fn getter(&self, key: K) -> StorageGuard<V> {
                let slot = key.to_slot(self.slot.into());
                unsafe { StorageGuard::new(V::new(slot, Self::CHILD_OFFSET)) }
            }
            /// Gets a mutable accessor to the element at the given key, or the zero-value is none is there.
            /// Note: the accessor is protected by a [`StorageGuardMut`], which restricts its lifetime
            /// to that of `&mut self`.
            pub fn setter(&mut self, key: K) -> StorageGuardMut<V> {
                let slot = key.to_slot(self.slot.into());
                unsafe { StorageGuardMut::new(V::new(slot, Self::CHILD_OFFSET)) }
            }
            /// Gets the element at the given key, or the zero value if none is there.
            pub fn get(&self, key: K) -> V::Wraps<'_> {
                let store = self.getter(key);
                unsafe { store.into_raw().load() }
            }
        }
        impl<'a, K, V> StorageMap<K, V>
        where
            K: StorageKey,
            V: SimpleStorageType<'a>,
        {
            /// Sets the element at a given key, overwriting what may have been there.
            pub fn insert(&mut self, key: K, value: V::Wraps<'a>) {
                let mut store = self.setter(key);
                store.set_by_wrapped(value);
            }
            /// Replace the element at the given key.
            /// Returns the old element, or the zero-value if none was there.
            pub fn replace(&mut self, key: K, value: V::Wraps<'a>) -> V::Wraps<'a> {
                let slot = key.to_slot(self.slot.into());
                unsafe {
                    let store = V::new(slot, Self::CHILD_OFFSET);
                    let mut alias = V::new(slot, Self::CHILD_OFFSET);
                    let prior = store.load();
                    alias.set_by_wrapped(value);
                    prior
                }
            }
            /// Remove the element at the given key.
            /// Returns the element, or the zero-value if none was there.
            pub fn take(&mut self, key: K) -> V::Wraps<'a> {
                let slot = key.to_slot(self.slot.into());
                unsafe {
                    let store = V::new(slot, Self::CHILD_OFFSET);
                    let mut alias = V::new(slot, Self::CHILD_OFFSET);
                    let value = store.load();
                    alias.erase();
                    value
                }
            }
        }
        impl<K, V> StorageMap<K, V>
        where
            K: StorageKey,
            V: Erase,
        {
            /// Delete the element at the given key, if it exists.
            pub fn delete(&mut self, key: K) {
                let mut store = self.setter(key);
                store.erase();
            }
        }
        /// Trait that allows types to be the key of a [`StorageMap`].
        ///
        /// Note: the assignment of slots must be injective.
        pub trait StorageKey {
            /// Assigns a slot based on the key and where the map is rooted.
            fn to_slot(&self, root: B256) -> U256;
        }
        impl<const B: usize, const L: usize> StorageKey for Uint<B, L> {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self));
                let data = data.concat_const::<32, 64>(root);
                crypto::keccak(data).into()
            }
        }
        impl<const B: usize, const L: usize> StorageKey for Signed<B, L> {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(self.into_raw()));
                let data = data.concat_const::<32, 64>(root);
                crypto::keccak(data).into()
            }
        }
        impl<const N: usize> StorageKey for FixedBytes<N> {
            fn to_slot(&self, root: B256) -> U256 {
                let mut pad = [0; 32];
                pad[..N].copy_from_slice(&self.0);
                let data = B256::from(pad);
                let data = data.concat_const::<32, 64>(root);
                crypto::keccak(data).into()
            }
        }
        impl StorageKey for &[u8] {
            fn to_slot(&self, root: B256) -> U256 {
                let mut vec = self.to_vec();
                vec.extend(root);
                crypto::keccak(vec).into()
            }
        }
        impl StorageKey for Vec<u8> {
            fn to_slot(&self, root: B256) -> U256 {
                let bytes: &[u8] = self.as_ref();
                bytes.to_slot(root)
            }
        }
        impl StorageKey for &str {
            fn to_slot(&self, root: B256) -> U256 {
                self.as_bytes().to_slot(root)
            }
        }
        impl StorageKey for String {
            fn to_slot(&self, root: B256) -> U256 {
                self.as_bytes().to_slot(root)
            }
        }
        impl StorageKey for Address {
            fn to_slot(&self, root: B256) -> U256 {
                let int: U160 = self.0.into();
                int.to_slot(root)
            }
        }
        impl StorageKey for bool {
            fn to_slot(&self, root: B256) -> U256 {
                let value = self.then_some(1_u8).unwrap_or_default();
                value.to_slot(root)
            }
        }
        impl StorageKey for u8 {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self));
                let data = data.concat_const::<32, 64>(root.into());
                crypto::keccak(data).into()
            }
        }
        impl StorageKey for i8 {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self as u8));
                let data = data.concat_const::<32, 64>(root.into());
                crypto::keccak(data).into()
            }
        }
        impl StorageKey for u16 {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self));
                let data = data.concat_const::<32, 64>(root.into());
                crypto::keccak(data).into()
            }
        }
        impl StorageKey for i16 {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self as u16));
                let data = data.concat_const::<32, 64>(root.into());
                crypto::keccak(data).into()
            }
        }
        impl StorageKey for u32 {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self));
                let data = data.concat_const::<32, 64>(root.into());
                crypto::keccak(data).into()
            }
        }
        impl StorageKey for i32 {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self as u32));
                let data = data.concat_const::<32, 64>(root.into());
                crypto::keccak(data).into()
            }
        }
        impl StorageKey for u64 {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self));
                let data = data.concat_const::<32, 64>(root.into());
                crypto::keccak(data).into()
            }
        }
        impl StorageKey for i64 {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self as u64));
                let data = data.concat_const::<32, 64>(root.into());
                crypto::keccak(data).into()
            }
        }
        impl StorageKey for u128 {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self));
                let data = data.concat_const::<32, 64>(root.into());
                crypto::keccak(data).into()
            }
        }
        impl StorageKey for i128 {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self as u128));
                let data = data.concat_const::<32, 64>(root.into());
                crypto::keccak(data).into()
            }
        }
        impl StorageKey for usize {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self));
                let data = data.concat_const::<32, 64>(root.into());
                crypto::keccak(data).into()
            }
        }
        impl StorageKey for isize {
            fn to_slot(&self, root: B256) -> U256 {
                let data = B256::from(U256::from(*self as usize));
                let data = data.concat_const::<32, 64>(root.into());
                crypto::keccak(data).into()
            }
        }
    }
    mod traits {
        use alloy_primitives::{FixedBytes, Signed, Uint, B256, U256};
        use core::{
            marker::PhantomData, ops::{Deref, DerefMut},
            ptr,
        };
        use derivative::Derivative;
        /// Accessor trait that lets a type be used in persistent storage.
        /// Users can implement this trait to add novel data structures to their contract definitions.
        /// The Stylus SDK by default provides only solidity types, which are represented [`the same way`].
        ///
        /// [`the same way`]: https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html
        pub trait StorageType: Sized {
            /// For primitive types, this is the type being stored.
            /// For collections, this is the [`StorageType`] being collected.
            type Wraps<'a>: 'a where Self: 'a;
            /// Mutable accessor to the type being stored.
            type WrapsMut<'a>: 'a where Self: 'a;
            /// The number of bytes in a slot needed to represent the type. Must not exceed 32.
            /// For types larger than 32 bytes that are stored inline with a struct's fields,
            /// set this to 32 and return the full size in [`StorageType::new`].
            ///
            /// For implementing collections, see how Solidity slots are assigned for [`Arrays and Maps`] and their
            /// Stylus equivalents [`StorageVec`](super::StorageVec) and [`StorageMap`](super::StorageMap).
            /// For multi-word, but still fixed-size types, see the implementations for structs
            /// and [`StorageArray`](super::StorageArray).
            ///
            /// [`Arrays and Maps`]: https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#mappings-and-dynamic-arrays
            const SLOT_BYTES: usize = 32;
            /// The number of words this type must fill. For primitives this is always 0.
            /// For complex types requiring more than one inline word, set this to the total size.
            const REQUIRED_SLOTS: usize = 0;
            /// Where in persistent storage the type should live. Although useful for framework designers
            /// creating new storage types, most user programs shouldn't call this.
            /// Note: implementations will have to be `const` once [`generic_const_exprs`] stabilizes.
            ///
            /// # Safety
            ///
            /// Aliases storage if two calls to the same slot and offset occur within the same lifetime.
            ///
            /// [`generic_const_exprs`]: https://github.com/rust-lang/rust/issues/76560
            unsafe fn new(slot: U256, offset: u8) -> Self;
            /// Load the wrapped type, consuming the accessor.
            /// Note: most types have a `get` and/or `getter`, which don't consume `Self`.
            fn load<'s>(self) -> Self::Wraps<'s>
            where
                Self: 's;
            /// Load the wrapped mutable type, consuming the accessor.
            /// Note: most types have a `set` and/or `setter`, which don't consume `Self`.
            fn load_mut<'s>(self) -> Self::WrapsMut<'s>
            where
                Self: 's;
        }
        /// Trait for accessors that can be used to completely erase their underlying value.
        /// Note that some collections, like [`StorageMap`](super::StorageMap), don't implement this trait.
        pub trait Erase: StorageType {
            /// Erase the value from persistent storage.
            fn erase(&mut self);
        }
        /// Trait for simple accessors that store no more than their wrapped value.
        /// The type's representation must be entirely inline, or storage leaks become possible.
        /// Note: it is a logic error if erasure does anything more than writing the zero-value.
        pub trait SimpleStorageType<'a>: StorageType + Erase + Into<Self::Wraps<'a>>
        where
            Self: 'a,
        {
            /// Write the value to persistent storage.
            fn set_by_wrapped(&mut self, value: Self::Wraps<'a>);
        }
        /// Trait for top-level storage types, usually implemented by proc macros.
        /// Top-level types are special in that their lifetimes track the entirety
        /// of all the EVM state-changes throughout a contract invocation.
        ///
        /// To prevent storage aliasing during reentrancy, you must hold a reference
        /// to such a type when making an EVM call. This may change in the future
        /// for programs that prevent reentrancy.
        ///
        /// # Safety
        ///
        /// The type must be top-level to prevent storage aliasing.
        pub unsafe trait TopLevelStorage {}
        /// Binds a storage accessor to a lifetime to prevent aliasing.
        /// Because this type doesn't implement `DerefMut`, mutable methods on the accessor aren't available.
        /// For a mutable accessor, see [`StorageGuardMut`].
        #[derivative(Debug = "transparent")]
        pub struct StorageGuard<'a, T: 'a> {
            inner: T,
            #[derivative(Debug = "ignore")]
            marker: PhantomData<&'a T>,
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<'a, T: 'a> ::core::fmt::Debug for StorageGuard<'a, T>
        where
            T: ::core::fmt::Debug,
        {
            fn fmt(&self, __f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    StorageGuard { inner: ref __arg_0, marker: _ } => {
                        ::core::fmt::Debug::fmt(__arg_0, __f)
                    }
                }
            }
        }
        impl<'a, T: 'a> StorageGuard<'a, T> {
            /// Creates a new storage guard around an arbitrary type.
            pub fn new(inner: T) -> Self {
                Self { inner, marker: PhantomData }
            }
            /// Get the underlying `T` directly, bypassing the borrow checker.
            ///
            /// # Safety
            ///
            /// Enables storage aliasing.
            pub unsafe fn into_raw(self) -> T {
                self.inner
            }
        }
        impl<'a, T: 'a> Deref for StorageGuard<'a, T> {
            type Target = T;
            fn deref(&self) -> &Self::Target {
                &self.inner
            }
        }
        /// Binds a storage accessor to a lifetime to prevent aliasing.
        pub struct StorageGuardMut<'a, T: 'a> {
            inner: T,
            marker: PhantomData<&'a T>,
        }
        impl<'a, T: 'a> StorageGuardMut<'a, T> {
            /// Creates a new storage guard around an arbitrary type.
            pub fn new(inner: T) -> Self {
                Self { inner, marker: PhantomData }
            }
            /// Get the underlying `T` directly, bypassing the borrow checker.
            ///
            /// # Safety
            ///
            /// Enables storage aliasing.
            pub unsafe fn into_raw(self) -> T {
                self.inner
            }
        }
        impl<'a, T: 'a> Deref for StorageGuardMut<'a, T> {
            type Target = T;
            fn deref(&self) -> &Self::Target {
                &self.inner
            }
        }
        impl<'a, T: 'a> DerefMut for StorageGuardMut<'a, T> {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.inner
            }
        }
        /// Trait for managing access to persistent storage.
        /// Notable implementations include the [`StorageCache`](super::StorageCache)
        /// and [`EagerStorage`](super::EagerStorage) types.
        pub trait GlobalStorage {
            /// Retrieves `N ≤ 32` bytes from persistent storage, performing [`SLOAD`]'s only as needed.
            /// The bytes are read from slot `key`, starting `offset` bytes from the left.
            /// Note that the bytes must exist within a single, 32-byte EVM word.
            ///
            /// # Safety
            ///
            /// UB if the read would cross a word boundary.
            /// May become safe when Rust stabilizes [`generic_const_exprs`].
            ///
            /// [`SLOAD`]: https://www.evm.codes/#54
            /// [`generic_const_exprs`]: https://github.com/rust-lang/rust/issues/76560
            unsafe fn get<const N: usize>(key: U256, offset: usize) -> FixedBytes<N> {
                if true {
                    if !(N + offset <= 32) {
                        ::core::panicking::panic("assertion failed: N + offset <= 32")
                    }
                }
                let word = Self::get_word(key);
                let value = &word[offset..][..N];
                FixedBytes::from_slice(value)
            }
            /// Retrieves a [`Uint`] from persistent storage, performing [`SLOAD`]'s only as needed.
            /// The integer's bytes are read from slot `key`, starting `offset` bytes from the left.
            /// Note that the bytes must exist within a single, 32-byte EVM word.
            ///
            /// # Safety
            ///
            /// UB if the read would cross a word boundary.
            /// May become safe when Rust stabilizes [`generic_const_exprs`].
            ///
            /// [`SLOAD`]: https://www.evm.codes/#54
            /// [`generic_const_exprs`]: https://github.com/rust-lang/rust/issues/76560
            unsafe fn get_uint<const B: usize, const L: usize>(
                key: U256,
                offset: usize,
            ) -> Uint<B, L> {
                if true {
                    if !(B / 8 + offset <= 32) {
                        ::core::panicking::panic(
                            "assertion failed: B / 8 + offset <= 32",
                        )
                    }
                }
                let word = Self::get_word(key);
                let value = &word[offset..][..B / 8];
                Uint::try_from_be_slice(value).unwrap()
            }
            /// Retrieves a [`Signed`] from persistent storage, performing [`SLOAD`]'s only as needed.
            /// The integer's bytes are read from slot `key`, starting `offset` bytes from the left.
            /// Note that the bytes must exist within a single, 32-byte EVM word.
            ///
            /// # Safety
            ///
            /// UB if the read would cross a word boundary.
            /// May become safe when Rust stabilizes [`generic_const_exprs`].
            ///
            /// [`SLOAD`]: https://www.evm.codes/#54
            /// [`generic_const_exprs`]: https://github.com/rust-lang/rust/issues/76560
            unsafe fn get_signed<const B: usize, const L: usize>(
                key: U256,
                offset: usize,
            ) -> Signed<B, L> {
                Signed::from_raw(Self::get_uint(key, offset))
            }
            /// Retrieves a [`u8`] from persistent storage, performing [`SLOAD`]'s only as needed.
            /// The byte is read from slot `key`, starting `offset` bytes from the left.
            ///
            /// # Safety
            ///
            /// UB if the read is out of bounds.
            /// May become safe when Rust stabilizes [`generic_const_exprs`].
            ///
            /// [`SLOAD`]: https://www.evm.codes/#54
            /// [`generic_const_exprs`]: https://github.com/rust-lang/rust/issues/76560
            unsafe fn get_byte(key: U256, offset: usize) -> u8 {
                if true {
                    if !(offset <= 32) {
                        ::core::panicking::panic("assertion failed: offset <= 32")
                    }
                }
                let word = Self::get::<1>(key, offset);
                word[0]
            }
            /// Retrieves a [`Signed`] from persistent storage, performing [`SLOAD`]'s only as needed.
            /// The integer's bytes are read from slot `key`, starting `offset` bytes from the left.
            /// Note that the bytes must exist within a single, 32-byte EVM word.
            ///
            /// # Safety
            ///
            /// UB if the read would cross a word boundary.
            /// May become safe when Rust stabilizes [`generic_const_exprs`].
            ///
            /// [`SLOAD`]: https://www.evm.codes/#54
            /// [`generic_const_exprs`]: https://github.com/rust-lang/rust/issues/76560
            fn get_word(key: U256) -> B256;
            /// Writes `N ≤ 32` bytes to persistent storage, performing [`SSTORE`]'s only as needed.
            /// The bytes are written to slot `key`, starting `offset` bytes from the left.
            /// Note that the bytes must be written to a single, 32-byte EVM word.
            ///
            /// # Safety
            ///
            /// UB if the write would cross a word boundary.
            /// Aliases if called during the lifetime an overlapping accessor.
            ///
            /// [`SSTORE`]: https://www.evm.codes/#55
            unsafe fn set<const N: usize>(
                key: U256,
                offset: usize,
                value: FixedBytes<N>,
            ) {
                if true {
                    if !(N + offset <= 32) {
                        ::core::panicking::panic("assertion failed: N + offset <= 32")
                    }
                }
                if N == 32 {
                    return Self::set_word(key, FixedBytes::from_slice(value.as_slice()));
                }
                let mut word = Self::get_word(key);
                let dest = word[offset..].as_mut_ptr();
                ptr::copy(value.as_ptr(), dest, N);
                Self::set_word(key, word);
            }
            /// Writes a [`Uint`] to persistent storage, performing [`SSTORE`]'s only as needed.
            /// The integer's bytes are written to slot `key`, starting `offset` bytes from the left.
            /// Note that the bytes must be written to a single, 32-byte EVM word.
            ///
            /// # Safety
            ///
            /// UB if the write would cross a word boundary.
            /// Aliases if called during the lifetime an overlapping accessor.
            ///
            /// [`SSTORE`]: https://www.evm.codes/#55
            unsafe fn set_uint<const B: usize, const L: usize>(
                key: U256,
                offset: usize,
                value: Uint<B, L>,
            ) {
                if true {
                    if !(B / 8 + offset <= 32) {
                        ::core::panicking::panic(
                            "assertion failed: B / 8 + offset <= 32",
                        )
                    }
                }
                if B == 256 {
                    return Self::set_word(
                        key,
                        FixedBytes::from_slice(&value.to_be_bytes::<32>()),
                    );
                }
                let mut word = Self::get_word(key);
                let value = value.to_be_bytes_vec();
                let dest = word[offset..].as_mut_ptr();
                ptr::copy(value.as_ptr(), dest, B / 8);
                Self::set_word(key, word);
            }
            /// Writes a [`Signed`] to persistent storage, performing [`SSTORE`]'s only as needed.
            /// The bytes are written to slot `key`, starting `offset` bytes from the left.
            /// Note that the bytes must be written to a single, 32-byte EVM word.
            ///
            /// # Safety
            ///
            /// UB if the write would cross a word boundary.
            /// Aliases if called during the lifetime an overlapping accessor.
            ///
            /// [`SSTORE`]: https://www.evm.codes/#55
            unsafe fn set_signed<const B: usize, const L: usize>(
                key: U256,
                offset: usize,
                value: Signed<B, L>,
            ) {
                Self::set_uint(key, offset, value.into_raw())
            }
            /// Writes a [`u8`] to persistent storage, performing [`SSTORE`]'s only as needed.
            /// The byte is written to slot `key`, starting `offset` bytes from the left.
            ///
            /// # Safety
            ///
            /// UB if the write is out of bounds.
            /// Aliases if called during the lifetime an overlapping accessor.
            ///
            /// [`SSTORE`]: https://www.evm.codes/#55
            unsafe fn set_byte(key: U256, offset: usize, value: u8) {
                let fixed = FixedBytes::from_slice(&[value]);
                Self::set::<1>(key, offset, fixed)
            }
            /// Stores a 32-byte EVM word to persistent storage, performing [`SSTORE`]'s only as needed.
            ///
            /// # Safety
            ///
            /// Aliases if called during the lifetime an overlapping accessor.
            ///
            /// [`SSTORE`]: https://www.evm.codes/#55
            unsafe fn set_word(key: U256, value: B256);
            /// Clears the 32-byte word at the given key, performing [`SSTORE`]'s only as needed.
            ///
            /// # Safety
            ///
            /// Aliases if called during the lifetime an overlapping accessor.
            ///
            /// [`SSTORE`]: https://www.evm.codes/#55
            unsafe fn clear_word(key: U256) {
                Self::set_word(key, B256::ZERO)
            }
        }
    }
    mod vec {
        use super::{
            Erase, GlobalStorage, SimpleStorageType, Storage, StorageGuard,
            StorageGuardMut, StorageType,
        };
        use crate::crypto;
        use alloy_primitives::U256;
        use core::{cell::OnceCell, marker::PhantomData};
        /// Accessor for a storage-backed vector.
        pub struct StorageVec<S: StorageType> {
            slot: U256,
            base: OnceCell<U256>,
            marker: PhantomData<S>,
        }
        impl<S: StorageType> StorageType for StorageVec<S> {
            type Wraps<'a> = StorageGuard<'a, StorageVec<S>> where Self: 'a;
            type WrapsMut<'a> = StorageGuardMut<'a, StorageVec<S>> where Self: 'a;
            unsafe fn new(slot: U256, offset: u8) -> Self {
                if true {
                    if !(offset == 0) {
                        ::core::panicking::panic("assertion failed: offset == 0")
                    }
                }
                Self {
                    slot,
                    base: OnceCell::new(),
                    marker: PhantomData,
                }
            }
            fn load<'s>(self) -> Self::Wraps<'s> {
                StorageGuard::new(self)
            }
            fn load_mut<'s>(self) -> Self::WrapsMut<'s> {
                StorageGuardMut::new(self)
            }
        }
        impl<S: StorageType> StorageVec<S> {
            /// Returns `true` if the collection contains no elements.
            pub fn is_empty(&self) -> bool {
                self.len() == 0
            }
            /// Gets the number of elements stored.
            pub fn len(&self) -> usize {
                let word: U256 = Storage::get_word(self.slot).into();
                word.try_into().unwrap()
            }
            /// Overwrites the vector's length.
            ///
            /// # Safety
            ///
            /// It must be sensible to create accessors for `S` from zero-slots,
            /// or any junk data left over from prior dirty operations.
            /// Note that [`StorageVec`] has unlimited capacity, so all lengths are valid.
            pub unsafe fn set_len(&mut self, len: usize) {
                Storage::set_word(self.slot, U256::from(len).into())
            }
            /// Gets an accessor to the element at a given index, if it exists.
            ///
            /// Note: the accessor is protected by a [`StorageGuard`], which restricts
            /// its lifetime to that of `&self`.
            pub fn getter(&self, index: impl TryInto<usize>) -> Option<StorageGuard<S>> {
                let store = unsafe { self.accessor(index)? };
                Some(StorageGuard::new(store))
            }
            /// Gets a mutable accessor to the element at a given index, if it exists.
            ///
            /// Note: the accessor is protected by a [`StorageGuardMut`], which restricts
            /// its lifetime to that of `&mut self`.
            pub fn setter(
                &mut self,
                index: impl TryInto<usize>,
            ) -> Option<StorageGuardMut<S>> {
                let store = unsafe { self.accessor(index)? };
                Some(StorageGuardMut::new(store))
            }
            /// Gets the underlying accessor to the element at a given index, if it exists.
            ///
            /// # Safety
            ///
            /// Enables aliasing.
            unsafe fn accessor(&self, index: impl TryInto<usize>) -> Option<S> {
                let index = index.try_into().ok()?;
                if index >= self.len() {
                    return None;
                }
                let (slot, offset) = self.index_slot(index);
                Some(S::new(slot, offset))
            }
            /// Gets the underlying accessor to the element at a given index, even if out of bounds.
            ///
            /// # Safety
            ///
            /// Enables aliasing. UB if out of bounds.
            unsafe fn accessor_unchecked(&self, index: usize) -> S {
                let (slot, offset) = self.index_slot(index);
                S::new(slot, offset)
            }
            /// Gets the element at the given index, if it exists.
            pub fn get(&self, index: impl TryInto<usize>) -> Option<S::Wraps<'_>> {
                let store = unsafe { self.accessor(index)? };
                Some(store.load())
            }
            /// Gets a mutable accessor to the element at a given index, if it exists.
            pub fn get_mut(
                &mut self,
                index: impl TryInto<usize>,
            ) -> Option<S::WrapsMut<'_>> {
                let store = unsafe { self.accessor(index)? };
                Some(store.load_mut())
            }
            /// Like [`std::vec::Vec::push`][vec_push], but returns a mutable accessor to the new slot.
            /// This enables pushing elements without constructing them first.
            ///
            /// # Example
            ///
            /// ```no_run
            /// use stylus_sdk::storage::{StorageVec, StorageType, StorageU256};
            /// use stylus_sdk::alloy_primitives::U256;
            ///
            /// let mut vec: StorageVec<StorageVec<StorageU256>> = unsafe { StorageVec::new(U256::ZERO, 0) };
            /// let mut inner_vec = vec.grow();
            /// inner_vec.push(U256::from(8));
            ///
            /// let value = inner_vec.get(0).unwrap();
            /// assert_eq!(value, U256::from(8));
            /// assert_eq!(inner_vec.len(), 1);
            /// ```
            ///
            /// [vec_push]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.push
            pub fn grow(&mut self) -> StorageGuardMut<S> {
                let index = self.len();
                unsafe { self.set_len(index + 1) };
                let (slot, offset) = self.index_slot(index);
                let store = unsafe { S::new(slot, offset) };
                StorageGuardMut::new(store)
            }
            /// Removes and returns an accessor to the last element of the vector, if any.
            pub fn shrink(&mut self) -> Option<StorageGuardMut<S>> {
                let index = match self.len() {
                    0 => return None,
                    x => x - 1,
                };
                unsafe {
                    self.set_len(index);
                    Some(StorageGuardMut::new(self.accessor_unchecked(index)))
                }
            }
            /// Shortens the vector, keeping the first `len` elements.
            ///
            /// Note: this method does not erase any underlying storage.
            pub fn truncate(&mut self, len: usize) {
                if len < self.len() {
                    unsafe { self.set_len(len) }
                }
            }
            /// Determines the slot and offset for the element at an index.
            fn index_slot(&self, index: usize) -> (U256, u8) {
                let width = S::SLOT_BYTES;
                let words = S::REQUIRED_SLOTS.max(1);
                let density = self.density();
                let slot = self.base() + U256::from(words * index / density);
                let offset = 32 - (width * (1 + index % density)) as u8;
                (slot, offset)
            }
            /// Number of elements per slot.
            const fn density(&self) -> usize {
                32 / S::SLOT_BYTES
            }
            /// Determines where in storage indices start. Could be made `const` in the future.
            fn base(&self) -> &U256 {
                self.base
                    .get_or_init(|| crypto::keccak(self.slot.to_be_bytes::<32>()).into())
            }
        }
        impl<'a, S: SimpleStorageType<'a>> StorageVec<S> {
            /// Adds an element to the end of the vector.
            pub fn push(&mut self, value: S::Wraps<'a>) {
                let mut store = self.grow();
                store.set_by_wrapped(value);
            }
            /// Removes and returns the last element of the vector, if it exists.
            ///
            /// Note: the underlying storage slot is erased when all elements in a word are freed.
            pub fn pop(&mut self) -> Option<S::Wraps<'a>> {
                let store = unsafe { self.shrink()?.into_raw() };
                let index = self.len();
                let value = store.into();
                let first = index % self.density() == 0;
                if first {
                    let slot = self.index_slot(index).0;
                    let words = S::REQUIRED_SLOTS.max(1);
                    for i in 0..words {
                        unsafe { Storage::clear_word(slot + U256::from(i)) };
                    }
                }
                Some(value)
            }
        }
        impl<S: Erase> StorageVec<S> {
            /// Removes and erases the last element of the vector.
            pub fn erase_last(&mut self) {
                if self.is_empty() {
                    return;
                }
                let index = self.len() - 1;
                unsafe {
                    self.accessor_unchecked(index).erase();
                    self.set_len(index);
                }
            }
        }
        impl<S: Erase> Erase for StorageVec<S> {
            fn erase(&mut self) {
                for i in 0..self.len() {
                    let mut store = unsafe { self.accessor_unchecked(i) };
                    store.erase()
                }
                self.truncate(0);
            }
        }
        impl<'a, S: SimpleStorageType<'a>> Extend<S::Wraps<'a>> for StorageVec<S> {
            fn extend<T: IntoIterator<Item = S::Wraps<'a>>>(&mut self, iter: T) {
                for elem in iter {
                    self.push(elem);
                }
            }
        }
    }
    pub(crate) type Storage = StorageCache;
    /// Global accessor to persistent storage that relies on VM-level caching.
    ///
    /// [`LocalStorageCache`]: super::LocalStorageCache
    pub struct StorageCache;
    impl GlobalStorage for StorageCache {
        /// Retrieves a 32-byte EVM word from persistent storage.
        fn get_word(key: U256) -> B256 {
            let mut data = B256::ZERO;
            unsafe {
                hostio::storage_load_bytes32(B256::from(key).as_ptr(), data.as_mut_ptr())
            };
            data
        }
        /// Stores a 32-byte EVM word to persistent storage.
        ///
        /// # Safety
        ///
        /// May alias storage.
        unsafe fn set_word(key: U256, value: B256) {
            hostio::storage_cache_bytes32(B256::from(key).as_ptr(), value.as_ptr())
        }
    }
    impl StorageCache {
        /// Flushes the VM cache, persisting all values to the EVM state trie.
        /// Note: this is used at the end of the [`entrypoint`] macro and is not typically called by user code.
        ///
        /// [`entrypoint`]: macro@stylus_proc::entrypoint
        pub fn flush() {
            unsafe { hostio::storage_flush_cache(false) }
        }
        /// Flushes and clears the VM cache, persisting all values to the EVM state trie.
        /// This is useful in cases of reentrancy to ensure cached values from one call context show up in another.
        pub fn clear() {
            unsafe { hostio::storage_flush_cache(true) }
        }
    }
    /// Overwrites the value in a cell.
    #[inline]
    fn overwrite_cell<T>(cell: &mut OnceCell<T>, value: T) {
        cell.take();
        _ = cell.set(value);
    }
    ///Accessor for a storage-backed [`alloy_primitives::aliases::U1`].
    pub type StorageU1 = StorageUint<1, 1>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::I1`].
    pub type StorageI1 = StorageSigned<1, 1>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::U8`].
    pub type StorageU8 = StorageUint<8, 1>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::I8`].
    pub type StorageI8 = StorageSigned<8, 1>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::U16`].
    pub type StorageU16 = StorageUint<16, 1>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::I16`].
    pub type StorageI16 = StorageSigned<16, 1>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::U32`].
    pub type StorageU32 = StorageUint<32, 1>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::I32`].
    pub type StorageI32 = StorageSigned<32, 1>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::U64`].
    pub type StorageU64 = StorageUint<64, 1>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::I64`].
    pub type StorageI64 = StorageSigned<64, 1>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::U128`].
    pub type StorageU128 = StorageUint<128, 2>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::I128`].
    pub type StorageI128 = StorageSigned<128, 2>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::U160`].
    pub type StorageU160 = StorageUint<160, 3>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::I160`].
    pub type StorageI160 = StorageSigned<160, 3>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::U192`].
    pub type StorageU192 = StorageUint<192, 3>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::I192`].
    pub type StorageI192 = StorageSigned<192, 3>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::U256`].
    pub type StorageU256 = StorageUint<256, 4>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::I256`].
    pub type StorageI256 = StorageSigned<256, 4>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::B8`].
    pub type StorageB8 = StorageFixedBytes<1>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::B16`].
    pub type StorageB16 = StorageFixedBytes<2>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::B32`].
    pub type StorageB32 = StorageFixedBytes<4>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::B64`].
    pub type StorageB64 = StorageFixedBytes<8>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::B96`].
    pub type StorageB96 = StorageFixedBytes<12>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::B128`].
    pub type StorageB128 = StorageFixedBytes<16>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::B160`].
    pub type StorageB160 = StorageFixedBytes<20>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::B192`].
    pub type StorageB192 = StorageFixedBytes<24>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::B224`].
    pub type StorageB224 = StorageFixedBytes<28>;
    ///Accessor for a storage-backed [`alloy_primitives::aliases::B256`].
    pub type StorageB256 = StorageFixedBytes<32>;
    /// Accessor for a storage-backed [`alloy_primitives::Uint`].
    ///
    /// Note: in the future `L` won't be needed.
    pub struct StorageUint<const B: usize, const L: usize> {
        slot: U256,
        offset: u8,
        cached: OnceCell<Uint<B, L>>,
    }
    #[automatically_derived]
    impl<const B: usize, const L: usize> ::core::fmt::Debug for StorageUint<B, L> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "StorageUint",
                "slot",
                &self.slot,
                "offset",
                &self.offset,
                "cached",
                &&self.cached,
            )
        }
    }
    impl<const B: usize, const L: usize> StorageUint<B, L> {
        /// Gets the underlying [`alloy_primitives::Uint`] in persistent storage.
        pub fn get(&self) -> Uint<B, L> {
            **self
        }
        /// Sets the underlying [`alloy_primitives::Uint`] in persistent storage.
        pub fn set(&mut self, value: Uint<B, L>) {
            overwrite_cell(&mut self.cached, value);
            unsafe { Storage::set_uint(self.slot, self.offset.into(), value) };
        }
    }
    impl<const B: usize, const L: usize> StorageType for StorageUint<B, L> {
        type Wraps<'a> = Uint<B, L>;
        type WrapsMut<'a> = StorageGuardMut<'a, Self>;
        const SLOT_BYTES: usize = (B / 8);
        unsafe fn new(slot: U256, offset: u8) -> Self {
            if true {
                if !(B <= 256) {
                    ::core::panicking::panic("assertion failed: B <= 256")
                }
            }
            Self {
                slot,
                offset,
                cached: OnceCell::new(),
            }
        }
        fn load<'s>(self) -> Self::Wraps<'s> {
            self.get()
        }
        fn load_mut<'s>(self) -> Self::WrapsMut<'s> {
            StorageGuardMut::new(self)
        }
    }
    impl<'a, const B: usize, const L: usize> SimpleStorageType<'a>
    for StorageUint<B, L> {
        fn set_by_wrapped(&mut self, value: Self::Wraps<'a>) {
            self.set(value);
        }
    }
    impl<const B: usize, const L: usize> Erase for StorageUint<B, L> {
        fn erase(&mut self) {
            self.set(Self::Wraps::ZERO);
        }
    }
    impl<const B: usize, const L: usize> Deref for StorageUint<B, L> {
        type Target = Uint<B, L>;
        fn deref(&self) -> &Self::Target {
            self.cached
                .get_or_init(|| unsafe {
                    Storage::get_uint(self.slot, self.offset.into())
                })
        }
    }
    impl<const B: usize, const L: usize> From<StorageUint<B, L>> for Uint<B, L> {
        fn from(value: StorageUint<B, L>) -> Self {
            *value
        }
    }
    /// Accessor for a storage-backed [`Signed`].
    ///
    /// Note: in the future `L` won't be needed.
    pub struct StorageSigned<const B: usize, const L: usize> {
        slot: U256,
        offset: u8,
        cached: OnceCell<Signed<B, L>>,
    }
    #[automatically_derived]
    impl<const B: usize, const L: usize> ::core::fmt::Debug for StorageSigned<B, L> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "StorageSigned",
                "slot",
                &self.slot,
                "offset",
                &self.offset,
                "cached",
                &&self.cached,
            )
        }
    }
    impl<const B: usize, const L: usize> StorageSigned<B, L> {
        /// Gets the underlying [`Signed`] in persistent storage.
        pub fn get(&self) -> Signed<B, L> {
            **self
        }
        /// Gets the underlying [`Signed`] in persistent storage.
        pub fn set(&mut self, value: Signed<B, L>) {
            overwrite_cell(&mut self.cached, value);
            unsafe { Storage::set_signed(self.slot, self.offset.into(), value) };
        }
    }
    impl<const B: usize, const L: usize> StorageType for StorageSigned<B, L> {
        type Wraps<'a> = Signed<B, L>;
        type WrapsMut<'a> = StorageGuardMut<'a, Self>;
        const SLOT_BYTES: usize = (B / 8);
        unsafe fn new(slot: U256, offset: u8) -> Self {
            Self {
                slot,
                offset,
                cached: OnceCell::new(),
            }
        }
        fn load<'s>(self) -> Self::Wraps<'s> {
            self.get()
        }
        fn load_mut<'s>(self) -> Self::WrapsMut<'s> {
            StorageGuardMut::new(self)
        }
    }
    impl<'a, const B: usize, const L: usize> SimpleStorageType<'a>
    for StorageSigned<B, L> {
        fn set_by_wrapped(&mut self, value: Self::Wraps<'a>) {
            self.set(value);
        }
    }
    impl<const B: usize, const L: usize> Erase for StorageSigned<B, L> {
        fn erase(&mut self) {
            self.set(Self::Wraps::ZERO)
        }
    }
    impl<const B: usize, const L: usize> Deref for StorageSigned<B, L> {
        type Target = Signed<B, L>;
        fn deref(&self) -> &Self::Target {
            self.cached
                .get_or_init(|| unsafe {
                    Storage::get_signed(self.slot, self.offset.into())
                })
        }
    }
    impl<const B: usize, const L: usize> From<StorageSigned<B, L>> for Signed<B, L> {
        fn from(value: StorageSigned<B, L>) -> Self {
            *value
        }
    }
    /// Accessor for a storage-backed [`FixedBytes`].
    pub struct StorageFixedBytes<const N: usize> {
        slot: U256,
        offset: u8,
        cached: OnceCell<FixedBytes<N>>,
    }
    #[automatically_derived]
    impl<const N: usize> ::core::fmt::Debug for StorageFixedBytes<N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "StorageFixedBytes",
                "slot",
                &self.slot,
                "offset",
                &self.offset,
                "cached",
                &&self.cached,
            )
        }
    }
    impl<const N: usize> StorageFixedBytes<N> {
        /// Gets the underlying [`FixedBytes`] in persistent storage.
        pub fn get(&self) -> FixedBytes<N> {
            **self
        }
        /// Gets the underlying [`FixedBytes`] in persistent storage.
        pub fn set(&mut self, value: FixedBytes<N>) {
            overwrite_cell(&mut self.cached, value);
            unsafe { Storage::set(self.slot, self.offset.into(), value) }
        }
    }
    impl<const N: usize> StorageType for StorageFixedBytes<N>
    where
        ByteCount<N>: SupportedFixedBytes,
    {
        type Wraps<'a> = FixedBytes<N>;
        type WrapsMut<'a> = StorageGuardMut<'a, Self>;
        const SLOT_BYTES: usize = N;
        unsafe fn new(slot: U256, offset: u8) -> Self {
            Self {
                slot,
                offset,
                cached: OnceCell::new(),
            }
        }
        fn load<'s>(self) -> Self::Wraps<'s> {
            self.get()
        }
        fn load_mut<'s>(self) -> Self::WrapsMut<'s> {
            StorageGuardMut::new(self)
        }
    }
    impl<'a, const N: usize> SimpleStorageType<'a> for StorageFixedBytes<N>
    where
        ByteCount<N>: SupportedFixedBytes,
    {
        fn set_by_wrapped(&mut self, value: Self::Wraps<'a>) {
            self.set(value);
        }
    }
    impl<const N: usize> Erase for StorageFixedBytes<N>
    where
        ByteCount<N>: SupportedFixedBytes,
    {
        fn erase(&mut self) {
            self.set(Self::Wraps::ZERO)
        }
    }
    impl<const N: usize> Deref for StorageFixedBytes<N> {
        type Target = FixedBytes<N>;
        fn deref(&self) -> &Self::Target {
            self.cached
                .get_or_init(|| unsafe { Storage::get(self.slot, self.offset.into()) })
        }
    }
    impl<const N: usize> From<StorageFixedBytes<N>> for FixedBytes<N> {
        fn from(value: StorageFixedBytes<N>) -> Self {
            *value
        }
    }
    /// Accessor for a storage-backed [`bool`].
    pub struct StorageBool {
        slot: U256,
        offset: u8,
        cached: OnceCell<bool>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StorageBool {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "StorageBool",
                "slot",
                &self.slot,
                "offset",
                &self.offset,
                "cached",
                &&self.cached,
            )
        }
    }
    impl StorageBool {
        /// Gets the underlying [`bool`] in persistent storage.
        pub fn get(&self) -> bool {
            **self
        }
        /// Gets the underlying [`bool`] in persistent storage.
        pub fn set(&mut self, value: bool) {
            overwrite_cell(&mut self.cached, value);
            unsafe { Storage::set_byte(self.slot, self.offset.into(), value as u8) }
        }
    }
    impl StorageType for StorageBool {
        type Wraps<'a> = bool;
        type WrapsMut<'a> = StorageGuardMut<'a, Self>;
        const SLOT_BYTES: usize = 1;
        unsafe fn new(slot: U256, offset: u8) -> Self {
            Self {
                slot,
                offset,
                cached: OnceCell::new(),
            }
        }
        fn load<'s>(self) -> Self::Wraps<'s> {
            self.get()
        }
        fn load_mut<'s>(self) -> Self::WrapsMut<'s> {
            StorageGuardMut::new(self)
        }
    }
    impl<'a> SimpleStorageType<'a> for StorageBool {
        fn set_by_wrapped(&mut self, value: Self::Wraps<'a>) {
            self.set(value);
        }
    }
    impl Erase for StorageBool {
        fn erase(&mut self) {
            self.set(false);
        }
    }
    impl Deref for StorageBool {
        type Target = bool;
        fn deref(&self) -> &Self::Target {
            self.cached
                .get_or_init(|| unsafe {
                    let data = Storage::get_byte(self.slot, self.offset.into());
                    data != 0
                })
        }
    }
    impl From<StorageBool> for bool {
        fn from(value: StorageBool) -> Self {
            *value
        }
    }
    /// Accessor for a storage-backed [`Address`].
    pub struct StorageAddress {
        slot: U256,
        offset: u8,
        cached: OnceCell<Address>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StorageAddress {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "StorageAddress",
                "slot",
                &self.slot,
                "offset",
                &self.offset,
                "cached",
                &&self.cached,
            )
        }
    }
    impl StorageAddress {
        /// Gets the underlying [`Address`] in persistent storage.
        pub fn get(&self) -> Address {
            **self
        }
        /// Gets the underlying [`Address`] in persistent storage.
        pub fn set(&mut self, value: Address) {
            overwrite_cell(&mut self.cached, value);
            unsafe { Storage::set::<20>(self.slot, self.offset.into(), value.into()) }
        }
    }
    impl StorageType for StorageAddress {
        type Wraps<'a> = Address;
        type WrapsMut<'a> = StorageGuardMut<'a, Self>;
        const SLOT_BYTES: usize = 20;
        unsafe fn new(slot: U256, offset: u8) -> Self {
            Self {
                slot,
                offset,
                cached: OnceCell::new(),
            }
        }
        fn load<'s>(self) -> Self::Wraps<'s> {
            self.get()
        }
        fn load_mut<'s>(self) -> Self::WrapsMut<'s> {
            StorageGuardMut::new(self)
        }
    }
    impl<'a> SimpleStorageType<'a> for StorageAddress {
        fn set_by_wrapped(&mut self, value: Self::Wraps<'a>) {
            self.set(value);
        }
    }
    impl Erase for StorageAddress {
        fn erase(&mut self) {
            self.set(Self::Wraps::ZERO);
        }
    }
    impl Deref for StorageAddress {
        type Target = Address;
        fn deref(&self) -> &Self::Target {
            self.cached
                .get_or_init(|| unsafe {
                    Storage::get::<20>(self.slot, self.offset.into()).into()
                })
        }
    }
    impl From<StorageAddress> for Address {
        fn from(value: StorageAddress) -> Self {
            *value
        }
    }
    /// Accessor for a storage-backed [`BlockNumber`].
    pub struct StorageBlockNumber {
        slot: U256,
        offset: u8,
        cached: OnceCell<BlockNumber>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StorageBlockNumber {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "StorageBlockNumber",
                "slot",
                &self.slot,
                "offset",
                &self.offset,
                "cached",
                &&self.cached,
            )
        }
    }
    impl StorageBlockNumber {
        /// Gets the underlying [`BlockNumber`] in persistent storage.
        pub fn get(&self) -> BlockNumber {
            **self
        }
        /// Gets the underlying [`BlockNumber`] in persistent storage.
        pub fn set(&mut self, value: BlockNumber) {
            overwrite_cell(&mut self.cached, value);
            let value = FixedBytes::from(value.to_be_bytes());
            unsafe { Storage::set::<8>(self.slot, self.offset.into(), value) };
        }
    }
    impl StorageType for StorageBlockNumber {
        type Wraps<'a> = BlockNumber;
        type WrapsMut<'a> = StorageGuardMut<'a, Self>;
        const SLOT_BYTES: usize = 8;
        unsafe fn new(slot: U256, offset: u8) -> Self {
            Self {
                slot,
                offset,
                cached: OnceCell::new(),
            }
        }
        fn load<'s>(self) -> Self::Wraps<'s> {
            self.get()
        }
        fn load_mut<'s>(self) -> Self::WrapsMut<'s> {
            StorageGuardMut::new(self)
        }
    }
    impl<'a> SimpleStorageType<'a> for StorageBlockNumber {
        fn set_by_wrapped(&mut self, value: Self::Wraps<'a>) {
            self.set(value);
        }
    }
    impl Erase for StorageBlockNumber {
        fn erase(&mut self) {
            self.set(0);
        }
    }
    impl Deref for StorageBlockNumber {
        type Target = BlockNumber;
        fn deref(&self) -> &Self::Target {
            self.cached
                .get_or_init(|| unsafe {
                    let data = Storage::get::<8>(self.slot, self.offset.into());
                    u64::from_be_bytes(data.0)
                })
        }
    }
    impl From<StorageBlockNumber> for BlockNumber {
        fn from(value: StorageBlockNumber) -> Self {
            *value
        }
    }
    /// Accessor for a storage-backed [`BlockHash`].
    pub struct StorageBlockHash {
        slot: U256,
        cached: OnceCell<BlockHash>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StorageBlockHash {
        #[inline]
        fn clone(&self) -> StorageBlockHash {
            StorageBlockHash {
                slot: ::core::clone::Clone::clone(&self.slot),
                cached: ::core::clone::Clone::clone(&self.cached),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StorageBlockHash {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "StorageBlockHash",
                "slot",
                &self.slot,
                "cached",
                &&self.cached,
            )
        }
    }
    impl StorageBlockHash {
        /// Gets the underlying [`BlockHash`] in persistent storage.
        pub fn get(&self) -> BlockHash {
            **self
        }
        /// Sets the underlying [`BlockHash`] in persistent storage.
        pub fn set(&mut self, value: BlockHash) {
            overwrite_cell(&mut self.cached, value);
            unsafe { Storage::set_word(self.slot, value) }
        }
    }
    impl StorageType for StorageBlockHash {
        type Wraps<'a> = BlockHash;
        type WrapsMut<'a> = StorageGuardMut<'a, Self>;
        unsafe fn new(slot: U256, _offset: u8) -> Self {
            let cached = OnceCell::new();
            Self { slot, cached }
        }
        fn load<'s>(self) -> Self::Wraps<'s> {
            self.get()
        }
        fn load_mut<'s>(self) -> Self::WrapsMut<'s> {
            StorageGuardMut::new(self)
        }
    }
    impl<'a> SimpleStorageType<'a> for StorageBlockHash {
        fn set_by_wrapped(&mut self, value: Self::Wraps<'a>) {
            self.set(value);
        }
    }
    impl Erase for StorageBlockHash {
        fn erase(&mut self) {
            self.set(Self::Wraps::ZERO);
        }
    }
    impl Deref for StorageBlockHash {
        type Target = BlockHash;
        fn deref(&self) -> &Self::Target {
            self.cached.get_or_init(|| Storage::get_word(self.slot))
        }
    }
    impl From<StorageBlockHash> for BlockHash {
        fn from(value: StorageBlockHash) -> Self {
            *value
        }
    }
    /// We implement `StorageType` for `PhantomData` so that storage types can be generic.
    impl<T> StorageType for PhantomData<T> {
        type Wraps<'a> = Self where Self: 'a;
        type WrapsMut<'a> = Self where Self: 'a;
        const REQUIRED_SLOTS: usize = 0;
        const SLOT_BYTES: usize = 0;
        unsafe fn new(_slot: U256, _offset: u8) -> Self {
            Self
        }
        fn load<'s>(self) -> Self::Wraps<'s>
        where
            Self: 's,
        {
            self
        }
        fn load_mut<'s>(self) -> Self::WrapsMut<'s>
        where
            Self: 's,
        {
            self
        }
    }
}
pub mod tx {
    //! VM affordances for inspecting the current tx.
    //!
    //! See also [`block`](crate::block), [`contract`](crate::contract), [`crypto`](crate::crypto),
    //! [`evm`](crate::evm), and [`msg`](crate::msg).
    //!
    //! ```no_run
    //! use stylus_sdk::tx;
    //!
    //! let gas_price = tx::gas_price();
    //! ```
    use crate::hostio::{self, wrap_hostio};
    use alloy_primitives::{Address, B256, U256};
    /// Gets the price of ink in evm gas basis points. See [`Ink and Gas`] for more information on
    /// Stylus's compute-pricing model.
    ///
    /// [`Ink and Gas`]: https://developer.arbitrum.io/TODO
    pub fn ink_price() -> u32 {
        unsafe { INK_PRICE.get() }
    }
    pub(crate) static mut INK_PRICE: hostio::CachedOption<u32> = hostio::CachedOption::new(||
    unsafe { hostio::tx_ink_price() });
    /// Converts evm gas to ink. See [`Ink and Gas`] for more information on
    /// Stylus's compute-pricing model.
    ///
    /// [`Ink and Gas`]: https://developer.arbitrum.io/TODO
    pub fn gas_to_ink(gas: u64) -> u64 {
        gas.saturating_mul(ink_price().into())
    }
    /// Converts ink to evm gas. See [`Ink and Gas`] for more information on
    /// Stylus's compute-pricing model.
    ///
    /// [`Ink and Gas`]: https://developer.arbitrum.io/TODO
    pub fn ink_to_gas(ink: u64) -> u64 {
        ink / ink_price() as u64
    }
    /// Gets the gas price in wei per gas, which on Arbitrum chains equals the basefee.
    pub fn gas_price() -> U256 {
        unsafe { GAS_PRICE.get() }
    }
    pub(crate) static mut GAS_PRICE: hostio::CachedOption<U256> = hostio::CachedOption::new(||
    {
        let mut data = B256::ZERO;
        unsafe { hostio::tx_gas_price(data.as_mut_ptr()) };
        data.into()
    });
    /// Gets the top-level sender of the transaction. The semantics are equivalent to that of the
    /// EVM's [`ORIGIN`] opcode.
    ///
    /// [`ORIGIN`]: https://www.evm.codes/#32
    pub fn origin() -> Address {
        unsafe { ORIGIN.get() }
    }
    pub(crate) static mut ORIGIN: hostio::CachedOption<Address> = hostio::CachedOption::new(||
    {
        let mut data = Address::ZERO;
        unsafe { hostio::tx_origin(data.as_mut_ptr()) };
        data.into()
    });
}
pub mod types {
    //! Traits for common types.
    //!
    //! The contents of this module are typically imported via the [`prelude`](crate::prelude).
    //!
    //! ```no_run
    //! use stylus_sdk::prelude::*;
    //! use alloy_primitives::{address, Address};
    //!
    //! let account = address!("361594F5429D23ECE0A88E4fBE529E1c49D524d8");
    //! let balance = account.balance();
    //! ```
    use crate::hostio;
    use alloc::vec::Vec;
    use alloy_primitives::{b256, Address, B256, U256};
    /// Trait that allows the [`Address`] type to inspect the corresponding account's balance and codehash.
    pub trait AddressVM {
        /// The balance in wei of the account.
        fn balance(&self) -> U256;
        /// Gets the code at the given address. The semantics are equivalent to that of the EVM's [`EXT_CODESIZE`].
        ///
        /// [`EXT_CODE_COPY`]: https://www.evm.codes/#3C
        fn code(&self) -> Vec<u8>;
        /// Gets the size of the code in bytes at the given address. The semantics are equivalent
        /// to that of the EVM's [`EXT_CODESIZE`].
        ///
        /// [`EXT_CODESIZE`]: https://www.evm.codes/#3B
        fn code_size(&self) -> usize;
        /// The codehash of the contract or [`EOA`] at the given address.
        ///
        /// [`EOA`]: https://ethereum.org/en/developers/docs/accounts/#types-of-account
        fn code_hash(&self) -> B256;
        /// Determines if an account has code. Note that this is insufficient to determine if an address is an
        /// [`EOA`]. During contract deployment, an account only gets its code at the very end, meaning that
        /// this method will return `false` while the constructor is executing.
        ///
        /// [`EOA`]: https://ethereum.org/en/developers/docs/accounts/#types-of-account
        fn has_code(&self) -> bool;
    }
    impl AddressVM for Address {
        fn balance(&self) -> U256 {
            let mut data = [0; 32];
            unsafe { hostio::account_balance(self.as_ptr(), data.as_mut_ptr()) };
            U256::from_be_bytes(data)
        }
        fn code(&self) -> Vec<u8> {
            let size = self.code_size();
            let mut dest = Vec::with_capacity(size);
            unsafe {
                hostio::account_code(self.as_ptr(), 0, size, dest.as_mut_ptr());
                dest.set_len(size);
                dest
            }
        }
        fn code_size(&self) -> usize {
            unsafe { hostio::account_code_size(self.as_ptr()) }
        }
        fn code_hash(&self) -> B256 {
            let mut data = [0; 32];
            unsafe { hostio::account_codehash(self.as_ptr(), data.as_mut_ptr()) };
            data.into()
        }
        fn has_code(&self) -> bool {
            let hash = self.code_hash();
            !hash.is_zero()
                && hash
                    != ::alloy_primitives::B256::new({
                        const STRINGS: &[&'static [u8]] = &[
                            "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470"
                                .as_bytes(),
                        ];
                        const LEN: usize = ::hex_literal::len(STRINGS);
                        const RES: [u8; LEN] = ::hex_literal::decode(STRINGS);
                        RES
                    })
        }
    }
}
mod util {
    /// Returns the minimum number of EVM words needed to store `bytes` bytes.
    pub(crate) const fn evm_words(bytes: usize) -> usize {
        (bytes + 31) / 32
    }
    /// Pads a length to the next multiple of 32 bytes
    pub(crate) const fn evm_padded_length(bytes: usize) -> usize {
        evm_words(bytes) * 32
    }
}
#[cfg(not(feature = "hostio"))]
mod hostio {
    //! Raw host I/Os for low-level access to the Stylus runtime.
    //!
    //! This module is only available when the `hostio` feature flag is enabled, which exposes
    //! low-level functions for accessing the VM directly. Most users should instead use the
    //! high-level equivalents of [`block`](crate::block), [`contract`](crate::contract),
    //! [`crypto`](crate::crypto), [`evm`](crate::evm), [`msg`](crate::msg), and [`tx`](crate::tx).
    //!
    //! ```ignore
    //! use stylus_sdk::hostio;
    //! use stylus_sdk::{alloy_primitives::Address, msg};
    //!
    //! let mut sender = Address::ZERO;
    //! unsafe {
    //!     hostio::msg_sender(sender.as_mut_ptr());
    //! }
    //!
    //! assert_eq!(sender, msg::sender());
    //! ```
    use cfg_if::cfg_if;
    #[link(wasm_import_module = "vm_hooks")]
    extern "C" {
        /// Gets the ETH balance in wei of the account at the given address.
        /// The semantics are equivalent to that of the EVM's [`BALANCE`] opcode.
        ///
        /// [`BALANCE`]: https://www.evm.codes/#31
        pub fn account_balance(address: *const u8, dest: *mut u8);
        /// Gets a subset of the code from the account at the given address. The semantics are identical to that
        /// of the EVM's [`EXT_CODE_COPY`] opcode, aside from one small detail: the write to the buffer `dest` will
        /// stop after the last byte is written. This is unlike the EVM, which right pads with zeros in this scenario.
        /// The return value is the number of bytes written, which allows the caller to detect if this has occured.
        ///
        /// [`EXT_CODE_COPY`]: https://www.evm.codes/#3C
        pub fn account_code(
            address: *const u8,
            offset: usize,
            size: usize,
            dest: *mut u8,
        ) -> usize;
        /// Gets the size of the code in bytes at the given address. The semantics are equivalent
        /// to that of the EVM's [`EXT_CODESIZE`].
        ///
        /// [`EXT_CODESIZE`]: https://www.evm.codes/#3B
        pub fn account_code_size(address: *const u8) -> usize;
        /// Gets the code hash of the account at the given address. The semantics are equivalent
        /// to that of the EVM's [`EXT_CODEHASH`] opcode. Note that the code hash of an account without
        /// code will be the empty hash
        /// `keccak("") = c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`.
        ///
        /// [`EXT_CODEHASH`]: https://www.evm.codes/#3F
        pub fn account_codehash(address: *const u8, dest: *mut u8);
        /// Reads a 32-byte value from permanent storage. Stylus's storage format is identical to
        /// that of the EVM. This means that, under the hood, this hostio is accessing the 32-byte
        /// value stored in the EVM state trie at offset `key`, which will be `0` when not previously
        /// set. The semantics, then, are equivalent to that of the EVM's [`SLOAD`] opcode.
        ///
        /// Note: the Stylus VM implements storage caching. This means that repeated calls to the same key
        /// will cost less than in the EVM.
        ///
        /// [`SLOAD`]: https://www.evm.codes/#54
        pub fn storage_load_bytes32(key: *const u8, dest: *mut u8);
        /// Writes a 32-byte value to the permanent storage cache. Stylus's storage format is identical to that
        /// of the EVM. This means that, under the hood, this hostio represents storing a 32-byte value into
        /// the EVM state trie at offset `key`. Refunds are tabulated exactly as in the EVM. The semantics, then,
        /// are equivalent to that of the EVM's [`SSTORE`] opcode.
        ///
        /// Note: because the value is cached, one must call `storage_flush_cache` to persist it.
        ///
        /// [`SSTORE`]: https://www.evm.codes/#55
        pub fn storage_cache_bytes32(key: *const u8, value: *const u8);
        /// Persists any dirty values in the storage cache to the EVM state trie, dropping the cache entirely if requested.
        /// Analogous to repeated invocations of [`SSTORE`].
        ///
        /// [`SSTORE`]: https://www.evm.codes/#55
        pub fn storage_flush_cache(clear: bool);
        /// Gets the basefee of the current block. The semantics are equivalent to that of the EVM's
        /// [`BASEFEE`] opcode.
        ///
        /// [`BASEFEE`]: https://www.evm.codes/#48
        pub fn block_basefee(basefee: *mut u8);
        /// Gets the unique chain identifier of the Arbitrum chain. The semantics are equivalent to
        /// that of the EVM's [`CHAIN_ID`] opcode.
        ///
        /// [`CHAIN_ID`]: https://www.evm.codes/#46
        pub fn chainid() -> u64;
        /// Gets the coinbase of the current block, which on Arbitrum chains is the L1 batch poster's
        /// address. This differs from Ethereum where the validator including the transaction
        /// determines the coinbase.
        pub fn block_coinbase(coinbase: *mut u8);
        /// Gets the gas limit of the current block. The semantics are equivalent to that of the EVM's
        /// [`GAS_LIMIT`] opcode. Note that as of the time of this writing, `evm.codes` incorrectly
        /// implies that the opcode returns the gas limit of the current transaction.  When in doubt,
        /// consult [`The Ethereum Yellow Paper`].
        ///
        /// [`GAS_LIMIT`]: https://www.evm.codes/#45
        /// [`The Ethereum Yellow Paper`]: https://ethereum.github.io/yellowpaper/paper.pdf
        pub fn block_gas_limit() -> u64;
        /// Gets a bounded estimate of the L1 block number at which the Sequencer sequenced the
        /// transaction. See [`Block Numbers and Time`] for more information on how this value is
        /// determined.
        ///
        /// [`Block Numbers and Time`]: https://developer.arbitrum.io/time
        pub fn block_number() -> u64;
        /// Gets a bounded estimate of the Unix timestamp at which the Sequencer sequenced the
        /// transaction. See [`Block Numbers and Time`] for more information on how this value is
        /// determined.
        ///
        /// [`Block Numbers and Time`]: https://developer.arbitrum.io/time
        pub fn block_timestamp() -> u64;
        /// Calls the contract at the given address with options for passing value and to limit the
        /// amount of gas supplied. The return status indicates whether the call succeeded, and is
        /// nonzero on failure.
        ///
        /// In both cases `return_data_len` will store the length of the result, the bytes of which can
        /// be read via the `read_return_data` hostio. The bytes are not returned directly so that the
        /// programmer can potentially save gas by choosing which subset of the return result they'd
        /// like to copy.
        ///
        /// The semantics are equivalent to that of the EVM's [`CALL`] opcode, including callvalue
        /// stipends and the 63/64 gas rule. This means that supplying the `u64::MAX` gas can be used
        /// to send as much as possible.
        ///
        /// [`CALL`]: https://www.evm.codes/#f1
        pub fn call_contract(
            contract: *const u8,
            calldata: *const u8,
            calldata_len: usize,
            value: *const u8,
            gas: u64,
            return_data_len: *mut usize,
        ) -> u8;
        /// Gets the address of the current program. The semantics are equivalent to that of the EVM's
        /// [`ADDRESS`] opcode.
        ///
        /// [`ADDRESS`]: https://www.evm.codes/#30
        pub fn contract_address(address: *mut u8);
        /// Deploys a new contract using the init code provided, which the EVM executes to construct
        /// the code of the newly deployed contract. The init code must be written in EVM bytecode, but
        /// the code it deploys can be that of a Stylus program. The code returned will be treated as
        /// WASM if it begins with the EOF-inspired header `0xEFF000`. Otherwise the code will be
        /// interpreted as that of a traditional EVM-style contract. See [`Deploying Stylus Programs`]
        /// for more information on writing init code.
        ///
        /// On success, this hostio returns the address of the newly created account whose address is
        /// a function of the sender and nonce. On failure the address will be `0`, `return_data_len`
        /// will store the length of the revert data, the bytes of which can be read via the
        /// `read_return_data` hostio. The semantics are equivalent to that of the EVM's [`CREATE`]
        /// opcode, which notably includes the exact address returned.
        ///
        /// [`Deploying Stylus Programs`]: https://developer.arbitrum.io/TODO
        /// [`CREATE`]: https://www.evm.codes/#f0
        pub fn create1(
            code: *const u8,
            code_len: usize,
            endowment: *const u8,
            contract: *mut u8,
            revert_data_len: *mut usize,
        );
        /// Deploys a new contract using the init code provided, which the EVM executes to construct
        /// the code of the newly deployed contract. The init code must be written in EVM bytecode, but
        /// the code it deploys can be that of a Stylus program. The code returned will be treated as
        /// WASM if it begins with the EOF-inspired header `0xEFF000`. Otherwise the code will be
        /// interpreted as that of a traditional EVM-style contract. See [`Deploying Stylus Programs`]
        /// for more information on writing init code.
        ///
        /// On success, this hostio returns the address of the newly created account whose address is a
        /// function of the sender, salt, and init code. On failure the address will be `0`,
        /// `return_data_len` will store the length of the revert data, the bytes of which can be read
        /// via the `read_return_data` hostio. The semantics are equivalent to that of the EVM's
        /// `[CREATE2`] opcode, which notably includes the exact address returned.
        ///
        /// [`Deploying Stylus Programs`]: https://developer.arbitrum.io/TODO
        /// [`CREATE2`]: https://www.evm.codes/#f5
        pub fn create2(
            code: *const u8,
            code_len: usize,
            endowment: *const u8,
            salt: *const u8,
            contract: *mut u8,
            revert_data_len: *mut usize,
        );
        /// Delegate calls the contract at the given address, with the option to limit the amount of
        /// gas supplied. The return status indicates whether the call succeeded, and is nonzero on
        /// failure.
        ///
        /// In both cases `return_data_len` will store the length of the result, the bytes of which
        /// can be read via the `read_return_data` hostio. The bytes are not returned directly so that
        /// the programmer can potentially save gas by choosing which subset of the return result
        /// they'd like to copy.
        ///
        /// The semantics are equivalent to that of the EVM's [`DELEGATE_CALL`] opcode, including the
        /// 63/64 gas rule. This means that supplying `u64::MAX` gas can be used to send as much as
        /// possible.
        ///
        /// [`DELEGATE_CALL`]: https://www.evm.codes/#F4
        pub fn delegate_call_contract(
            contract: *const u8,
            calldata: *const u8,
            calldata_len: usize,
            gas: u64,
            return_data_len: *mut usize,
        ) -> u8;
        /// Emits an EVM log with the given number of topics and data, the first bytes of which should
        /// be the 32-byte-aligned topic data. The semantics are equivalent to that of the EVM's
        /// [`LOG0`], [`LOG1`], [`LOG2`], [`LOG3`], and [`LOG4`] opcodes based on the number of topics
        /// specified. Requesting more than `4` topics will induce a revert.
        ///
        /// [`LOG0`]: https://www.evm.codes/#a0
        /// [`LOG1`]: https://www.evm.codes/#a1
        /// [`LOG2`]: https://www.evm.codes/#a2
        /// [`LOG3`]: https://www.evm.codes/#a3
        /// [`LOG4`]: https://www.evm.codes/#a4
        pub fn emit_log(data: *const u8, len: usize, topics: usize);
        /// Gets the amount of gas left after paying for the cost of this hostio. The semantics are
        /// equivalent to that of the EVM's [`GAS`] opcode.
        ///
        /// [`GAS`]: https://www.evm.codes/#5a
        pub fn evm_gas_left() -> u64;
        /// Gets the amount of ink remaining after paying for the cost of this hostio. The semantics
        /// are equivalent to that of the EVM's [`GAS`] opcode, except the units are in ink. See
        /// [`Ink and Gas`] for more information on Stylus's compute pricing.
        ///
        /// [`GAS`]: https://www.evm.codes/#5a
        /// [`Ink and Gas`]: https://developer.arbitrum.io/TODO
        pub fn evm_ink_left() -> u64;
        /// The `entrypoint!` macro handles importing this hostio, which is required if the
        /// program's memory grows. Otherwise compilation through the `ArbWasm` precompile will revert.
        /// Internally the Stylus VM forces calls to this hostio whenever new WASM pages are allocated.
        /// Calls made voluntarily will unproductively consume gas.
        pub fn pay_for_memory_grow(pages: u16);
        /// Whether the current call is reentrant.
        pub fn msg_reentrant() -> bool;
        /// Gets the address of the account that called the program. For normal L2-to-L2 transactions
        /// the semantics are equivalent to that of the EVM's [`CALLER`] opcode, including in cases
        /// arising from [`DELEGATE_CALL`].
        ///
        /// For L1-to-L2 retryable ticket transactions, the top-level sender's address will be aliased.
        /// See [`Retryable Ticket Address Aliasing`] for more information on how this works.
        ///
        /// [`CALLER`]: https://www.evm.codes/#33
        /// [`DELEGATE_CALL`]: https://www.evm.codes/#f4
        /// [`Retryable Ticket Address Aliasing`]: https://developer.arbitrum.io/arbos/l1-to-l2-messaging#address-aliasing
        pub fn msg_sender(sender: *mut u8);
        /// Get the ETH value in wei sent to the program. The semantics are equivalent to that of the
        /// EVM's [`CALLVALUE`] opcode.
        ///
        /// [`CALLVALUE`]: https://www.evm.codes/#34
        pub fn msg_value(value: *mut u8);
        /// Efficiently computes the [`keccak256`] hash of the given preimage.
        /// The semantics are equivalent to that of the EVM's [`SHA3`] opcode.
        ///
        /// [`keccak256`]: https://en.wikipedia.org/wiki/SHA-3
        /// [`SHA3`]: https://www.evm.codes/#20
        #[allow(unused)]
        pub fn native_keccak256(bytes: *const u8, len: usize, output: *mut u8);
        /// Reads the program calldata. The semantics are equivalent to that of the EVM's
        /// [`CALLDATA_COPY`] opcode when requesting the entirety of the current call's calldata.
        ///
        /// [`CALLDATA_COPY`]: https://www.evm.codes/#37
        pub fn read_args(dest: *mut u8);
        /// Copies the bytes of the last EVM call or deployment return result. Does not revert if out of
        /// bounds, but rather copies the overlapping portion. The semantics are otherwise equivalent
        /// to that of the EVM's [`RETURN_DATA_COPY`] opcode.
        ///
        /// Returns the number of bytes written.
        ///
        /// [`RETURN_DATA_COPY`]: https://www.evm.codes/#3e
        pub fn read_return_data(dest: *mut u8, offset: usize, size: usize) -> usize;
        /// Writes the final return data. If not called before the program exists, the return data will
        /// be 0 bytes long. Note that this hostio does not cause the program to exit, which happens
        /// naturally when `user_entrypoint` returns.
        pub fn write_result(data: *const u8, len: usize);
        /// Returns the length of the last EVM call or deployment return result, or `0` if neither have
        /// happened during the program's execution. The semantics are equivalent to that of the EVM's
        /// [`RETURN_DATA_SIZE`] opcode.
        ///
        /// [`RETURN_DATA_SIZE`]: https://www.evm.codes/#3d
        pub fn return_data_size() -> usize;
        /// Static calls the contract at the given address, with the option to limit the amount of gas
        /// supplied. The return status indicates whether the call succeeded, and is nonzero on
        /// failure.
        ///
        /// In both cases `return_data_len` will store the length of the result, the bytes of which can
        /// be read via the `read_return_data` hostio. The bytes are not returned directly so that the
        /// programmer can potentially save gas by choosing which subset of the return result they'd
        /// like to copy.
        ///
        /// The semantics are equivalent to that of the EVM's [`STATIC_CALL`] opcode, including the
        /// 63/64 gas rule. This means that supplying `u64::MAX` gas can be used to send as much as
        /// possible.
        ///
        /// [`STATIC_CALL`]: https://www.evm.codes/#FA
        pub fn static_call_contract(
            contract: *const u8,
            calldata: *const u8,
            calldata_len: usize,
            gas: u64,
            return_data_len: *mut usize,
        ) -> u8;
        /// Gets the gas price in wei per gas, which on Arbitrum chains equals the basefee. The
        /// semantics are equivalent to that of the EVM's [`GAS_PRICE`] opcode.
        ///
        /// [`GAS_PRICE`]: https://www.evm.codes/#3A
        pub fn tx_gas_price(gas_price: *mut u8);
        /// Gets the price of ink in evm gas basis points. See [`Ink and Gas`] for more information on
        /// Stylus's compute-pricing model.
        ///
        /// [`Ink and Gas`]: https://developer.arbitrum.io/TODO
        pub fn tx_ink_price() -> u32;
        /// Gets the top-level sender of the transaction. The semantics are equivalent to that of the
        /// EVM's [`ORIGIN`] opcode.
        ///
        /// [`ORIGIN`]: https://www.evm.codes/#32
        pub fn tx_origin(origin: *mut u8);
    }
    #[allow(dead_code)]
    #[link(wasm_import_module = "console")]
    extern "C" {
        /// Prints a 32-bit floating point number to the console. Only available in debug mode with
        /// floating point enabled.
        pub fn log_f32(value: f32);
        /// Prints a 64-bit floating point number to the console. Only available in debug mode with
        /// floating point enabled.
        pub fn log_f64(value: f64);
        /// Prints a 32-bit integer to the console, which can be either signed or unsigned.
        /// Only available in debug mode.
        pub fn log_i32(value: i32);
        /// Prints a 64-bit integer to the console, which can be either signed or unsigned.
        /// Only available in debug mode.
        pub fn log_i64(value: i64);
        /// Prints a UTF-8 encoded string to the console. Only available in debug mode.
        pub fn log_txt(text: *const u8, len: usize);
    }
    pub(crate) use wrap_hostio;
    /// Caches a value to avoid paying for hostio invocations.
    pub(crate) struct CachedOption<T: Copy> {
        value: Option<T>,
        loader: fn() -> T,
    }
    impl<T: Copy> CachedOption<T> {
        /// Creates a new [`CachedOption`], which will use the `loader` during `get`.
        pub const fn new(loader: fn() -> T) -> Self {
            let value = None;
            Self { value, loader }
        }
        /// Sets and overwrites the cached value.
        pub fn set(&mut self, value: T) {
            self.value = Some(value);
        }
        /// Gets the value, writing it to the cache if necessary.
        pub fn get(&mut self) -> T {
            *self.value.get_or_insert_with(|| (self.loader)())
        }
    }
}
use alloc::vec::Vec;
/// Represents a contract invocation outcome.
pub type ArbResult = Result<Vec<u8>, Vec<u8>>;
