#![feature(prelude_import)]
//! Procedural macros for [The Stylus SDK][sdk].
//!
//! You can import these via
//!
//! ```ignore
//! use stylus_sdk::prelude::*;
//! ```
//!
//! For a guided exploration of the features, please see the comprehensive [Feature Overview][overview].
//!
//! [overview]: https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#calls
//! [sdk]: https://docs.rs/stylus-sdk/latest/stylus_sdk/index.html
#![warn(missing_docs)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use proc_macro::TokenStream;
mod calls {
    use crate::types::solidity_type_info;
    use convert_case::{Case, Casing};
    use proc_macro::TokenStream;
    use proc_macro2::Ident;
    use quote::quote;
    use sha3::{Digest, Keccak256};
    use std::borrow::Cow;
    use syn_solidity::{
        FunctionAttribute, Item, Mutability, SolIdent, Spanned, Visibility,
    };
    pub fn sol_interface(input: TokenStream) -> TokenStream {
        let input = match syn_solidity::parse(input) {
            Ok(f) => f,
            Err(err) => return err.to_compile_error().into(),
        };
        use crate::types::Purity::*;
        let alloy_address = {
            let mut _s = ::quote::__private::TokenStream::new();
            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "alloy_primitives");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "Address");
            _s
        };
        let sol_address = {
            let mut _s = ::quote::__private::TokenStream::new();
            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "alloy_sol_types");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "sol_data");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "Address");
            _s
        };
        let sol_type = {
            let mut _s = ::quote::__private::TokenStream::new();
            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "alloy_sol_types");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "SolType");
            _s
        };
        let sol_value = {
            let mut _s = ::quote::__private::TokenStream::new();
            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "alloy_sol_types");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "SolValue");
            _s
        };
        let sol_type_value = {
            let mut _s = ::quote::__private::TokenStream::new();
            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "alloy_sol_types");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "private");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "SolTypeValue");
            _s
        };
        let mut output = ::quote::__private::TokenStream::new();
        let mut method_impls = ::quote::__private::TokenStream::new();
        for item in input.items {
            let Item::Contract(contract) = item else {
                {
                    let error = syn::Error::new(
                        syn::spanned::Spanned::span(&item.span()),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("not an interface"),
                            );
                            res
                        },
                    );
                    return error.to_compile_error().into();
                }
            };
            if !contract.is_interface() {
                {
                    let error = syn::Error::new(
                        syn::spanned::Spanned::span(&contract.kind.span()),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("not an interface"),
                            );
                            res
                        },
                    );
                    return error.to_compile_error().into();
                };
            }
            let name = &contract.name;
            for item in contract.body {
                let Item::Function(func) = item else {
                    continue;
                };
                let Some(name) = &func.name else {
                    continue;
                };
                let mut purity = None;
                for attr in &func.attributes.0 {
                    if let FunctionAttribute::Mutability(mutability) = attr {
                        if purity.is_some() {
                            {
                                let error = syn::Error::new(
                                    syn::spanned::Spanned::span(&attr.span()),
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("more than one purity attribute specified"),
                                        );
                                        res
                                    },
                                );
                                return error.to_compile_error().into();
                            };
                        }
                        purity = Some(
                            match mutability {
                                Mutability::Constant(_) | Mutability::Pure(_) => Pure,
                                Mutability::View(_) => View,
                                Mutability::Payable(_) => Payable,
                            },
                        );
                    }
                    if let FunctionAttribute::Visibility(vis) = attr {
                        if let Visibility::Internal(_) | Visibility::Private(_) = vis {
                            {
                                let error = syn::Error::new(
                                    syn::spanned::Spanned::span(&vis.span()),
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("internal method in interface"),
                                        );
                                        res
                                    },
                                );
                                return error.to_compile_error().into();
                            };
                        }
                    }
                }
                let purity = purity.unwrap_or(Write);
                let (context, call) = match purity {
                    Pure | View => {
                        (
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "impl");
                                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "call");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(
                                    &mut _s,
                                    "StaticCallContext",
                                );
                                _s
                            },
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "call");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "static_call");
                                _s
                            },
                        )
                    }
                    Write => {
                        (
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "impl");
                                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "call");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(
                                    &mut _s,
                                    "NonPayableCallContext",
                                );
                                _s
                            },
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "call");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "call");
                                _s
                            },
                        )
                    }
                    Payable => {
                        (
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "impl");
                                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "call");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(
                                    &mut _s,
                                    "MutatingCallContext",
                                );
                                _s
                            },
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "call");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "call");
                                _s
                            },
                        )
                    }
                };
                let return_type = match func.return_type() {
                    Some(ty) => solidity_type_info(&ty).0,
                    None => Cow::from("()"),
                };
                let return_type: syn::Type = match syn::parse_str(&&return_type) {
                    Ok(ty) => ty,
                    Err(err) => return err.to_compile_error().into(),
                };
                let mut selector = Keccak256::new();
                selector.update(name.to_string());
                selector.update("(");
                let mut sol_args = ::alloc::vec::Vec::new();
                let mut rust_args = ::alloc::vec::Vec::new();
                let mut rust_arg_names = ::alloc::vec::Vec::new();
                for (i, arg) in func.parameters.iter().enumerate() {
                    let (sol_path, abi) = solidity_type_info(&arg.ty);
                    if i > 0 {
                        selector.update(",");
                    }
                    selector.update(&*abi);
                    let ty: syn::Type = match syn::parse_str(&&sol_path) {
                        Ok(ty) => ty,
                        Err(err) => return err.to_compile_error().into(),
                    };
                    let name = arg
                        .name
                        .as_ref()
                        .map(Cow::Borrowed)
                        .unwrap_or_else(|| Cow::Owned(
                            SolIdent::new(
                                &{
                                    let res = ::alloc::fmt::format(
                                        format_args!("argument_{0}", i),
                                    );
                                    res
                                },
                            ),
                        ));
                    rust_args
                        .push({
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::ToTokens::to_tokens(&name, &mut _s);
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::__private::push_lt(&mut _s);
                            ::quote::ToTokens::to_tokens(&ty, &mut _s);
                            ::quote::__private::push_ident(&mut _s, "as");
                            ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                            ::quote::__private::push_gt(&mut _s);
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "RustType");
                            _s
                        });
                    sol_args.push(ty);
                    rust_arg_names.push(name);
                }
                selector.update(")");
                let selector = selector.finalize();
                let selector0 = selector[0];
                let selector1 = selector[1];
                let selector2 = selector[2];
                let selector3 = selector[3];
                let rust_name = Ident::new(
                    &name.to_string().to_case(Case::Snake),
                    name.span(),
                );
                method_impls
                    .extend({
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "pub");
                        ::quote::__private::push_ident(&mut _s, "fn");
                        ::quote::ToTokens::to_tokens(&rust_name, &mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_and(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "self");
                                ::quote::__private::push_comma(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "context");
                                ::quote::__private::push_colon(&mut _s);
                                ::quote::ToTokens::to_tokens(&context, &mut _s);
                                {
                                    use ::quote::__private::ext::*;
                                    let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                                    #[allow(unused_mut)]
                                    let (mut rust_args, i) = rust_args.quote_into_iter();
                                    let has_iter = has_iter | i;
                                    let _: ::quote::__private::HasIterator = has_iter;
                                    while true {
                                        let rust_args = match rust_args.next() {
                                            Some(_x) => ::quote::__private::RepInterp(_x),
                                            None => break,
                                        };
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::ToTokens::to_tokens(&rust_args, &mut _s);
                                    }
                                }
                                _s
                            },
                        );
                        ::quote::__private::push_rarrow(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "Result");
                        ::quote::__private::push_shl(&mut _s);
                        ::quote::ToTokens::to_tokens(&return_type, &mut _s);
                        ::quote::__private::push_ident(&mut _s, "as");
                        ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                        ::quote::__private::push_gt(&mut _s);
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "RustType");
                        ::quote::__private::push_comma(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "call");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "Error");
                        ::quote::__private::push_gt(&mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "use");
                                ::quote::__private::push_ident(&mut _s, "alloc");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "vec");
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "let");
                                ::quote::__private::push_ident(&mut _s, "args");
                                ::quote::__private::push_eq(&mut _s);
                                ::quote::__private::push_lt(&mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        {
                                            use ::quote::__private::ext::*;
                                            let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                                            #[allow(unused_mut)]
                                            let (mut sol_args, i) = sol_args.quote_into_iter();
                                            let has_iter = has_iter | i;
                                            let _: ::quote::__private::HasIterator = has_iter;
                                            while true {
                                                let sol_args = match sol_args.next() {
                                                    Some(_x) => ::quote::__private::RepInterp(_x),
                                                    None => break,
                                                };
                                                ::quote::ToTokens::to_tokens(&sol_args, &mut _s);
                                                ::quote::__private::push_comma(&mut _s);
                                            }
                                        }
                                        _s
                                    },
                                );
                                ::quote::__private::push_ident(&mut _s, "as");
                                ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                                ::quote::__private::push_gt(&mut _s);
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "abi_encode");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_and(&mut _s);
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Parenthesis,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                {
                                                    use ::quote::__private::ext::*;
                                                    let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                                                    #[allow(unused_mut)]
                                                    let (mut rust_arg_names, i) = rust_arg_names
                                                        .quote_into_iter();
                                                    let has_iter = has_iter | i;
                                                    let _: ::quote::__private::HasIterator = has_iter;
                                                    while true {
                                                        let rust_arg_names = match rust_arg_names.next() {
                                                            Some(_x) => ::quote::__private::RepInterp(_x),
                                                            None => break,
                                                        };
                                                        ::quote::ToTokens::to_tokens(&rust_arg_names, &mut _s);
                                                        ::quote::__private::push_comma(&mut _s);
                                                    }
                                                }
                                                _s
                                            },
                                        );
                                        _s
                                    },
                                );
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "let");
                                ::quote::__private::push_ident(&mut _s, "mut");
                                ::quote::__private::push_ident(&mut _s, "calldata");
                                ::quote::__private::push_eq(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "vec");
                                ::quote::__private::push_bang(&mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Bracket,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::ToTokens::to_tokens(&selector0, &mut _s);
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::ToTokens::to_tokens(&selector1, &mut _s);
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::ToTokens::to_tokens(&selector2, &mut _s);
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::ToTokens::to_tokens(&selector3, &mut _s);
                                        _s
                                    },
                                );
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "calldata");
                                ::quote::__private::push_dot(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "extend");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "args");
                                        _s
                                    },
                                );
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "let");
                                ::quote::__private::push_ident(&mut _s, "returned");
                                ::quote::__private::push_eq(&mut _s);
                                ::quote::ToTokens::to_tokens(&call, &mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "context");
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "self");
                                        ::quote::__private::push_dot(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "address");
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::push_and(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "calldata");
                                        _s
                                    },
                                );
                                ::quote::__private::push_question(&mut _s);
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "Ok");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_lt(&mut _s);
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Parenthesis,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                ::quote::ToTokens::to_tokens(&return_type, &mut _s);
                                                ::quote::__private::push_comma(&mut _s);
                                                _s
                                            },
                                        );
                                        ::quote::__private::push_ident(&mut _s, "as");
                                        ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                                        ::quote::__private::push_gt(&mut _s);
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "abi_decode");
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Parenthesis,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                ::quote::__private::push_and(&mut _s);
                                                ::quote::__private::push_ident(&mut _s, "returned");
                                                ::quote::__private::push_comma(&mut _s);
                                                ::quote::__private::push_ident(&mut _s, "true");
                                                _s
                                            },
                                        );
                                        ::quote::__private::push_question(&mut _s);
                                        ::quote::__private::push_dot(&mut _s);
                                        ::quote::__private::parse(&mut _s, "0");
                                        _s
                                    },
                                );
                                _s
                            },
                        );
                        _s
                    });
            }
            output
                .extend({
                    let mut _s = ::quote::__private::TokenStream::new();
                    ::quote::__private::push_ident(&mut _s, "pub");
                    ::quote::__private::push_ident(&mut _s, "struct");
                    ::quote::ToTokens::to_tokens(&name, &mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "pub");
                            ::quote::__private::push_ident(&mut _s, "address");
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::ToTokens::to_tokens(&alloy_address, &mut _s);
                            ::quote::__private::push_comma(&mut _s);
                            _s
                        },
                    );
                    ::quote::__private::push_ident(&mut _s, "impl");
                    ::quote::ToTokens::to_tokens(&name, &mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "pub");
                            ::quote::__private::push_ident(&mut _s, "fn");
                            ::quote::__private::push_ident(&mut _s, "new");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "address");
                                    ::quote::__private::push_colon(&mut _s);
                                    ::quote::ToTokens::to_tokens(&alloy_address, &mut _s);
                                    _s
                                },
                            );
                            ::quote::__private::push_rarrow(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "Self");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "Self");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Brace,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "address");
                                            _s
                                        },
                                    );
                                    _s
                                },
                            );
                            ::quote::ToTokens::to_tokens(&method_impls, &mut _s);
                            _s
                        },
                    );
                    ::quote::__private::push_ident(&mut _s, "impl");
                    ::quote::__private::push_ident(&mut _s, "core");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "ops");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "Deref");
                    ::quote::__private::push_ident(&mut _s, "for");
                    ::quote::ToTokens::to_tokens(&name, &mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "type");
                            ::quote::__private::push_ident(&mut _s, "Target");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::ToTokens::to_tokens(&alloy_address, &mut _s);
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "fn");
                            ::quote::__private::push_ident(&mut _s, "deref");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_and(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "self");
                                    _s
                                },
                            );
                            ::quote::__private::push_rarrow(&mut _s);
                            ::quote::__private::push_and(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "Self");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "Target");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_and(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "self");
                                    ::quote::__private::push_dot(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "address");
                                    _s
                                },
                            );
                            _s
                        },
                    );
                    ::quote::__private::push_ident(&mut _s, "impl");
                    ::quote::ToTokens::to_tokens(&sol_value, &mut _s);
                    ::quote::__private::push_ident(&mut _s, "for");
                    ::quote::ToTokens::to_tokens(&name, &mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "type");
                            ::quote::__private::push_ident(&mut _s, "SolType");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::ToTokens::to_tokens(&name, &mut _s);
                            ::quote::__private::push_semi(&mut _s);
                            _s
                        },
                    );
                    ::quote::__private::push_ident(&mut _s, "impl");
                    ::quote::ToTokens::to_tokens(&sol_type_value, &mut _s);
                    ::quote::__private::push_lt(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "Self");
                    ::quote::__private::push_gt(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "for");
                    ::quote::ToTokens::to_tokens(&name, &mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_pound(&mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Bracket,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "inline");
                                    _s
                                },
                            );
                            ::quote::__private::push_ident(&mut _s, "fn");
                            ::quote::__private::push_ident(&mut _s, "stv_to_tokens");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_and(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "self");
                                    _s
                                },
                            );
                            ::quote::__private::push_rarrow(&mut _s);
                            ::quote::__private::push_lt(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "Self");
                            ::quote::__private::push_ident(&mut _s, "as");
                            ::quote::__private::push_ident(&mut _s, "alloy_sol_types");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "SolType");
                            ::quote::__private::push_gt(&mut _s);
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "Token");
                            ::quote::__private::push_lt(&mut _s);
                            ::quote::__private::push_lifetime(&mut _s, "\'_");
                            ::quote::__private::push_gt(&mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::ToTokens::to_tokens(&sol_address, &mut _s);
                                    ::quote::__private::push_ident(&mut _s, "as");
                                    ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                                    ::quote::__private::push_gt(&mut _s);
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "tokenize");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_and(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "self");
                                            ::quote::__private::push_dot(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "address");
                                            _s
                                        },
                                    );
                                    _s
                                },
                            );
                            ::quote::__private::push_pound(&mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Bracket,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "inline");
                                    _s
                                },
                            );
                            ::quote::__private::push_ident(&mut _s, "fn");
                            ::quote::__private::push_ident(
                                &mut _s,
                                "stv_abi_encoded_size",
                            );
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_and(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "self");
                                    _s
                                },
                            );
                            ::quote::__private::push_rarrow(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "usize");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::ToTokens::to_tokens(&sol_address, &mut _s);
                                    ::quote::__private::push_ident(&mut _s, "as");
                                    ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                                    ::quote::__private::push_gt(&mut _s);
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "abi_encoded_size");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_and(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "self");
                                            ::quote::__private::push_dot(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "address");
                                            _s
                                        },
                                    );
                                    _s
                                },
                            );
                            ::quote::__private::push_pound(&mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Bracket,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "inline");
                                    _s
                                },
                            );
                            ::quote::__private::push_ident(&mut _s, "fn");
                            ::quote::__private::push_ident(
                                &mut _s,
                                "stv_eip712_data_word",
                            );
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_and(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "self");
                                    _s
                                },
                            );
                            ::quote::__private::push_rarrow(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "alloy_sol_types");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "Word");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::ToTokens::to_tokens(&sol_address, &mut _s);
                                    ::quote::__private::push_ident(&mut _s, "as");
                                    ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                                    ::quote::__private::push_gt(&mut _s);
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "eip712_data_word");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_and(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "self");
                                            ::quote::__private::push_dot(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "address");
                                            _s
                                        },
                                    );
                                    _s
                                },
                            );
                            ::quote::__private::push_pound(&mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Bracket,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "inline");
                                    _s
                                },
                            );
                            ::quote::__private::push_ident(&mut _s, "fn");
                            ::quote::__private::push_ident(
                                &mut _s,
                                "stv_abi_encode_packed_to",
                            );
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_and(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "self");
                                    ::quote::__private::push_comma(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "out");
                                    ::quote::__private::push_colon(&mut _s);
                                    ::quote::__private::push_and(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "mut");
                                    ::quote::__private::push_ident(&mut _s, "alloy_sol_types");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "private");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "Vec");
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "u8");
                                    ::quote::__private::push_gt(&mut _s);
                                    _s
                                },
                            );
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::ToTokens::to_tokens(&sol_address, &mut _s);
                                    ::quote::__private::push_ident(&mut _s, "as");
                                    ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                                    ::quote::__private::push_gt(&mut _s);
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(
                                        &mut _s,
                                        "abi_encode_packed_to",
                                    );
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_and(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "self");
                                            ::quote::__private::push_dot(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "address");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "out");
                                            _s
                                        },
                                    );
                                    _s
                                },
                            );
                            _s
                        },
                    );
                    ::quote::__private::push_ident(&mut _s, "impl");
                    ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                    ::quote::__private::push_ident(&mut _s, "for");
                    ::quote::ToTokens::to_tokens(&name, &mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "type");
                            ::quote::__private::push_ident(&mut _s, "RustType");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::ToTokens::to_tokens(&name, &mut _s);
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "type");
                            ::quote::__private::push_ident(&mut _s, "Token");
                            ::quote::__private::push_lt(&mut _s);
                            ::quote::__private::push_lifetime(&mut _s, "\'a");
                            ::quote::__private::push_gt(&mut _s);
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::__private::push_lt(&mut _s);
                            ::quote::ToTokens::to_tokens(&sol_address, &mut _s);
                            ::quote::__private::push_ident(&mut _s, "as");
                            ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                            ::quote::__private::push_gt(&mut _s);
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "Token");
                            ::quote::__private::push_lt(&mut _s);
                            ::quote::__private::push_lifetime(&mut _s, "\'a");
                            ::quote::__private::push_gt(&mut _s);
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "const");
                            ::quote::__private::push_ident(&mut _s, "SOL_NAME");
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::__private::push_and(&mut _s);
                            ::quote::__private::push_lifetime(&mut _s, "\'static");
                            ::quote::__private::push_ident(&mut _s, "str");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::__private::push_lt(&mut _s);
                            ::quote::ToTokens::to_tokens(&sol_address, &mut _s);
                            ::quote::__private::push_ident(&mut _s, "as");
                            ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                            ::quote::__private::push_gt(&mut _s);
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "SOL_NAME");
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "const");
                            ::quote::__private::push_ident(&mut _s, "ENCODED_SIZE");
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "Option");
                            ::quote::__private::push_lt(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "usize");
                            ::quote::__private::push_gt(&mut _s);
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::__private::push_lt(&mut _s);
                            ::quote::ToTokens::to_tokens(&sol_address, &mut _s);
                            ::quote::__private::push_ident(&mut _s, "as");
                            ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                            ::quote::__private::push_gt(&mut _s);
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "ENCODED_SIZE");
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "fn");
                            ::quote::__private::push_ident(&mut _s, "valid_token");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "token");
                                    ::quote::__private::push_colon(&mut _s);
                                    ::quote::__private::push_and(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "Self");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "Token");
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::__private::push_lifetime(&mut _s, "\'_");
                                    ::quote::__private::push_gt(&mut _s);
                                    _s
                                },
                            );
                            ::quote::__private::push_rarrow(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "bool");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::ToTokens::to_tokens(&sol_address, &mut _s);
                                    ::quote::__private::push_ident(&mut _s, "as");
                                    ::quote::ToTokens::to_tokens(&sol_type, &mut _s);
                                    ::quote::__private::push_gt(&mut _s);
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "valid_token");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "token");
                                            _s
                                        },
                                    );
                                    _s
                                },
                            );
                            ::quote::__private::push_ident(&mut _s, "fn");
                            ::quote::__private::push_ident(&mut _s, "detokenize");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "token");
                                    ::quote::__private::push_colon(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "Self");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "Token");
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::__private::push_lifetime(&mut _s, "\'_");
                                    ::quote::__private::push_gt(&mut _s);
                                    _s
                                },
                            );
                            ::quote::__private::push_rarrow(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "Self");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "RustType");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::ToTokens::to_tokens(&name, &mut _s);
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "new");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::ToTokens::to_tokens(&sol_address, &mut _s);
                                            ::quote::__private::push_colon2(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "detokenize");
                                            ::quote::__private::push_group(
                                                &mut _s,
                                                ::quote::__private::Delimiter::Parenthesis,
                                                {
                                                    let mut _s = ::quote::__private::TokenStream::new();
                                                    ::quote::__private::push_ident(&mut _s, "token");
                                                    _s
                                                },
                                            );
                                            _s
                                        },
                                    );
                                    _s
                                },
                            );
                            _s
                        },
                    );
                    ::quote::__private::push_ident(&mut _s, "impl");
                    ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "abi");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "AbiType");
                    ::quote::__private::push_ident(&mut _s, "for");
                    ::quote::ToTokens::to_tokens(&name, &mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "type");
                            ::quote::__private::push_ident(&mut _s, "SolType");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::ToTokens::to_tokens(&name, &mut _s);
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "const");
                            ::quote::__private::push_ident(&mut _s, "ABI");
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "abi");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "ConstString");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::__private::push_lt(&mut _s);
                            ::quote::ToTokens::to_tokens(&alloy_address, &mut _s);
                            ::quote::__private::push_ident(&mut _s, "as");
                            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "abi");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "AbiType");
                            ::quote::__private::push_gt(&mut _s);
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "ABI");
                            ::quote::__private::push_semi(&mut _s);
                            _s
                        },
                    );
                    _s
                });
        }
        output.into()
    }
}
mod methods {
    pub mod entrypoint {
        use cfg_if::cfg_if;
        use proc_macro::TokenStream;
        use proc_macro2::{Ident, Span};
        use quote::quote;
        use syn::{parse_macro_input, Item};
        pub fn entrypoint(attr: TokenStream, input: TokenStream) -> TokenStream {
            let input: Item = match ::syn::parse_macro_input::parse::<_>(input) {
                ::syn::__private::Ok(data) => data,
                ::syn::__private::Err(err) => {
                    return ::syn::__private::TokenStream::from(err.to_compile_error());
                }
            };
            if !attr.is_empty() {
                {
                    let error = syn::Error::new(
                        syn::spanned::Spanned::span(&Span::mixed_site()),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("this macro is not configurable"),
                            );
                            res
                        },
                    );
                    return error.to_compile_error().into();
                };
            }
            let mut output = {
                let mut _s = ::quote::__private::TokenStream::new();
                ::quote::ToTokens::to_tokens(&input, &mut _s);
                _s
            };
            let user = match input {
                Item::Struct(input) => {
                    let name = &input.ident;
                    let (impl_generics, ty_generics, where_clause) = input
                        .generics
                        .split_for_impl();
                    output
                        .extend({
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "unsafe");
                            ::quote::__private::push_ident(&mut _s, "impl");
                            ::quote::ToTokens::to_tokens(&impl_generics, &mut _s);
                            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "storage");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "TopLevelStorage");
                            ::quote::__private::push_ident(&mut _s, "for");
                            ::quote::ToTokens::to_tokens(&name, &mut _s);
                            ::quote::ToTokens::to_tokens(&ty_generics, &mut _s);
                            ::quote::ToTokens::to_tokens(&where_clause, &mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                ::quote::__private::TokenStream::new(),
                            );
                            ::quote::__private::push_ident(&mut _s, "fn");
                            ::quote::__private::push_ident(&mut _s, "entrypoint");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "input");
                                    ::quote::__private::push_colon(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "alloc");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "vec");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "Vec");
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "u8");
                                    ::quote::__private::push_gt(&mut _s);
                                    _s
                                },
                            );
                            ::quote::__private::push_rarrow(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "ArbResult");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "use");
                                    ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Brace,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "abi");
                                            ::quote::__private::push_colon2(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "Router");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "alloy_primitives");
                                            ::quote::__private::push_colon2(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "U256");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "console");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "hex");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "storage");
                                            ::quote::__private::push_colon2(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "StorageType");
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_semi(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "use");
                                    ::quote::__private::push_ident(&mut _s, "core");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "convert");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "TryInto");
                                    ::quote::__private::push_semi(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "use");
                                    ::quote::__private::push_ident(&mut _s, "alloc");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "vec");
                                    ::quote::__private::push_semi(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "if");
                                    ::quote::__private::push_ident(&mut _s, "input");
                                    ::quote::__private::push_dot(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "len");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        ::quote::__private::TokenStream::new(),
                                    );
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::__private::parse(&mut _s, "4");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Brace,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "console");
                                            ::quote::__private::push_bang(&mut _s);
                                            ::quote::__private::push_group(
                                                &mut _s,
                                                ::quote::__private::Delimiter::Parenthesis,
                                                {
                                                    let mut _s = ::quote::__private::TokenStream::new();
                                                    ::quote::__private::parse(
                                                        &mut _s,
                                                        "\"calldata too short: {}\"",
                                                    );
                                                    ::quote::__private::push_comma(&mut _s);
                                                    ::quote::__private::push_ident(&mut _s, "hex");
                                                    ::quote::__private::push_colon2(&mut _s);
                                                    ::quote::__private::push_ident(&mut _s, "encode");
                                                    ::quote::__private::push_group(
                                                        &mut _s,
                                                        ::quote::__private::Delimiter::Parenthesis,
                                                        {
                                                            let mut _s = ::quote::__private::TokenStream::new();
                                                            ::quote::__private::push_ident(&mut _s, "input");
                                                            _s
                                                        },
                                                    );
                                                    _s
                                                },
                                            );
                                            ::quote::__private::push_semi(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "return");
                                            ::quote::__private::push_ident(&mut _s, "Err");
                                            ::quote::__private::push_group(
                                                &mut _s,
                                                ::quote::__private::Delimiter::Parenthesis,
                                                {
                                                    let mut _s = ::quote::__private::TokenStream::new();
                                                    ::quote::__private::push_ident(&mut _s, "vec");
                                                    ::quote::__private::push_bang(&mut _s);
                                                    ::quote::__private::push_group(
                                                        &mut _s,
                                                        ::quote::__private::Delimiter::Bracket,
                                                        ::quote::__private::TokenStream::new(),
                                                    );
                                                    _s
                                                },
                                            );
                                            ::quote::__private::push_semi(&mut _s);
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_ident(&mut _s, "let");
                                    ::quote::__private::push_ident(&mut _s, "selector");
                                    ::quote::__private::push_eq(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "u32");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "from_be_bytes");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "TryInto");
                                            ::quote::__private::push_colon2(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "try_into");
                                            ::quote::__private::push_group(
                                                &mut _s,
                                                ::quote::__private::Delimiter::Parenthesis,
                                                {
                                                    let mut _s = ::quote::__private::TokenStream::new();
                                                    ::quote::__private::push_and(&mut _s);
                                                    ::quote::__private::push_ident(&mut _s, "input");
                                                    ::quote::__private::push_group(
                                                        &mut _s,
                                                        ::quote::__private::Delimiter::Bracket,
                                                        {
                                                            let mut _s = ::quote::__private::TokenStream::new();
                                                            ::quote::__private::push_dot2(&mut _s);
                                                            ::quote::__private::parse(&mut _s, "4");
                                                            _s
                                                        },
                                                    );
                                                    _s
                                                },
                                            );
                                            ::quote::__private::push_dot(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "unwrap");
                                            ::quote::__private::push_group(
                                                &mut _s,
                                                ::quote::__private::Delimiter::Parenthesis,
                                                ::quote::__private::TokenStream::new(),
                                            );
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_semi(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "let");
                                    ::quote::__private::push_ident(&mut _s, "mut");
                                    ::quote::__private::push_ident(&mut _s, "storage");
                                    ::quote::__private::push_eq(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "unsafe");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Brace,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_lt(&mut _s);
                                            ::quote::ToTokens::to_tokens(&name, &mut _s);
                                            ::quote::__private::push_ident(&mut _s, "as");
                                            ::quote::__private::push_ident(&mut _s, "StorageType");
                                            ::quote::__private::push_gt(&mut _s);
                                            ::quote::__private::push_colon2(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "new");
                                            ::quote::__private::push_group(
                                                &mut _s,
                                                ::quote::__private::Delimiter::Parenthesis,
                                                {
                                                    let mut _s = ::quote::__private::TokenStream::new();
                                                    ::quote::__private::push_ident(&mut _s, "U256");
                                                    ::quote::__private::push_colon2(&mut _s);
                                                    ::quote::__private::push_ident(&mut _s, "ZERO");
                                                    ::quote::__private::push_comma(&mut _s);
                                                    ::quote::__private::parse(&mut _s, "0");
                                                    _s
                                                },
                                            );
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_semi(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "match");
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::ToTokens::to_tokens(&name, &mut _s);
                                    ::quote::__private::push_ident(&mut _s, "as");
                                    ::quote::__private::push_ident(&mut _s, "Router");
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::__private::push_underscore(&mut _s);
                                    ::quote::__private::push_shr(&mut _s);
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "route");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_and(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "mut");
                                            ::quote::__private::push_ident(&mut _s, "storage");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "selector");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::push_and(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "input");
                                            ::quote::__private::push_group(
                                                &mut _s,
                                                ::quote::__private::Delimiter::Bracket,
                                                {
                                                    let mut _s = ::quote::__private::TokenStream::new();
                                                    ::quote::__private::parse(&mut _s, "4");
                                                    ::quote::__private::push_dot2(&mut _s);
                                                    _s
                                                },
                                            );
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Brace,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "Some");
                                            ::quote::__private::push_group(
                                                &mut _s,
                                                ::quote::__private::Delimiter::Parenthesis,
                                                {
                                                    let mut _s = ::quote::__private::TokenStream::new();
                                                    ::quote::__private::push_ident(&mut _s, "res");
                                                    _s
                                                },
                                            );
                                            ::quote::__private::push_fat_arrow(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "res");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "None");
                                            ::quote::__private::push_fat_arrow(&mut _s);
                                            ::quote::__private::push_group(
                                                &mut _s,
                                                ::quote::__private::Delimiter::Brace,
                                                {
                                                    let mut _s = ::quote::__private::TokenStream::new();
                                                    ::quote::__private::push_ident(&mut _s, "console");
                                                    ::quote::__private::push_bang(&mut _s);
                                                    ::quote::__private::push_group(
                                                        &mut _s,
                                                        ::quote::__private::Delimiter::Parenthesis,
                                                        {
                                                            let mut _s = ::quote::__private::TokenStream::new();
                                                            ::quote::__private::parse(
                                                                &mut _s,
                                                                "\"unknown method selector: {selector:08x}\"",
                                                            );
                                                            _s
                                                        },
                                                    );
                                                    ::quote::__private::push_semi(&mut _s);
                                                    ::quote::__private::push_ident(&mut _s, "Err");
                                                    ::quote::__private::push_group(
                                                        &mut _s,
                                                        ::quote::__private::Delimiter::Parenthesis,
                                                        {
                                                            let mut _s = ::quote::__private::TokenStream::new();
                                                            ::quote::__private::push_ident(&mut _s, "vec");
                                                            ::quote::__private::push_bang(&mut _s);
                                                            ::quote::__private::push_group(
                                                                &mut _s,
                                                                ::quote::__private::Delimiter::Bracket,
                                                                ::quote::__private::TokenStream::new(),
                                                            );
                                                            _s
                                                        },
                                                    );
                                                    _s
                                                },
                                            );
                                            ::quote::__private::push_comma(&mut _s);
                                            _s
                                        },
                                    );
                                    _s
                                },
                            );
                            _s
                        });
                    if false {
                        output
                            .extend({
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "pub");
                                ::quote::__private::push_ident(&mut _s, "fn");
                                ::quote::__private::push_ident(&mut _s, "print_abi");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "license");
                                        ::quote::__private::push_colon(&mut _s);
                                        ::quote::__private::push_and(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "str");
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "pragma");
                                        ::quote::__private::push_colon(&mut _s);
                                        ::quote::__private::push_and(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "str");
                                        _s
                                    },
                                );
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Brace,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "abi");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "export");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "print_abi");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_lt(&mut _s);
                                        ::quote::ToTokens::to_tokens(&name, &mut _s);
                                        ::quote::__private::push_gt(&mut _s);
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Parenthesis,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                ::quote::__private::push_ident(&mut _s, "license");
                                                ::quote::__private::push_comma(&mut _s);
                                                ::quote::__private::push_ident(&mut _s, "pragma");
                                                _s
                                            },
                                        );
                                        ::quote::__private::push_semi(&mut _s);
                                        _s
                                    },
                                );
                                _s
                            });
                    }
                    Ident::new("entrypoint", name.span())
                }
                Item::Fn(input) => input.sig.ident.clone(),
                _ => {
                    let error = syn::Error::new(
                        syn::spanned::Spanned::span(&input),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("not a struct or fn"),
                            );
                            res
                        },
                    );
                    return error.to_compile_error().into();
                }
            };
            let deny_reentrant = {
                let mut _s = ::quote::__private::TokenStream::new();
                ::quote::__private::push_ident(&mut _s, "if");
                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "msg");
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "reentrant");
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Parenthesis,
                    ::quote::__private::TokenStream::new(),
                );
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Brace,
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "return");
                        ::quote::__private::parse(&mut _s, "1");
                        ::quote::__private::push_semi(&mut _s);
                        _s
                    },
                );
                _s
            };
            output
                .extend({
                    let mut _s = ::quote::__private::TokenStream::new();
                    ::quote::__private::push_pound(&mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Bracket,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "no_mangle");
                            _s
                        },
                    );
                    ::quote::__private::push_ident(&mut _s, "pub");
                    ::quote::__private::push_ident(&mut _s, "unsafe");
                    ::quote::__private::push_ident(&mut _s, "fn");
                    ::quote::__private::push_ident(&mut _s, "mark_used");
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        ::quote::__private::TokenStream::new(),
                    );
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "evm");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(
                                &mut _s,
                                "pay_for_memory_grow",
                            );
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::parse(&mut _s, "0");
                                    _s
                                },
                            );
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "panic");
                            ::quote::__private::push_bang(&mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                ::quote::__private::TokenStream::new(),
                            );
                            ::quote::__private::push_semi(&mut _s);
                            _s
                        },
                    );
                    ::quote::__private::push_pound(&mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Bracket,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "no_mangle");
                            _s
                        },
                    );
                    ::quote::__private::push_ident(&mut _s, "pub");
                    ::quote::__private::push_ident(&mut _s, "extern");
                    ::quote::__private::parse(&mut _s, "\"C\"");
                    ::quote::__private::push_ident(&mut _s, "fn");
                    ::quote::__private::push_ident(&mut _s, "user_entrypoint");
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "len");
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "usize");
                            _s
                        },
                    );
                    ::quote::__private::push_rarrow(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "usize");
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::ToTokens::to_tokens(&deny_reentrant, &mut _s);
                            ::quote::__private::push_ident(&mut _s, "let");
                            ::quote::__private::push_ident(&mut _s, "input");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "contract");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "args");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "len");
                                    _s
                                },
                            );
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "let");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "data");
                                    ::quote::__private::push_comma(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "status");
                                    _s
                                },
                            );
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "match");
                            ::quote::ToTokens::to_tokens(&user, &mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "input");
                                    _s
                                },
                            );
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "Ok");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "data");
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_fat_arrow(&mut _s);
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "data");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::parse(&mut _s, "0");
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_comma(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "Err");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "data");
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_fat_arrow(&mut _s);
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "data");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::parse(&mut _s, "1");
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_comma(&mut _s);
                                    _s
                                },
                            );
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "unsafe");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "storage");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "StorageCache");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "flush");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        ::quote::__private::TokenStream::new(),
                                    );
                                    _s
                                },
                            );
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "contract");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "output");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_and(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "data");
                                    _s
                                },
                            );
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "status");
                            _s
                        },
                    );
                    _s
                });
            output.into()
        }
    }
    pub mod error {
        use proc_macro::TokenStream;
        use quote::quote;
        use syn::{parse_macro_input, Fields, ItemEnum};
        pub fn derive_solidity_error(input: TokenStream) -> TokenStream {
            let input = match ::syn::parse_macro_input::parse::<ItemEnum>(input) {
                ::syn::__private::Ok(data) => data,
                ::syn::__private::Err(err) => {
                    return ::syn::__private::TokenStream::from(err.to_compile_error());
                }
            };
            let name = &input.ident;
            let mut match_arms = ::quote::__private::TokenStream::new();
            let mut errors = ::alloc::vec::Vec::new();
            let mut output = ::quote::__private::TokenStream::new();
            for variant in input.variants {
                let variant_name = variant.ident;
                let error = match variant.fields {
                    Fields::Unnamed(e) if variant.fields.len() == 1 => {
                        e.unnamed.first().unwrap().clone()
                    }
                    _ => {
                        let error = syn::Error::new(
                            syn::spanned::Spanned::span(&variant.fields),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Variant not a 1-tuple"),
                                );
                                res
                            },
                        );
                        return error.to_compile_error().into();
                    }
                };
                let ty = error.ty.clone();
                match_arms
                    .extend({
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::ToTokens::to_tokens(&name, &mut _s);
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::ToTokens::to_tokens(&variant_name, &mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "e");
                                _s
                            },
                        );
                        ::quote::__private::push_fat_arrow(&mut _s);
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "call");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "MethodError");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "encode");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "e");
                                _s
                            },
                        );
                        ::quote::__private::push_comma(&mut _s);
                        _s
                    });
                output
                    .extend({
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "impl");
                        ::quote::__private::push_ident(&mut _s, "From");
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                        ::quote::__private::push_gt(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "for");
                        ::quote::ToTokens::to_tokens(&name, &mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "fn");
                                ::quote::__private::push_ident(&mut _s, "from");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "value");
                                        ::quote::__private::push_colon(&mut _s);
                                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                                        _s
                                    },
                                );
                                ::quote::__private::push_rarrow(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "Self");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Brace,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::ToTokens::to_tokens(&name, &mut _s);
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::ToTokens::to_tokens(&variant_name, &mut _s);
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Parenthesis,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                ::quote::__private::push_ident(&mut _s, "value");
                                                _s
                                            },
                                        );
                                        _s
                                    },
                                );
                                _s
                            },
                        );
                        _s
                    });
                errors.push(error);
            }
            output
                .extend({
                    let mut _s = ::quote::__private::TokenStream::new();
                    ::quote::__private::push_ident(&mut _s, "impl");
                    ::quote::__private::push_ident(&mut _s, "From");
                    ::quote::__private::push_lt(&mut _s);
                    ::quote::ToTokens::to_tokens(&name, &mut _s);
                    ::quote::__private::push_gt(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "for");
                    ::quote::__private::push_ident(&mut _s, "alloc");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "vec");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "Vec");
                    ::quote::__private::push_lt(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "u8");
                    ::quote::__private::push_gt(&mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "fn");
                            ::quote::__private::push_ident(&mut _s, "from");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "err");
                                    ::quote::__private::push_colon(&mut _s);
                                    ::quote::ToTokens::to_tokens(&name, &mut _s);
                                    _s
                                },
                            );
                            ::quote::__private::push_rarrow(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "alloc");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "vec");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "Vec");
                            ::quote::__private::push_lt(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "u8");
                            ::quote::__private::push_gt(&mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "match");
                                    ::quote::__private::push_ident(&mut _s, "err");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Brace,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::ToTokens::to_tokens(&match_arms, &mut _s);
                                            _s
                                        },
                                    );
                                    _s
                                },
                            );
                            _s
                        },
                    );
                    _s
                });
            if false {
                output
                    .extend({
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "impl");
                        ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "abi");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "export");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "internal");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "InnerTypes");
                        ::quote::__private::push_ident(&mut _s, "for");
                        ::quote::ToTokens::to_tokens(&name, &mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "fn");
                                ::quote::__private::push_ident(&mut _s, "inner_types");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    ::quote::__private::TokenStream::new(),
                                );
                                ::quote::__private::push_rarrow(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "alloc");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "vec");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "Vec");
                                ::quote::__private::push_lt(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "abi");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "export");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "internal");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "InnerType");
                                ::quote::__private::push_gt(&mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Brace,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "use");
                                        ::quote::__private::push_ident(&mut _s, "alloc");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Brace,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                ::quote::__private::push_ident(&mut _s, "format");
                                                ::quote::__private::push_comma(&mut _s);
                                                ::quote::__private::push_ident(&mut _s, "vec");
                                                _s
                                            },
                                        );
                                        ::quote::__private::push_semi(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "use");
                                        ::quote::__private::push_ident(&mut _s, "core");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "any");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "TypeId");
                                        ::quote::__private::push_semi(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "use");
                                        ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "abi");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "export");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "internal");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "InnerType");
                                        ::quote::__private::push_semi(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "use");
                                        ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "alloy_sol_types");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "SolError");
                                        ::quote::__private::push_semi(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "vec");
                                        ::quote::__private::push_bang(&mut _s);
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Bracket,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                {
                                                    use ::quote::__private::ext::*;
                                                    let mut _i = 0usize;
                                                    let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                                                    #[allow(unused_mut)]
                                                    let (mut errors, i) = errors.quote_into_iter();
                                                    let has_iter = has_iter | i;
                                                    #[allow(unused_mut)]
                                                    let (mut errors, i) = errors.quote_into_iter();
                                                    let has_iter = has_iter | i;
                                                    let _: ::quote::__private::HasIterator = has_iter;
                                                    while true {
                                                        let errors = match errors.next() {
                                                            Some(_x) => ::quote::__private::RepInterp(_x),
                                                            None => break,
                                                        };
                                                        let errors = match errors.next() {
                                                            Some(_x) => ::quote::__private::RepInterp(_x),
                                                            None => break,
                                                        };
                                                        if _i > 0 {
                                                            ::quote::__private::push_comma(&mut _s);
                                                        }
                                                        _i += 1;
                                                        ::quote::__private::push_ident(&mut _s, "InnerType");
                                                        ::quote::__private::push_group(
                                                            &mut _s,
                                                            ::quote::__private::Delimiter::Brace,
                                                            {
                                                                let mut _s = ::quote::__private::TokenStream::new();
                                                                ::quote::__private::push_ident(&mut _s, "name");
                                                                ::quote::__private::push_colon(&mut _s);
                                                                ::quote::__private::push_ident(&mut _s, "format");
                                                                ::quote::__private::push_bang(&mut _s);
                                                                ::quote::__private::push_group(
                                                                    &mut _s,
                                                                    ::quote::__private::Delimiter::Parenthesis,
                                                                    {
                                                                        let mut _s = ::quote::__private::TokenStream::new();
                                                                        ::quote::__private::parse(&mut _s, "\"error {};\"");
                                                                        ::quote::__private::push_comma(&mut _s);
                                                                        ::quote::__private::push_lt(&mut _s);
                                                                        ::quote::ToTokens::to_tokens(&errors, &mut _s);
                                                                        ::quote::__private::push_ident(&mut _s, "as");
                                                                        ::quote::__private::push_ident(&mut _s, "SolError");
                                                                        ::quote::__private::push_gt(&mut _s);
                                                                        ::quote::__private::push_colon2(&mut _s);
                                                                        ::quote::__private::push_ident(&mut _s, "SIGNATURE");
                                                                        ::quote::__private::push_dot(&mut _s);
                                                                        ::quote::__private::push_ident(&mut _s, "replace");
                                                                        ::quote::__private::push_group(
                                                                            &mut _s,
                                                                            ::quote::__private::Delimiter::Parenthesis,
                                                                            {
                                                                                let mut _s = ::quote::__private::TokenStream::new();
                                                                                ::quote::__private::parse(&mut _s, "\',\'");
                                                                                ::quote::__private::push_comma(&mut _s);
                                                                                ::quote::__private::parse(&mut _s, "\", \"");
                                                                                _s
                                                                            },
                                                                        );
                                                                        _s
                                                                    },
                                                                );
                                                                ::quote::__private::push_comma(&mut _s);
                                                                ::quote::__private::push_ident(&mut _s, "id");
                                                                ::quote::__private::push_colon(&mut _s);
                                                                ::quote::__private::push_ident(&mut _s, "TypeId");
                                                                ::quote::__private::push_colon2(&mut _s);
                                                                ::quote::__private::push_ident(&mut _s, "of");
                                                                ::quote::__private::push_colon2(&mut _s);
                                                                ::quote::__private::push_lt(&mut _s);
                                                                ::quote::ToTokens::to_tokens(&errors, &mut _s);
                                                                ::quote::__private::push_gt(&mut _s);
                                                                ::quote::__private::push_group(
                                                                    &mut _s,
                                                                    ::quote::__private::Delimiter::Parenthesis,
                                                                    ::quote::__private::TokenStream::new(),
                                                                );
                                                                ::quote::__private::push_comma(&mut _s);
                                                                _s
                                                            },
                                                        );
                                                    }
                                                }
                                                _s
                                            },
                                        );
                                        _s
                                    },
                                );
                                _s
                            },
                        );
                        _s
                    });
            }
            output.into()
        }
    }
    pub mod external {
        use crate::types::{self, Purity};
        use convert_case::{Case, Casing};
        use proc_macro::TokenStream;
        use proc_macro2::Ident;
        use quote::{quote, quote_spanned};
        use std::{mem, str::FromStr};
        use syn::{
            parenthesized, parse::{Parse, ParseStream},
            parse_macro_input, punctuated::Punctuated, spanned::Spanned, FnArg, ImplItem,
            Index, ItemImpl, Lit, LitStr, Pat, PatType, Result, ReturnType, Token, Type,
        };
        pub fn external(_attr: TokenStream, input: TokenStream) -> TokenStream {
            let mut input = match ::syn::parse_macro_input::parse::<ItemImpl>(input) {
                ::syn::__private::Ok(data) => data,
                ::syn::__private::Err(err) => {
                    return ::syn::__private::TokenStream::from(err.to_compile_error());
                }
            };
            let mut selectors = ::quote::__private::TokenStream::new();
            let mut match_selectors = ::quote::__private::TokenStream::new();
            let mut abi = ::quote::__private::TokenStream::new();
            let mut types = ::alloc::vec::Vec::new();
            for item in input.items.iter_mut() {
                let ImplItem::Method(method) = item else {
                    continue;
                };
                let mut purity = None;
                let mut override_id = None;
                let mut override_name = None;
                for attr in mem::take(&mut method.attrs) {
                    let Some(ident) = attr.path.get_ident() else {
                        continue;
                    };
                    if let Ok(elem) = Purity::from_str(&ident.to_string()) {
                        if !attr.tokens.is_empty() {
                            {
                                let error = syn::Error::new(
                                    syn::spanned::Spanned::span(&attr.tokens),
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("attribute does not take parameters"),
                                        );
                                        res
                                    },
                                );
                                return error.to_compile_error().into();
                            };
                        }
                        if purity.is_some() {
                            {
                                let error = syn::Error::new(
                                    syn::spanned::Spanned::span(&attr.path),
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("more than one purity attribute"),
                                        );
                                        res
                                    },
                                );
                                return error.to_compile_error().into();
                            };
                        }
                        purity = Some(elem);
                        continue;
                    }
                    if *ident == "selector" {
                        if override_id.is_some() || override_name.is_some() {
                            {
                                let error = syn::Error::new(
                                    syn::spanned::Spanned::span(&attr.path),
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("more than one selector attribute"),
                                        );
                                        res
                                    },
                                );
                                return error.to_compile_error().into();
                            };
                        }
                        let args = match syn::parse2::<
                            SelectorArgs,
                        >(attr.tokens.clone()) {
                            Ok(args) => args,
                            Err(error) => {
                                let error = syn::Error::new(
                                    syn::spanned::Spanned::span(&ident),
                                    {
                                        let res = ::alloc::fmt::format(format_args!("{0}", error));
                                        res
                                    },
                                );
                                return error.to_compile_error().into();
                            }
                        };
                        override_id = args.id;
                        override_name = args.name;
                        continue;
                    }
                    method.attrs.push(attr);
                }
                use Purity::*;
                let mut args = method.sig.inputs.iter().peekable();
                let mut has_self = false;
                let needed_purity = match args.peek() {
                    Some(FnArg::Receiver(recv)) => {
                        has_self = true;
                        recv.mutability.into()
                    }
                    Some(FnArg::Typed(PatType { ty, .. })) => {
                        match &**ty {
                            Type::Reference(ty) => ty.mutability.into(),
                            _ => Pure,
                        }
                    }
                    _ => Pure,
                };
                let purity = purity.unwrap_or(needed_purity);
                if purity == Pure && purity < needed_purity {
                    {
                        let error = syn::Error::new(
                            syn::spanned::Spanned::span(&args.next()),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("pure method must not access storage"),
                                );
                                res
                            },
                        );
                        return error.to_compile_error().into();
                    };
                }
                if purity == View && purity < needed_purity {
                    {
                        let error = syn::Error::new(
                            syn::spanned::Spanned::span(&args.next()),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "storage is &mut, but the method is {0}",
                                        purity,
                                    ),
                                );
                                res
                            },
                        );
                        return error.to_compile_error().into();
                    };
                }
                if needed_purity > Pure {
                    args.next();
                }
                /// finds the root type for a given arg
                fn pattern_ident(pat: Pat) -> Option<Ident> {
                    match pat {
                        Pat::Ident(ident) => Some(ident.ident),
                        Pat::Reference(pat) => pattern_ident(*pat.pat),
                        _ => None,
                    }
                }
                let args: Vec<_> = args
                    .map(|arg| match arg {
                        FnArg::Typed(t) => (pattern_ident(*t.pat.clone()), t.ty.clone()),
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    })
                    .collect();
                let name = &method.sig.ident;
                let sol_name = override_name
                    .unwrap_or(name.to_string().to_case(Case::Camel));
                let mut deny_value = ::quote::__private::TokenStream::new();
                if purity != Payable {
                    let name = name.to_string();
                    deny_value = {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "if");
                        ::quote::__private::push_ident(&mut _s, "let");
                        ::quote::__private::push_ident(&mut _s, "Err");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "err");
                                _s
                            },
                        );
                        ::quote::__private::push_eq(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "internal");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "deny_value");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::ToTokens::to_tokens(&name, &mut _s);
                                _s
                            },
                        );
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "return");
                                ::quote::__private::push_ident(&mut _s, "Some");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "Err");
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Parenthesis,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                ::quote::__private::push_ident(&mut _s, "err");
                                                _s
                                            },
                                        );
                                        _s
                                    },
                                );
                                ::quote::__private::push_semi(&mut _s);
                                _s
                            },
                        );
                        _s
                    };
                }
                let storage = if needed_purity == Pure {
                    ::quote::__private::TokenStream::new()
                } else if has_self {
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "core");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "borrow");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "BorrowMut");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "borrow_mut");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "storage");
                                _s
                            },
                        );
                        ::quote::__private::push_comma(&mut _s);
                        _s
                    }
                } else {
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "storage");
                        ::quote::__private::push_comma(&mut _s);
                        _s
                    }
                };
                let mut expand_args = ::alloc::vec::Vec::new();
                for (index, (_, ty)) in args.iter().enumerate() {
                    let index = Index {
                        index: index as u32,
                        span: ty.span(),
                    };
                    expand_args
                        .push({
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "args");
                            ::quote::__private::push_dot(&mut _s);
                            ::quote::ToTokens::to_tokens(&index, &mut _s);
                            _s
                        });
                }
                let constant = Ident::new(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("SELECTOR_{0}", name),
                        );
                        res
                    },
                    name.span(),
                );
                let arg_types: &Vec<_> = &args.iter().map(|a| &a.1).collect();
                let selector = match override_id {
                    Some(id) => {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::ToTokens::to_tokens(&id, &mut _s);
                        _s
                    }
                    None => {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "u32");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "from_be_bytes");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(
                                    &mut _s,
                                    "function_selector",
                                );
                                ::quote::__private::push_bang(&mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::ToTokens::to_tokens(&sol_name, &mut _s);
                                        {
                                            use ::quote::__private::ext::*;
                                            let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                                            #[allow(unused_mut)]
                                            let (mut arg_types, i) = arg_types.quote_into_iter();
                                            let has_iter = has_iter | i;
                                            let _: ::quote::__private::HasIterator = has_iter;
                                            while true {
                                                let arg_types = match arg_types.next() {
                                                    Some(_x) => ::quote::__private::RepInterp(_x),
                                                    None => break,
                                                };
                                                ::quote::__private::push_comma(&mut _s);
                                                ::quote::ToTokens::to_tokens(&arg_types, &mut _s);
                                            }
                                        }
                                        _s
                                    },
                                );
                                _s
                            },
                        );
                        _s
                    }
                };
                selectors
                    .extend({
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_pound(&mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Bracket,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "allow");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(
                                            &mut _s,
                                            "non_upper_case_globals",
                                        );
                                        _s
                                    },
                                );
                                _s
                            },
                        );
                        ::quote::__private::push_ident(&mut _s, "const");
                        ::quote::ToTokens::to_tokens(&constant, &mut _s);
                        ::quote::__private::push_colon(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "u32");
                        ::quote::__private::push_eq(&mut _s);
                        ::quote::ToTokens::to_tokens(&selector, &mut _s);
                        ::quote::__private::push_semi(&mut _s);
                        _s
                    });
                let in_span = method.sig.inputs.span();
                let decode_inputs = {
                    let mut _s = ::quote::__private::TokenStream::new();
                    let _span: ::quote::__private::Span = ::quote::__private::get_span(
                            in_span,
                        )
                        .__into_span();
                    ::quote::__private::push_lt_spanned(&mut _s, _span);
                    ::quote::__private::push_group_spanned(
                        &mut _s,
                        _span,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            let _span: ::quote::__private::Span = ::quote::__private::get_span(
                                    _span,
                                )
                                .__into_span();
                            {
                                use ::quote::__private::ext::*;
                                let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                                #[allow(unused_mut)]
                                let (mut arg_types, i) = arg_types.quote_into_iter();
                                let has_iter = has_iter | i;
                                let _: ::quote::__private::HasIterator = has_iter;
                                while true {
                                    let arg_types = match arg_types.next() {
                                        Some(_x) => ::quote::__private::RepInterp(_x),
                                        None => break,
                                    };
                                    ::quote::ToTokens::to_tokens(&arg_types, &mut _s);
                                    ::quote::__private::push_comma_spanned(&mut _s, _span);
                                }
                            }
                            _s
                        },
                    );
                    ::quote::__private::push_ident_spanned(&mut _s, _span, "as");
                    ::quote::__private::push_ident_spanned(&mut _s, _span, "AbiType");
                    ::quote::__private::push_gt_spanned(&mut _s, _span);
                    ::quote::__private::push_colon2_spanned(&mut _s, _span);
                    ::quote::__private::push_ident_spanned(&mut _s, _span, "SolType");
                    _s
                };
                let ret_span = match &method.sig.output {
                    x @ ReturnType::Default => x.span(),
                    ReturnType::Type(_, ty) => ty.span(),
                };
                let encode_result = {
                    let mut _s = ::quote::__private::TokenStream::new();
                    let _span: ::quote::__private::Span = ::quote::__private::get_span(
                            ret_span,
                        )
                        .__into_span();
                    ::quote::__private::push_ident_spanned(
                        &mut _s,
                        _span,
                        "EncodableReturnType",
                    );
                    ::quote::__private::push_colon2_spanned(&mut _s, _span);
                    ::quote::__private::push_ident_spanned(&mut _s, _span, "encode");
                    ::quote::__private::push_group_spanned(
                        &mut _s,
                        _span,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            let _span: ::quote::__private::Span = ::quote::__private::get_span(
                                    _span,
                                )
                                .__into_span();
                            ::quote::__private::push_ident_spanned(
                                &mut _s,
                                _span,
                                "result",
                            );
                            _s
                        },
                    );
                    _s
                };
                match_selectors
                    .extend({
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_pound(&mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Bracket,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "allow");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(
                                            &mut _s,
                                            "non_upper_case_globals",
                                        );
                                        _s
                                    },
                                );
                                _s
                            },
                        );
                        ::quote::ToTokens::to_tokens(&constant, &mut _s);
                        ::quote::__private::push_fat_arrow(&mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::ToTokens::to_tokens(&deny_value, &mut _s);
                                ::quote::__private::push_ident(&mut _s, "let");
                                ::quote::__private::push_ident(&mut _s, "args");
                                ::quote::__private::push_eq(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "match");
                                ::quote::__private::push_lt(&mut _s);
                                ::quote::ToTokens::to_tokens(&decode_inputs, &mut _s);
                                ::quote::__private::push_ident(&mut _s, "as");
                                ::quote::__private::push_ident(&mut _s, "SolType");
                                ::quote::__private::push_gt(&mut _s);
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(
                                    &mut _s,
                                    "abi_decode_params",
                                );
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "input");
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "true");
                                        _s
                                    },
                                );
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Brace,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "Ok");
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Parenthesis,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                ::quote::__private::push_ident(&mut _s, "args");
                                                _s
                                            },
                                        );
                                        ::quote::__private::push_fat_arrow(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "args");
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "Err");
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Parenthesis,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                ::quote::__private::push_ident(&mut _s, "err");
                                                _s
                                            },
                                        );
                                        ::quote::__private::push_fat_arrow(&mut _s);
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Brace,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                ::quote::__private::push_ident(&mut _s, "internal");
                                                ::quote::__private::push_colon2(&mut _s);
                                                ::quote::__private::push_ident(
                                                    &mut _s,
                                                    "failed_to_decode_arguments",
                                                );
                                                ::quote::__private::push_group(
                                                    &mut _s,
                                                    ::quote::__private::Delimiter::Parenthesis,
                                                    {
                                                        let mut _s = ::quote::__private::TokenStream::new();
                                                        ::quote::__private::push_ident(&mut _s, "err");
                                                        _s
                                                    },
                                                );
                                                ::quote::__private::push_semi(&mut _s);
                                                ::quote::__private::push_ident(&mut _s, "return");
                                                ::quote::__private::push_ident(&mut _s, "Some");
                                                ::quote::__private::push_group(
                                                    &mut _s,
                                                    ::quote::__private::Delimiter::Parenthesis,
                                                    {
                                                        let mut _s = ::quote::__private::TokenStream::new();
                                                        ::quote::__private::push_ident(&mut _s, "Err");
                                                        ::quote::__private::push_group(
                                                            &mut _s,
                                                            ::quote::__private::Delimiter::Parenthesis,
                                                            {
                                                                let mut _s = ::quote::__private::TokenStream::new();
                                                                ::quote::__private::push_ident(&mut _s, "vec");
                                                                ::quote::__private::push_bang(&mut _s);
                                                                ::quote::__private::push_group(
                                                                    &mut _s,
                                                                    ::quote::__private::Delimiter::Bracket,
                                                                    ::quote::__private::TokenStream::new(),
                                                                );
                                                                _s
                                                            },
                                                        );
                                                        _s
                                                    },
                                                );
                                                ::quote::__private::push_semi(&mut _s);
                                                _s
                                            },
                                        );
                                        _s
                                    },
                                );
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "let");
                                ::quote::__private::push_ident(&mut _s, "result");
                                ::quote::__private::push_eq(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "Self");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::ToTokens::to_tokens(&name, &mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::ToTokens::to_tokens(&storage, &mut _s);
                                        {
                                            use ::quote::__private::ext::*;
                                            let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                                            #[allow(unused_mut)]
                                            let (mut expand_args, i) = expand_args.quote_into_iter();
                                            let has_iter = has_iter | i;
                                            let _: ::quote::__private::HasIterator = has_iter;
                                            while true {
                                                let expand_args = match expand_args.next() {
                                                    Some(_x) => ::quote::__private::RepInterp(_x),
                                                    None => break,
                                                };
                                                ::quote::ToTokens::to_tokens(&expand_args, &mut _s);
                                                ::quote::__private::push_comma(&mut _s);
                                            }
                                        }
                                        _s
                                    },
                                );
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "Some");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::ToTokens::to_tokens(&encode_result, &mut _s);
                                        _s
                                    },
                                );
                                _s
                            },
                        );
                        _s
                    });
                if true {
                    continue;
                }
                let sol_args = args
                    .iter()
                    .enumerate()
                    .map(|(i, (ident, ty))| {
                        let comma = (i > 0).then_some(", ").unwrap_or_default();
                        let name = ident
                            .as_ref()
                            .map(ToString::to_string)
                            .unwrap_or_default();
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "write");
                            ::quote::__private::push_bang(&mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "f");
                                    ::quote::__private::push_comma(&mut _s);
                                    ::quote::__private::parse(&mut _s, "\"{}{}{}\"");
                                    ::quote::__private::push_comma(&mut _s);
                                    ::quote::ToTokens::to_tokens(&comma, &mut _s);
                                    ::quote::__private::push_comma(&mut _s);
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::ToTokens::to_tokens(&ty, &mut _s);
                                    ::quote::__private::push_ident(&mut _s, "as");
                                    ::quote::__private::push_ident(&mut _s, "AbiType");
                                    ::quote::__private::push_gt(&mut _s);
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "EXPORT_ABI_ARG");
                                    ::quote::__private::push_comma(&mut _s);
                                    ::quote::__private::push_ident(
                                        &mut _s,
                                        "underscore_if_sol",
                                    );
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::ToTokens::to_tokens(&name, &mut _s);
                                            _s
                                        },
                                    );
                                    _s
                                },
                            );
                            ::quote::__private::push_question(&mut _s);
                            ::quote::__private::push_semi(&mut _s);
                            _s
                        }
                    });
                let sol_outs = match &method.sig.output {
                    ReturnType::Default => ::quote::__private::TokenStream::new(),
                    ReturnType::Type(_, ty) => {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(
                            &mut _s,
                            "write_solidity_returns",
                        );
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                        ::quote::__private::push_gt(&mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "f");
                                _s
                            },
                        );
                        ::quote::__private::push_question(&mut _s);
                        ::quote::__private::push_semi(&mut _s);
                        _s
                    }
                };
                let sol_purity = match purity {
                    Write => "".to_string(),
                    x => {
                        let res = ::alloc::fmt::format(format_args!(" {0}", x));
                        res
                    }
                };
                let mut comment = ::quote::__private::TokenStream::new();
                if let Some(id) = override_id {
                    comment
                        .extend({
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "write");
                            ::quote::__private::push_bang(&mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "f");
                                    ::quote::__private::push_comma(&mut _s);
                                    ::quote::__private::parse(
                                        &mut _s,
                                        "\"\\n    // note: selector was overridden to be 0x{:x}.\"",
                                    );
                                    ::quote::__private::push_comma(&mut _s);
                                    ::quote::ToTokens::to_tokens(&id, &mut _s);
                                    _s
                                },
                            );
                            ::quote::__private::push_question(&mut _s);
                            ::quote::__private::push_semi(&mut _s);
                            _s
                        });
                }
                abi.extend({
                    let mut _s = ::quote::__private::TokenStream::new();
                    ::quote::ToTokens::to_tokens(&comment, &mut _s);
                    ::quote::__private::push_ident(&mut _s, "write");
                    ::quote::__private::push_bang(&mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "f");
                            ::quote::__private::push_comma(&mut _s);
                            ::quote::__private::parse(
                                &mut _s,
                                "\"\\n    function {}(\"",
                            );
                            ::quote::__private::push_comma(&mut _s);
                            ::quote::ToTokens::to_tokens(&sol_name, &mut _s);
                            _s
                        },
                    );
                    ::quote::__private::push_question(&mut _s);
                    ::quote::__private::push_semi(&mut _s);
                    {
                        use ::quote::__private::ext::*;
                        let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                        #[allow(unused_mut)]
                        let (mut sol_args, i) = sol_args.quote_into_iter();
                        let has_iter = has_iter | i;
                        let _: ::quote::__private::HasIterator = has_iter;
                        while true {
                            let sol_args = match sol_args.next() {
                                Some(_x) => ::quote::__private::RepInterp(_x),
                                None => break,
                            };
                            ::quote::ToTokens::to_tokens(&sol_args, &mut _s);
                        }
                    }
                    ::quote::__private::push_ident(&mut _s, "write");
                    ::quote::__private::push_bang(&mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "f");
                            ::quote::__private::push_comma(&mut _s);
                            ::quote::__private::parse(&mut _s, "\") external\"");
                            _s
                        },
                    );
                    ::quote::__private::push_question(&mut _s);
                    ::quote::__private::push_semi(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "write");
                    ::quote::__private::push_bang(&mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "f");
                            ::quote::__private::push_comma(&mut _s);
                            ::quote::ToTokens::to_tokens(&sol_purity, &mut _s);
                            _s
                        },
                    );
                    ::quote::__private::push_question(&mut _s);
                    ::quote::__private::push_semi(&mut _s);
                    ::quote::ToTokens::to_tokens(&sol_outs, &mut _s);
                    ::quote::__private::push_ident(&mut _s, "writeln");
                    ::quote::__private::push_bang(&mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "f");
                            ::quote::__private::push_comma(&mut _s);
                            ::quote::__private::parse(&mut _s, "\";\"");
                            _s
                        },
                    );
                    ::quote::__private::push_question(&mut _s);
                    ::quote::__private::push_semi(&mut _s);
                    _s
                });
            }
            let mut inherits = ::alloc::vec::Vec::new();
            for attr in mem::take(&mut input.attrs) {
                if !attr.path.is_ident("inherit") {
                    input.attrs.push(attr);
                    continue;
                }
                let contents: InheritsAttr = match attr.parse_args() {
                    Ok(contents) => contents,
                    Err(err) => {
                        return proc_macro::TokenStream::from(err.to_compile_error());
                    }
                };
                for ty in contents.types {
                    inherits.push(ty);
                }
            }
            let inherit_routes = inherits
                .iter()
                .map(|ty| {
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "if");
                        ::quote::__private::push_ident(&mut _s, "let");
                        ::quote::__private::push_ident(&mut _s, "Some");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "result");
                                _s
                            },
                        );
                        ::quote::__private::push_eq(&mut _s);
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                        ::quote::__private::push_ident(&mut _s, "as");
                        ::quote::__private::push_ident(&mut _s, "Router");
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "S");
                        ::quote::__private::push_shr(&mut _s);
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "route");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "storage");
                                ::quote::__private::push_comma(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "selector");
                                ::quote::__private::push_comma(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "input");
                                _s
                            },
                        );
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "return");
                                ::quote::__private::push_ident(&mut _s, "Some");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "result");
                                        _s
                                    },
                                );
                                ::quote::__private::push_semi(&mut _s);
                                _s
                            },
                        );
                        _s
                    }
                });
            let borrow_clauses = inherits
                .iter()
                .map(|ty| {
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "S");
                        ::quote::__private::push_colon(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "core");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "borrow");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "BorrowMut");
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                        ::quote::__private::push_gt(&mut _s);
                        _s
                    }
                });
            let self_ty = &input.self_ty;
            let generic_params = &input.generics.params;
            let where_clauses = input
                .generics
                .where_clause
                .clone()
                .map(|c| c.predicates)
                .unwrap_or_default();
            let mut router = {
                let mut _s = ::quote::__private::TokenStream::new();
                ::quote::ToTokens::to_tokens(&input, &mut _s);
                ::quote::__private::push_ident(&mut _s, "impl");
                ::quote::__private::push_lt(&mut _s);
                ::quote::__private::push_ident(&mut _s, "S");
                ::quote::__private::push_comma(&mut _s);
                ::quote::ToTokens::to_tokens(&generic_params, &mut _s);
                ::quote::__private::push_gt(&mut _s);
                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "abi");
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "Router");
                ::quote::__private::push_lt(&mut _s);
                ::quote::__private::push_ident(&mut _s, "S");
                ::quote::__private::push_gt(&mut _s);
                ::quote::__private::push_ident(&mut _s, "for");
                ::quote::ToTokens::to_tokens(&self_ty, &mut _s);
                ::quote::__private::push_ident(&mut _s, "where");
                ::quote::__private::push_ident(&mut _s, "S");
                ::quote::__private::push_colon(&mut _s);
                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "storage");
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "TopLevelStorage");
                ::quote::__private::push_add(&mut _s);
                ::quote::__private::push_ident(&mut _s, "core");
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "borrow");
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "BorrowMut");
                ::quote::__private::push_lt(&mut _s);
                ::quote::__private::push_ident(&mut _s, "Self");
                ::quote::__private::push_gt(&mut _s);
                ::quote::__private::push_comma(&mut _s);
                {
                    use ::quote::__private::ext::*;
                    let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                    #[allow(unused_mut)]
                    let (mut borrow_clauses, i) = borrow_clauses.quote_into_iter();
                    let has_iter = has_iter | i;
                    let _: ::quote::__private::HasIterator = has_iter;
                    while true {
                        let borrow_clauses = match borrow_clauses.next() {
                            Some(_x) => ::quote::__private::RepInterp(_x),
                            None => break,
                        };
                        ::quote::ToTokens::to_tokens(&borrow_clauses, &mut _s);
                        ::quote::__private::push_comma(&mut _s);
                    }
                }
                ::quote::ToTokens::to_tokens(&where_clauses, &mut _s);
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Brace,
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "type");
                        ::quote::__private::push_ident(&mut _s, "Storage");
                        ::quote::__private::push_eq(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "Self");
                        ::quote::__private::push_semi(&mut _s);
                        ::quote::__private::push_pound(&mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Bracket,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "inline");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "always");
                                        _s
                                    },
                                );
                                _s
                            },
                        );
                        ::quote::__private::push_ident(&mut _s, "fn");
                        ::quote::__private::push_ident(&mut _s, "route");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "storage");
                                ::quote::__private::push_colon(&mut _s);
                                ::quote::__private::push_and(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "mut");
                                ::quote::__private::push_ident(&mut _s, "S");
                                ::quote::__private::push_comma(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "selector");
                                ::quote::__private::push_colon(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "u32");
                                ::quote::__private::push_comma(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "input");
                                ::quote::__private::push_colon(&mut _s);
                                ::quote::__private::push_and(&mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Bracket,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "u8");
                                        _s
                                    },
                                );
                                _s
                            },
                        );
                        ::quote::__private::push_rarrow(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "Option");
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "ArbResult");
                        ::quote::__private::push_gt(&mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "use");
                                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Brace,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(
                                            &mut _s,
                                            "function_selector",
                                        );
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "alloy_sol_types");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "SolType");
                                        _s
                                    },
                                );
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "use");
                                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "abi");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Brace,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "internal");
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "internal");
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(
                                            &mut _s,
                                            "EncodableReturnType",
                                        );
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "AbiType");
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "Router");
                                        _s
                                    },
                                );
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "use");
                                ::quote::__private::push_ident(&mut _s, "alloc");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "vec");
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_pound(&mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Bracket,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "cfg");
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Parenthesis,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                ::quote::__private::push_ident(&mut _s, "feature");
                                                ::quote::__private::push_eq(&mut _s);
                                                ::quote::__private::parse(&mut _s, "\"export-abi\"");
                                                _s
                                            },
                                        );
                                        _s
                                    },
                                );
                                ::quote::__private::push_ident(&mut _s, "use");
                                ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "abi");
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "export");
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::ToTokens::to_tokens(&selectors, &mut _s);
                                ::quote::__private::push_ident(&mut _s, "match");
                                ::quote::__private::push_ident(&mut _s, "selector");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Brace,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::ToTokens::to_tokens(&match_selectors, &mut _s);
                                        ::quote::__private::push_underscore(&mut _s);
                                        ::quote::__private::push_fat_arrow(&mut _s);
                                        ::quote::__private::push_group(
                                            &mut _s,
                                            ::quote::__private::Delimiter::Brace,
                                            {
                                                let mut _s = ::quote::__private::TokenStream::new();
                                                {
                                                    use ::quote::__private::ext::*;
                                                    let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                                                    #[allow(unused_mut)]
                                                    let (mut inherit_routes, i) = inherit_routes
                                                        .quote_into_iter();
                                                    let has_iter = has_iter | i;
                                                    let _: ::quote::__private::HasIterator = has_iter;
                                                    while true {
                                                        let inherit_routes = match inherit_routes.next() {
                                                            Some(_x) => ::quote::__private::RepInterp(_x),
                                                            None => break,
                                                        };
                                                        ::quote::ToTokens::to_tokens(&inherit_routes, &mut _s);
                                                    }
                                                }
                                                ::quote::__private::push_ident(&mut _s, "None");
                                                _s
                                            },
                                        );
                                        _s
                                    },
                                );
                                _s
                            },
                        );
                        _s
                    },
                );
                _s
            };
            if true {
                return router.into();
            }
            for item in input.items.iter_mut() {
                let ImplItem::Method(method) = item else {
                    continue;
                };
                if let ReturnType::Type(_, ty) = &method.sig.output {
                    types.push(ty);
                }
            }
            let type_decls = {
                let mut _s = ::quote::__private::TokenStream::new();
                ::quote::__private::push_ident(&mut _s, "let");
                ::quote::__private::push_ident(&mut _s, "mut");
                ::quote::__private::push_ident(&mut _s, "seen");
                ::quote::__private::push_eq(&mut _s);
                ::quote::__private::push_ident(&mut _s, "HashSet");
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "new");
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Parenthesis,
                    ::quote::__private::TokenStream::new(),
                );
                ::quote::__private::push_semi(&mut _s);
                ::quote::__private::push_ident(&mut _s, "for");
                ::quote::__private::push_ident(&mut _s, "item");
                ::quote::__private::push_ident(&mut _s, "in");
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Bracket,
                    ::quote::__private::TokenStream::new(),
                );
                ::quote::__private::push_dot(&mut _s);
                ::quote::__private::push_ident(&mut _s, "iter");
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Parenthesis,
                    ::quote::__private::TokenStream::new(),
                );
                {
                    use ::quote::__private::ext::*;
                    let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                    #[allow(unused_mut)]
                    let (mut types, i) = types.quote_into_iter();
                    let has_iter = has_iter | i;
                    let _: ::quote::__private::HasIterator = has_iter;
                    while true {
                        let types = match types.next() {
                            Some(_x) => ::quote::__private::RepInterp(_x),
                            None => break,
                        };
                        ::quote::__private::push_dot(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "chain");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_and(&mut _s);
                                ::quote::__private::push_lt(&mut _s);
                                ::quote::ToTokens::to_tokens(&types, &mut _s);
                                ::quote::__private::push_ident(&mut _s, "as");
                                ::quote::__private::push_ident(&mut _s, "InnerTypes");
                                ::quote::__private::push_gt(&mut _s);
                                ::quote::__private::push_colon2(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "inner_types");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    ::quote::__private::TokenStream::new(),
                                );
                                _s
                            },
                        );
                    }
                }
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Brace,
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "if");
                        ::quote::__private::push_ident(&mut _s, "seen");
                        ::quote::__private::push_dot(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "insert");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "item");
                                ::quote::__private::push_dot(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "id");
                                _s
                            },
                        );
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "writeln");
                                ::quote::__private::push_bang(&mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "f");
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::parse(&mut _s, "\"\\n    {}\"");
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "item");
                                        ::quote::__private::push_dot(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "name");
                                        _s
                                    },
                                );
                                ::quote::__private::push_question(&mut _s);
                                ::quote::__private::push_semi(&mut _s);
                                _s
                            },
                        );
                        _s
                    },
                );
                _s
            };
            let name = match *self_ty.clone() {
                Type::Path(path) => {
                    path.path.segments.last().unwrap().ident.clone().to_string()
                }
                _ => {
                    let error = syn::Error::new(
                        syn::spanned::Spanned::span(&self_ty),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Can\'t generate ABI for unnamed type"),
                            );
                            res
                        },
                    );
                    return error.to_compile_error().into();
                }
            };
            let inherited_abis = inherits
                .iter()
                .map(|ty| {
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                        ::quote::__private::push_ident(&mut _s, "as");
                        ::quote::__private::push_ident(&mut _s, "GenerateAbi");
                        ::quote::__private::push_gt(&mut _s);
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "fmt_abi");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "f");
                                _s
                            },
                        );
                        ::quote::__private::push_question(&mut _s);
                        ::quote::__private::push_semi(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "writeln");
                        ::quote::__private::push_bang(&mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "f");
                                _s
                            },
                        );
                        ::quote::__private::push_question(&mut _s);
                        ::quote::__private::push_semi(&mut _s);
                        _s
                    }
                });
            let mut is_clause = match inherits.is_empty() {
                true => ::quote::__private::TokenStream::new(),
                false => {
                    let mut _s = ::quote::__private::TokenStream::new();
                    ::quote::__private::push_ident(&mut _s, "write");
                    ::quote::__private::push_bang(&mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "f");
                            ::quote::__private::push_comma(&mut _s);
                            ::quote::__private::parse(&mut _s, "\" is \"");
                            _s
                        },
                    );
                    ::quote::__private::push_question(&mut _s);
                    ::quote::__private::push_semi(&mut _s);
                    _s
                }
            };
            is_clause
                .extend(
                    inherits
                        .iter()
                        .enumerate()
                        .map(|(i, ty)| {
                            let comma = (i > 0).then_some(", ").unwrap_or_default();
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "write");
                                ::quote::__private::push_bang(&mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_ident(&mut _s, "f");
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::parse(&mut _s, "\"{}I{}\"");
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::ToTokens::to_tokens(&comma, &mut _s);
                                        ::quote::__private::push_comma(&mut _s);
                                        ::quote::__private::push_lt(&mut _s);
                                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                                        ::quote::__private::push_ident(&mut _s, "as");
                                        ::quote::__private::push_ident(&mut _s, "GenerateAbi");
                                        ::quote::__private::push_gt(&mut _s);
                                        ::quote::__private::push_colon2(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "NAME");
                                        _s
                                    },
                                );
                                ::quote::__private::push_question(&mut _s);
                                ::quote::__private::push_semi(&mut _s);
                                _s
                            }
                        }),
                );
            router
                .extend({
                    let mut _s = ::quote::__private::TokenStream::new();
                    ::quote::__private::push_ident(&mut _s, "impl");
                    ::quote::__private::push_lt(&mut _s);
                    ::quote::ToTokens::to_tokens(&generic_params, &mut _s);
                    ::quote::__private::push_gt(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "abi");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "GenerateAbi");
                    ::quote::__private::push_ident(&mut _s, "for");
                    ::quote::ToTokens::to_tokens(&self_ty, &mut _s);
                    ::quote::__private::push_ident(&mut _s, "where");
                    ::quote::ToTokens::to_tokens(&where_clauses, &mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "const");
                            ::quote::__private::push_ident(&mut _s, "NAME");
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::__private::push_and(&mut _s);
                            ::quote::__private::push_lifetime(&mut _s, "\'static");
                            ::quote::__private::push_ident(&mut _s, "str");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::ToTokens::to_tokens(&name, &mut _s);
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "fn");
                            ::quote::__private::push_ident(&mut _s, "fmt_abi");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "f");
                                    ::quote::__private::push_colon(&mut _s);
                                    ::quote::__private::push_and(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "mut");
                                    ::quote::__private::push_ident(&mut _s, "core");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "fmt");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "Formatter");
                                    ::quote::__private::push_lt(&mut _s);
                                    ::quote::__private::push_lifetime(&mut _s, "\'_");
                                    ::quote::__private::push_gt(&mut _s);
                                    _s
                                },
                            );
                            ::quote::__private::push_rarrow(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "core");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "fmt");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "Result");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "use");
                                    ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "abi");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Brace,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "AbiType");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "GenerateAbi");
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_semi(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "use");
                                    ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "abi");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "internal");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(
                                        &mut _s,
                                        "write_solidity_returns",
                                    );
                                    ::quote::__private::push_semi(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "use");
                                    ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "abi");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "export");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Brace,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(
                                                &mut _s,
                                                "underscore_if_sol",
                                            );
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "internal");
                                            ::quote::__private::push_colon2(&mut _s);
                                            ::quote::__private::push_ident(&mut _s, "InnerTypes");
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_semi(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "use");
                                    ::quote::__private::push_ident(&mut _s, "std");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "collections");
                                    ::quote::__private::push_colon2(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "HashSet");
                                    ::quote::__private::push_semi(&mut _s);
                                    {
                                        use ::quote::__private::ext::*;
                                        let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                                        #[allow(unused_mut)]
                                        let (mut inherited_abis, i) = inherited_abis
                                            .quote_into_iter();
                                        let has_iter = has_iter | i;
                                        let _: ::quote::__private::HasIterator = has_iter;
                                        while true {
                                            let inherited_abis = match inherited_abis.next() {
                                                Some(_x) => ::quote::__private::RepInterp(_x),
                                                None => break,
                                            };
                                            ::quote::ToTokens::to_tokens(&inherited_abis, &mut _s);
                                        }
                                    }
                                    ::quote::__private::push_ident(&mut _s, "write");
                                    ::quote::__private::push_bang(&mut _s);
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "f");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::parse(&mut _s, "\"interface I{}\"");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::ToTokens::to_tokens(&name, &mut _s);
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_question(&mut _s);
                                    ::quote::__private::push_semi(&mut _s);
                                    ::quote::ToTokens::to_tokens(&is_clause, &mut _s);
                                    ::quote::__private::push_ident(&mut _s, "write");
                                    ::quote::__private::push_bang(&mut _s);
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "f");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::parse(&mut _s, "\" {{\"");
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_question(&mut _s);
                                    ::quote::__private::push_semi(&mut _s);
                                    ::quote::ToTokens::to_tokens(&abi, &mut _s);
                                    ::quote::ToTokens::to_tokens(&type_decls, &mut _s);
                                    ::quote::__private::push_ident(&mut _s, "writeln");
                                    ::quote::__private::push_bang(&mut _s);
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_ident(&mut _s, "f");
                                            ::quote::__private::push_comma(&mut _s);
                                            ::quote::__private::parse(&mut _s, "\"}}\"");
                                            _s
                                        },
                                    );
                                    ::quote::__private::push_question(&mut _s);
                                    ::quote::__private::push_semi(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "Ok");
                                    ::quote::__private::push_group(
                                        &mut _s,
                                        ::quote::__private::Delimiter::Parenthesis,
                                        {
                                            let mut _s = ::quote::__private::TokenStream::new();
                                            ::quote::__private::push_group(
                                                &mut _s,
                                                ::quote::__private::Delimiter::Parenthesis,
                                                ::quote::__private::TokenStream::new(),
                                            );
                                            _s
                                        },
                                    );
                                    _s
                                },
                            );
                            _s
                        },
                    );
                    _s
                });
            router.into()
        }
        struct InheritsAttr {
            types: Punctuated<Type, ::syn::token::Comma>,
        }
        impl Parse for InheritsAttr {
            fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
                let types = Punctuated::parse_separated_nonempty(input)?;
                Ok(Self { types })
            }
        }
        struct SelectorArgs {
            id: Option<u32>,
            name: Option<String>,
        }
        impl Parse for SelectorArgs {
            fn parse(input: ParseStream) -> Result<Self> {
                let mut id = None;
                let mut name = None;
                let content;
                let _ = match ::syn::__private::parse_parens(&input) {
                    ::syn::__private::Ok(parens) => {
                        content = parens.content;
                        parens.token
                    }
                    ::syn::__private::Err(error) => {
                        return ::syn::__private::Err(error);
                    }
                };
                let input = content;
                if input.is_empty() {
                    {
                        return Err(
                            syn::Error::new(
                                syn::spanned::Spanned::span(&input.span()),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!("missing id or text argument"),
                                    );
                                    res
                                },
                            ),
                        )
                    };
                }
                while !input.is_empty() {
                    let ident: Ident = input.parse()?;
                    let _: ::syn::token::Eq = input.parse()?;
                    match ident.to_string().as_str() {
                        "id" => {
                            let lit: Lit = input.parse()?;
                            if id.is_some() {
                                {
                                    return Err(
                                        syn::Error::new(
                                            syn::spanned::Spanned::span(&lit),
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!("only one \"id\" is allowed"),
                                                );
                                                res
                                            },
                                        ),
                                    )
                                };
                            }
                            id = Some(
                                match lit {
                                    Lit::Int(lit) => lit.base10_parse()?,
                                    Lit::Str(lit) => {
                                        let name = lit.value();
                                        if !name.contains('(') {
                                            {
                                                return Err(
                                                    syn::Error::new(
                                                        syn::spanned::Spanned::span(&lit),
                                                        {
                                                            let res = ::alloc::fmt::format(
                                                                format_args!(
                                                                    "missing parens. Perhaps you meant name = \"{0}\"?",
                                                                    name,
                                                                ),
                                                            );
                                                            res
                                                        },
                                                    ),
                                                )
                                            };
                                        }
                                        let hash = types::keccak(name.as_bytes());
                                        u32::from_be_bytes(hash[..4].try_into().unwrap())
                                    }
                                    _ => {
                                        return Err(
                                            syn::Error::new(
                                                syn::spanned::Spanned::span(&lit),
                                                {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("expected u32 or string"),
                                                    );
                                                    res
                                                },
                                            ),
                                        );
                                    }
                                },
                            );
                        }
                        "name" => {
                            let lit: LitStr = input.parse()?;
                            if name.is_some() {
                                {
                                    return Err(
                                        syn::Error::new(
                                            syn::spanned::Spanned::span(&lit),
                                            {
                                                let res = ::alloc::fmt::format(
                                                    format_args!("only one \"name\" is allowed"),
                                                );
                                                res
                                            },
                                        ),
                                    )
                                };
                            }
                            name = Some(lit.value());
                        }
                        _ => {
                            return Err(
                                syn::Error::new(
                                    syn::spanned::Spanned::span(&ident),
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("Unknown selector attribute"),
                                        );
                                        res
                                    },
                                ),
                            );
                        }
                    }
                    let _: Result<::syn::token::Comma> = input.parse();
                }
                if id.is_some() == name.is_some() {
                    {
                        return Err(
                            syn::Error::new(
                                syn::spanned::Spanned::span(&input.span()),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!("only one of \"id\" or \"name\" expected"),
                                    );
                                    res
                                },
                            ),
                        )
                    };
                }
                Ok(Self { id, name })
            }
        }
    }
}
mod storage {
    use crate::storage::proc::{
        SolidityField, SolidityFields, SolidityStruct, SolidityStructs,
    };
    use proc_macro::TokenStream;
    use quote::{quote, ToTokens};
    use std::mem;
    use syn::{parse_macro_input, punctuated::Punctuated, Index, ItemStruct, Token, Type};
    mod proc {
        use lazy_static::lazy_static;
        use proc_macro2::{Ident, Literal};
        use quote::quote;
        use regex::Regex;
        use syn::{
            braced, bracketed, parenthesized, parse::{Parse, ParseStream},
            punctuated::Punctuated, token::Bracket, Attribute, Error, Generics, Path,
            Result, Token, Visibility,
        };
        pub struct SolidityStructs(pub Vec<SolidityStruct>);
        impl Parse for SolidityStructs {
            fn parse(input: ParseStream) -> Result<Self> {
                let mut structs = Vec::new();
                while !input.is_empty() {
                    structs.push(input.parse()?);
                }
                Ok(Self(structs))
            }
        }
        pub struct SolidityStruct {
            pub attrs: Vec<Attribute>,
            pub vis: Visibility,
            pub name: Ident,
            pub generics: Generics,
            pub fields: SolidityFields,
        }
        impl Parse for SolidityStruct {
            fn parse(input: ParseStream) -> Result<Self> {
                let attrs: Vec<Attribute> = Attribute::parse_outer(input)?;
                let vis: Visibility = input.parse()?;
                let _: ::syn::token::Struct = input.parse()?;
                let name: Ident = input.parse()?;
                let generics: Generics = input.parse()?;
                let content;
                let _ = match ::syn::__private::parse_braces(&input) {
                    ::syn::__private::Ok(braces) => {
                        content = braces.content;
                        braces.token
                    }
                    ::syn::__private::Err(error) => {
                        return ::syn::__private::Err(error);
                    }
                };
                let fields = content.parse()?;
                Ok(Self {
                    attrs,
                    vis,
                    name,
                    generics,
                    fields,
                })
            }
        }
        pub struct SolidityFields(pub Punctuated<SolidityField, ::syn::token::Semi>);
        impl Parse for SolidityFields {
            fn parse(input: ParseStream) -> Result<Self> {
                let fields = Punctuated::parse_terminated(input)?;
                Ok(Self(fields))
            }
        }
        pub struct SolidityField {
            pub attrs: Vec<Attribute>,
            pub name: Ident,
            pub ty: Path,
        }
        impl Parse for SolidityField {
            fn parse(input: ParseStream) -> Result<Self> {
                let attrs: Vec<Attribute> = Attribute::parse_outer(input)?;
                let ty = SolidityTy::parse(input)?.0;
                let name: Ident = input.parse()?;
                Ok(SolidityField { attrs, name, ty })
            }
        }
        pub struct SolidityTy(Path);
        impl Parse for SolidityTy {
            fn parse(input: ParseStream) -> Result<Self> {
                let start: Path = input.parse()?;
                let mut path: Path;
                if start.is_ident("mapping") {
                    let content;
                    let _ = match ::syn::__private::parse_parens(&input) {
                        ::syn::__private::Ok(parens) => {
                            content = parens.content;
                            parens.token
                        }
                        ::syn::__private::Err(error) => {
                            return ::syn::__private::Err(error);
                        }
                    };
                    let key = content.parse::<PrimitiveKey>()?.0;
                    let _: ::syn::token::FatArrow = content.parse()?;
                    let value = content.parse::<SolidityTy>()?.0;
                    let ty = {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "{0}<{1}, {2}>",
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "stylus_sdk::storage::{0}",
                                            {
                                                let res = ::alloc::fmt::format(format_args!("StorageMap"));
                                                res
                                            },
                                        ),
                                    );
                                    res
                                },
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::ToTokens::to_tokens(&key, &mut _s);
                                    _s
                                },
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::ToTokens::to_tokens(&value, &mut _s);
                                    _s
                                },
                            ),
                        );
                        res
                    };
                    path = syn::parse_str(&ty)?;
                } else {
                    let base: Primitive = start.try_into()?;
                    path = base.0;
                };
                while input.peek(Bracket) {
                    let content;
                    let _ = match ::syn::__private::parse_brackets(&input) {
                        ::syn::__private::Ok(brackets) => {
                            content = brackets.content;
                            brackets.token
                        }
                        ::syn::__private::Err(error) => {
                            return ::syn::__private::Err(error);
                        }
                    };
                    if content.is_empty() {
                        let outer = {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "stylus_sdk::storage::{0}",
                                    {
                                        let res = ::alloc::fmt::format(format_args!("StorageVec"));
                                        res
                                    },
                                ),
                            );
                            res
                        };
                        let inner = {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::ToTokens::to_tokens(&path, &mut _s);
                            _s
                        };
                        path = syn::parse_str(
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!("{0}<{1}>", outer, inner),
                                );
                                res
                            },
                        )?;
                    } else {
                        let content: Literal = content.parse()?;
                        let Ok(size) = content.to_string().parse::<usize>() else {
                            {
                                return Err(
                                    syn::Error::new(
                                        syn::spanned::Spanned::span(&content),
                                        {
                                            let res = ::alloc::fmt::format(
                                                format_args!("Array size must be a positive integer"),
                                            );
                                            res
                                        },
                                    ),
                                )
                            };
                        };
                        let outer = {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "stylus_sdk::storage::{0}",
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("StorageArray"),
                                        );
                                        res
                                    },
                                ),
                            );
                            res
                        };
                        let inner = {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::ToTokens::to_tokens(&path, &mut _s);
                            _s
                        };
                        path = syn::parse_str(
                            &{
                                let res = ::alloc::fmt::format(
                                    format_args!("{0}<{1}, {2}>", outer, inner, size),
                                );
                                res
                            },
                        )?;
                    }
                }
                Ok(SolidityTy(path))
            }
        }
        pub struct Primitive(Path);
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct UINT_REGEX {
            __private_field: (),
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        static UINT_REGEX: UINT_REGEX = UINT_REGEX { __private_field: () };
        impl ::lazy_static::__Deref for UINT_REGEX {
            type Target = Regex;
            fn deref(&self) -> &Regex {
                #[inline(always)]
                fn __static_ref_initialize() -> Regex {
                    Regex::new(r"^uint(\d+)$").unwrap()
                }
                #[inline(always)]
                fn __stability() -> &'static Regex {
                    static LAZY: ::lazy_static::lazy::Lazy<Regex> = ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for UINT_REGEX {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct INT_REGEX {
            __private_field: (),
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        static INT_REGEX: INT_REGEX = INT_REGEX { __private_field: () };
        impl ::lazy_static::__Deref for INT_REGEX {
            type Target = Regex;
            fn deref(&self) -> &Regex {
                #[inline(always)]
                fn __static_ref_initialize() -> Regex {
                    Regex::new(r"^int(\d+)$").unwrap()
                }
                #[inline(always)]
                fn __stability() -> &'static Regex {
                    static LAZY: ::lazy_static::lazy::Lazy<Regex> = ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for INT_REGEX {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct BYTES_REGEX {
            __private_field: (),
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        static BYTES_REGEX: BYTES_REGEX = BYTES_REGEX { __private_field: () };
        impl ::lazy_static::__Deref for BYTES_REGEX {
            type Target = Regex;
            fn deref(&self) -> &Regex {
                #[inline(always)]
                fn __static_ref_initialize() -> Regex {
                    Regex::new(r"^bytes(\d+)$").unwrap()
                }
                #[inline(always)]
                fn __stability() -> &'static Regex {
                    static LAZY: ::lazy_static::lazy::Lazy<Regex> = ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for BYTES_REGEX {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct LOWER_REGEX {
            __private_field: (),
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        static LOWER_REGEX: LOWER_REGEX = LOWER_REGEX { __private_field: () };
        impl ::lazy_static::__Deref for LOWER_REGEX {
            type Target = Regex;
            fn deref(&self) -> &Regex {
                #[inline(always)]
                fn __static_ref_initialize() -> Regex {
                    Regex::new(r"^[0-9a-z]+$").unwrap()
                }
                #[inline(always)]
                fn __stability() -> &'static Regex {
                    static LAZY: ::lazy_static::lazy::Lazy<Regex> = ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for LOWER_REGEX {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        impl Parse for Primitive {
            fn parse(input: ParseStream) -> Result<Self> {
                let path: Path = input.parse()?;
                path.try_into()
            }
        }
        impl TryFrom<Path> for Primitive {
            type Error = Error;
            fn try_from(path: Path) -> std::result::Result<Self, Self::Error> {
                let Some(ident) = path.get_ident() else {
                    return Ok(Self(path));
                };
                let name = &ident.to_string();
                if let Some(caps) = UINT_REGEX.captures(name) {
                    let bits: usize = caps[1].parse().unwrap();
                    let limbs = (63 + bits) / 64;
                    if bits > 256 {
                        return Err(
                            Error::new_spanned(
                                &ident,
                                "Type not supported: too many bits",
                            ),
                        );
                    }
                    return {
                        let path = {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "stylus_sdk::storage::{0}",
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("StorageUint<{0}, {1}>", bits, limbs),
                                        );
                                        res
                                    },
                                ),
                            );
                            res
                        };
                        Ok(Self(syn::parse_str(&path)?))
                    };
                }
                if let Some(caps) = INT_REGEX.captures(name) {
                    let bits: usize = caps[1].parse().unwrap();
                    let limbs = (63 + bits) / 64;
                    if bits > 256 {
                        return Err(
                            Error::new_spanned(
                                &ident,
                                "Type not supported: too many bits",
                            ),
                        );
                    }
                    return {
                        let path = {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "stylus_sdk::storage::{0}",
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("StorageSigned<{0}, {1}>", bits, limbs),
                                        );
                                        res
                                    },
                                ),
                            );
                            res
                        };
                        Ok(Self(syn::parse_str(&path)?))
                    };
                }
                if let Some(caps) = BYTES_REGEX.captures(name) {
                    let bytes: usize = caps[1].parse().unwrap();
                    if bytes > 32 {
                        return Err(
                            Error::new_spanned(
                                &ident,
                                "Type not supported: too many bytes",
                            ),
                        );
                    }
                    return {
                        let path = {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "stylus_sdk::storage::{0}",
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!("StorageFixedBytes<{0}>", bytes),
                                        );
                                        res
                                    },
                                ),
                            );
                            res
                        };
                        Ok(Self(syn::parse_str(&path)?))
                    };
                }
                let ty = match name.as_str() {
                    "address" => "StorageAddress",
                    "bool" => "StorageBool",
                    "bytes" => "StorageBytes",
                    "int" => "StorageI256",
                    "string" => "StorageString",
                    "uint" => "StorageU256",
                    x => {
                        match LOWER_REGEX.is_match(x) {
                            true => {
                                return Err(Error::new_spanned(ident, "Type not supported"));
                            }
                            false => return Ok(Self(syn::parse_str(x)?)),
                        }
                    }
                };
                {
                    let path = {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "stylus_sdk::storage::{0}",
                                {
                                    let res = ::alloc::fmt::format(format_args!("{0}", ty));
                                    res
                                },
                            ),
                        );
                        res
                    };
                    Ok(Self(syn::parse_str(&path)?))
                }
            }
        }
        pub struct PrimitiveKey(Path);
        impl Parse for PrimitiveKey {
            fn parse(input: ParseStream) -> Result<Self> {
                let path: Path = input.parse()?;
                path.try_into()
            }
        }
        impl TryFrom<Path> for PrimitiveKey {
            type Error = Error;
            fn try_from(path: Path) -> std::result::Result<Self, Self::Error> {
                let Some(ident) = path.get_ident() else {
                    return Ok(Self(path));
                };
                let name = &ident.to_string();
                if let Some(caps) = UINT_REGEX.captures(name) {
                    let bits: usize = caps[1].parse().unwrap();
                    let limbs = (63 + bits) / 64;
                    if bits > 256 {
                        return Err(
                            Error::new_spanned(
                                &ident,
                                "Type not supported: too many bits",
                            ),
                        );
                    }
                    return {
                        let path = {
                            let res = ::alloc::fmt::format(
                                format_args!("Uint<{0}, {1}>", bits, limbs),
                            );
                            res
                        };
                        let path = {
                            let res = ::alloc::fmt::format(
                                format_args!("stylus_sdk::alloy_primitives::{0}", path),
                            );
                            res
                        };
                        Ok(Self(syn::parse_str(&path)?))
                    };
                }
                if let Some(caps) = INT_REGEX.captures(name) {
                    let bits: usize = caps[1].parse().unwrap();
                    let limbs = (63 + bits) / 64;
                    if bits > 256 {
                        return Err(
                            Error::new_spanned(
                                &ident,
                                "Type not supported: too many bits",
                            ),
                        );
                    }
                    return {
                        let path = {
                            let res = ::alloc::fmt::format(
                                format_args!("Signed<{0}, {1}>", bits, limbs),
                            );
                            res
                        };
                        let path = {
                            let res = ::alloc::fmt::format(
                                format_args!("stylus_sdk::alloy_primitives::{0}", path),
                            );
                            res
                        };
                        Ok(Self(syn::parse_str(&path)?))
                    };
                }
                if let Some(caps) = BYTES_REGEX.captures(name) {
                    let bytes: usize = caps[1].parse().unwrap();
                    if bytes > 32 {
                        return Err(
                            Error::new_spanned(
                                &ident,
                                "Type not supported: too many bytes",
                            ),
                        );
                    }
                    return {
                        let path = {
                            let res = ::alloc::fmt::format(
                                format_args!("FixedBytes<{0}>", bytes),
                            );
                            res
                        };
                        let path = {
                            let res = ::alloc::fmt::format(
                                format_args!("stylus_sdk::alloy_primitives::{0}", path),
                            );
                            res
                        };
                        Ok(Self(syn::parse_str(&path)?))
                    };
                }
                let ty = match name.as_str() {
                    "address" => "Address",
                    "bool" => "U8",
                    "int" => "I256",
                    "uint" => "U256",
                    "bytes" => return Ok(Self(syn::parse_str("Vec<u8>")?)),
                    "string" => return Ok(Self(syn::parse_str("String")?)),
                    x => {
                        match LOWER_REGEX.is_match(x) {
                            true => {
                                return Err(Error::new_spanned(ident, "Type not supported"));
                            }
                            false => return Ok(Self(syn::parse_str(x)?)),
                        }
                    }
                };
                {
                    let path = {
                        let res = ::alloc::fmt::format(format_args!("{0}", ty));
                        res
                    };
                    let path = {
                        let res = ::alloc::fmt::format(
                            format_args!("stylus_sdk::alloy_primitives::{0}", path),
                        );
                        res
                    };
                    Ok(Self(syn::parse_str(&path)?))
                }
            }
        }
    }
    pub fn solidity_storage(_attr: TokenStream, input: TokenStream) -> TokenStream {
        let mut input = match ::syn::parse_macro_input::parse::<ItemStruct>(input) {
            ::syn::__private::Ok(data) => data,
            ::syn::__private::Err(err) => {
                return ::syn::__private::TokenStream::from(err.to_compile_error());
            }
        };
        let name = &input.ident;
        let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();
        let mut init = ::quote::__private::TokenStream::new();
        let mut size = ::quote::__private::TokenStream::new();
        let mut borrows = ::quote::__private::TokenStream::new();
        for (field_index, field) in input.fields.iter_mut().enumerate() {
            let Type::Path(ty) = &field.ty else {
                {
                    let error = syn::Error::new(
                        syn::spanned::Spanned::span(&&field),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Type not supported for EVM state storage"),
                            );
                            res
                        },
                    );
                    return error.to_compile_error().into();
                };
            };
            let attrs = mem::take(&mut field.attrs);
            for attr in attrs {
                if !attr.path.is_ident("borrow") {
                    field.attrs.push(attr);
                    continue;
                }
                if !attr.tokens.is_empty() {
                    {
                        let error = syn::Error::new(
                            syn::spanned::Spanned::span(&attr.tokens),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("borrow attribute does not take parameters"),
                                );
                                res
                            },
                        );
                        return error.to_compile_error().into();
                    };
                }
                let ty = &field.ty;
                let accessor = match field.ident.as_ref() {
                    Some(accessor) => accessor.into_token_stream(),
                    None => Index::from(field_index).into_token_stream(),
                };
                borrows
                    .extend({
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "impl");
                        ::quote::__private::push_ident(&mut _s, "core");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "borrow");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "Borrow");
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                        ::quote::__private::push_gt(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "for");
                        ::quote::ToTokens::to_tokens(&name, &mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "fn");
                                ::quote::__private::push_ident(&mut _s, "borrow");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_and(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "self");
                                        _s
                                    },
                                );
                                ::quote::__private::push_rarrow(&mut _s);
                                ::quote::__private::push_and(&mut _s);
                                ::quote::ToTokens::to_tokens(&ty, &mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Brace,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_and(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "self");
                                        ::quote::__private::push_dot(&mut _s);
                                        ::quote::ToTokens::to_tokens(&accessor, &mut _s);
                                        _s
                                    },
                                );
                                _s
                            },
                        );
                        ::quote::__private::push_ident(&mut _s, "impl");
                        ::quote::__private::push_ident(&mut _s, "core");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "borrow");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "BorrowMut");
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                        ::quote::__private::push_gt(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "for");
                        ::quote::ToTokens::to_tokens(&name, &mut _s);
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "fn");
                                ::quote::__private::push_ident(&mut _s, "borrow_mut");
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Parenthesis,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_and(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "mut");
                                        ::quote::__private::push_ident(&mut _s, "self");
                                        _s
                                    },
                                );
                                ::quote::__private::push_rarrow(&mut _s);
                                ::quote::__private::push_and(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "mut");
                                ::quote::ToTokens::to_tokens(&ty, &mut _s);
                                ::quote::__private::push_group(
                                    &mut _s,
                                    ::quote::__private::Delimiter::Brace,
                                    {
                                        let mut _s = ::quote::__private::TokenStream::new();
                                        ::quote::__private::push_and(&mut _s);
                                        ::quote::__private::push_ident(&mut _s, "mut");
                                        ::quote::__private::push_ident(&mut _s, "self");
                                        ::quote::__private::push_dot(&mut _s);
                                        ::quote::ToTokens::to_tokens(&accessor, &mut _s);
                                        _s
                                    },
                                );
                                _s
                            },
                        );
                        _s
                    });
            }
            let path = &ty.path.segments.last().unwrap().ident;
            let not_supported = {
                let res = ::alloc::fmt::format(
                    format_args!("Type `{0}` not supported for EVM state storage", path),
                );
                res
            };
            match path.to_string().as_str() {
                x @ ("u8" | "u16" | "u32" | "u64" | "u128" | "i8" | "i16" | "i32" | "i64"
                | "i128" | "U8" | "U16" | "U32" | "U64" | "U128" | "I8" | "I16" | "I32"
                | "I64" | "I128") => {
                    {
                        let error = syn::Error::new(
                            syn::spanned::Spanned::span(&&field),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{1}. Instead try `Storage{0}`.",
                                        x.to_uppercase(),
                                        not_supported,
                                    ),
                                );
                                res
                            },
                        );
                        return error.to_compile_error().into();
                    };
                }
                "usize" => {
                    let error = syn::Error::new(
                        syn::spanned::Spanned::span(&&field),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("{0}.", not_supported),
                            );
                            res
                        },
                    );
                    return error.to_compile_error().into();
                }
                "isize" => {
                    let error = syn::Error::new(
                        syn::spanned::Spanned::span(&&field),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("{0}.", not_supported),
                            );
                            res
                        },
                    );
                    return error.to_compile_error().into();
                }
                "bool" => {
                    let error = syn::Error::new(
                        syn::spanned::Spanned::span(&&field),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "{0}. Instead try `StorageBool`.",
                                    not_supported,
                                ),
                            );
                            res
                        },
                    );
                    return error.to_compile_error().into();
                }
                "f32" | "f64" => {
                    let error = syn::Error::new(
                        syn::spanned::Spanned::span(&&field),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "{0}. Consider fixed-point arithmetic.",
                                    not_supported,
                                ),
                            );
                            res
                        },
                    );
                    return error.to_compile_error().into();
                }
                _ => {}
            }
            let Some(ident) = &field.ident else {
                continue;
            };
            init.extend({
                let mut _s = ::quote::__private::TokenStream::new();
                ::quote::ToTokens::to_tokens(&ident, &mut _s);
                ::quote::__private::push_colon(&mut _s);
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Brace,
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "let");
                        ::quote::__private::push_ident(&mut _s, "bytes");
                        ::quote::__private::push_eq(&mut _s);
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                        ::quote::__private::push_ident(&mut _s, "as");
                        ::quote::__private::push_ident(&mut _s, "storage");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "StorageType");
                        ::quote::__private::push_gt(&mut _s);
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "SLOT_BYTES");
                        ::quote::__private::push_semi(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "let");
                        ::quote::__private::push_ident(&mut _s, "words");
                        ::quote::__private::push_eq(&mut _s);
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                        ::quote::__private::push_ident(&mut _s, "as");
                        ::quote::__private::push_ident(&mut _s, "storage");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "StorageType");
                        ::quote::__private::push_gt(&mut _s);
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "REQUIRED_SLOTS");
                        ::quote::__private::push_semi(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "if");
                        ::quote::__private::push_ident(&mut _s, "space");
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "bytes");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "space");
                                ::quote::__private::push_eq(&mut _s);
                                ::quote::__private::parse(&mut _s, "32");
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "slot");
                                ::quote::__private::push_add_eq(&mut _s);
                                ::quote::__private::parse(&mut _s, "1");
                                ::quote::__private::push_semi(&mut _s);
                                _s
                            },
                        );
                        ::quote::__private::push_ident(&mut _s, "space");
                        ::quote::__private::push_sub_eq(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "bytes");
                        ::quote::__private::push_semi(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "let");
                        ::quote::__private::push_ident(&mut _s, "root");
                        ::quote::__private::push_eq(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "root");
                        ::quote::__private::push_add(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "alloy_primitives");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "U256");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "from");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "slot");
                                _s
                            },
                        );
                        ::quote::__private::push_semi(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "let");
                        ::quote::__private::push_ident(&mut _s, "field");
                        ::quote::__private::push_eq(&mut _s);
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                        ::quote::__private::push_ident(&mut _s, "as");
                        ::quote::__private::push_ident(&mut _s, "storage");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "StorageType");
                        ::quote::__private::push_gt(&mut _s);
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "new");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Parenthesis,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "root");
                                ::quote::__private::push_comma(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "space");
                                ::quote::__private::push_ident(&mut _s, "as");
                                ::quote::__private::push_ident(&mut _s, "u8");
                                _s
                            },
                        );
                        ::quote::__private::push_semi(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "if");
                        ::quote::__private::push_ident(&mut _s, "words");
                        ::quote::__private::push_gt(&mut _s);
                        ::quote::__private::parse(&mut _s, "0");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "slot");
                                ::quote::__private::push_add_eq(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "words");
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "space");
                                ::quote::__private::push_eq(&mut _s);
                                ::quote::__private::parse(&mut _s, "32");
                                ::quote::__private::push_semi(&mut _s);
                                _s
                            },
                        );
                        ::quote::__private::push_ident(&mut _s, "field");
                        _s
                    },
                );
                ::quote::__private::push_comma(&mut _s);
                _s
            });
            size.extend({
                let mut _s = ::quote::__private::TokenStream::new();
                ::quote::__private::push_ident(&mut _s, "let");
                ::quote::__private::push_ident(&mut _s, "bytes");
                ::quote::__private::push_eq(&mut _s);
                ::quote::__private::push_lt(&mut _s);
                ::quote::ToTokens::to_tokens(&ty, &mut _s);
                ::quote::__private::push_ident(&mut _s, "as");
                ::quote::__private::push_ident(&mut _s, "storage");
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "StorageType");
                ::quote::__private::push_gt(&mut _s);
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "SLOT_BYTES");
                ::quote::__private::push_semi(&mut _s);
                ::quote::__private::push_ident(&mut _s, "let");
                ::quote::__private::push_ident(&mut _s, "words");
                ::quote::__private::push_eq(&mut _s);
                ::quote::__private::push_lt(&mut _s);
                ::quote::ToTokens::to_tokens(&ty, &mut _s);
                ::quote::__private::push_ident(&mut _s, "as");
                ::quote::__private::push_ident(&mut _s, "storage");
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "StorageType");
                ::quote::__private::push_gt(&mut _s);
                ::quote::__private::push_colon2(&mut _s);
                ::quote::__private::push_ident(&mut _s, "REQUIRED_SLOTS");
                ::quote::__private::push_semi(&mut _s);
                ::quote::__private::push_ident(&mut _s, "if");
                ::quote::__private::push_ident(&mut _s, "words");
                ::quote::__private::push_gt(&mut _s);
                ::quote::__private::parse(&mut _s, "0");
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Brace,
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "total");
                        ::quote::__private::push_add_eq(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "words");
                        ::quote::__private::push_semi(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "space");
                        ::quote::__private::push_eq(&mut _s);
                        ::quote::__private::parse(&mut _s, "32");
                        ::quote::__private::push_semi(&mut _s);
                        _s
                    },
                );
                ::quote::__private::push_ident(&mut _s, "else");
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Brace,
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "if");
                        ::quote::__private::push_ident(&mut _s, "space");
                        ::quote::__private::push_lt(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "bytes");
                        ::quote::__private::push_group(
                            &mut _s,
                            ::quote::__private::Delimiter::Brace,
                            {
                                let mut _s = ::quote::__private::TokenStream::new();
                                ::quote::__private::push_ident(&mut _s, "space");
                                ::quote::__private::push_eq(&mut _s);
                                ::quote::__private::parse(&mut _s, "32");
                                ::quote::__private::push_semi(&mut _s);
                                ::quote::__private::push_ident(&mut _s, "total");
                                ::quote::__private::push_add_eq(&mut _s);
                                ::quote::__private::parse(&mut _s, "1");
                                ::quote::__private::push_semi(&mut _s);
                                _s
                            },
                        );
                        ::quote::__private::push_ident(&mut _s, "space");
                        ::quote::__private::push_sub_eq(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "bytes");
                        ::quote::__private::push_semi(&mut _s);
                        _s
                    },
                );
                _s
            });
        }
        let expanded = {
            let mut _s = ::quote::__private::TokenStream::new();
            ::quote::ToTokens::to_tokens(&input, &mut _s);
            ::quote::__private::push_ident(&mut _s, "impl");
            ::quote::ToTokens::to_tokens(&impl_generics, &mut _s);
            ::quote::ToTokens::to_tokens(&name, &mut _s);
            ::quote::ToTokens::to_tokens(&ty_generics, &mut _s);
            ::quote::ToTokens::to_tokens(&where_clause, &mut _s);
            ::quote::__private::push_group(
                &mut _s,
                ::quote::__private::Delimiter::Brace,
                {
                    let mut _s = ::quote::__private::TokenStream::new();
                    ::quote::__private::push_ident(&mut _s, "const");
                    ::quote::__private::push_ident(&mut _s, "fn");
                    ::quote::__private::push_ident(&mut _s, "required_slots");
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        ::quote::__private::TokenStream::new(),
                    );
                    ::quote::__private::push_rarrow(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "usize");
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "use");
                            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "storage");
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "let");
                            ::quote::__private::push_ident(&mut _s, "mut");
                            ::quote::__private::push_ident(&mut _s, "total");
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "usize");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::__private::parse(&mut _s, "0");
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "let");
                            ::quote::__private::push_ident(&mut _s, "mut");
                            ::quote::__private::push_ident(&mut _s, "space");
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "usize");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::__private::parse(&mut _s, "32");
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::ToTokens::to_tokens(&size, &mut _s);
                            ::quote::__private::push_ident(&mut _s, "if");
                            ::quote::__private::push_ident(&mut _s, "space");
                            ::quote::__private::push_ne(&mut _s);
                            ::quote::__private::parse(&mut _s, "32");
                            ::quote::__private::push_or_or(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "total");
                            ::quote::__private::push_eq_eq(&mut _s);
                            ::quote::__private::parse(&mut _s, "0");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "total");
                                    ::quote::__private::push_add_eq(&mut _s);
                                    ::quote::__private::parse(&mut _s, "1");
                                    ::quote::__private::push_semi(&mut _s);
                                    _s
                                },
                            );
                            ::quote::__private::push_ident(&mut _s, "total");
                            _s
                        },
                    );
                    _s
                },
            );
            ::quote::__private::push_ident(&mut _s, "impl");
            ::quote::ToTokens::to_tokens(&impl_generics, &mut _s);
            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "storage");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "StorageType");
            ::quote::__private::push_ident(&mut _s, "for");
            ::quote::ToTokens::to_tokens(&name, &mut _s);
            ::quote::ToTokens::to_tokens(&ty_generics, &mut _s);
            ::quote::ToTokens::to_tokens(&where_clause, &mut _s);
            ::quote::__private::push_group(
                &mut _s,
                ::quote::__private::Delimiter::Brace,
                {
                    let mut _s = ::quote::__private::TokenStream::new();
                    ::quote::__private::push_ident(&mut _s, "type");
                    ::quote::__private::push_ident(&mut _s, "Wraps");
                    ::quote::__private::push_lt(&mut _s);
                    ::quote::__private::push_lifetime(&mut _s, "\'a");
                    ::quote::__private::push_gt(&mut _s);
                    ::quote::__private::push_eq(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "storage");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "StorageGuard");
                    ::quote::__private::push_lt(&mut _s);
                    ::quote::__private::push_lifetime(&mut _s, "\'a");
                    ::quote::__private::push_comma(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "Self");
                    ::quote::__private::push_gt(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "where");
                    ::quote::__private::push_ident(&mut _s, "Self");
                    ::quote::__private::push_colon(&mut _s);
                    ::quote::__private::push_lifetime(&mut _s, "\'a");
                    ::quote::__private::push_semi(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "type");
                    ::quote::__private::push_ident(&mut _s, "WrapsMut");
                    ::quote::__private::push_lt(&mut _s);
                    ::quote::__private::push_lifetime(&mut _s, "\'a");
                    ::quote::__private::push_gt(&mut _s);
                    ::quote::__private::push_eq(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "storage");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "StorageGuardMut");
                    ::quote::__private::push_lt(&mut _s);
                    ::quote::__private::push_lifetime(&mut _s, "\'a");
                    ::quote::__private::push_comma(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "Self");
                    ::quote::__private::push_gt(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "where");
                    ::quote::__private::push_ident(&mut _s, "Self");
                    ::quote::__private::push_colon(&mut _s);
                    ::quote::__private::push_lifetime(&mut _s, "\'a");
                    ::quote::__private::push_semi(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "const");
                    ::quote::__private::push_ident(&mut _s, "SLOT_BYTES");
                    ::quote::__private::push_colon(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "usize");
                    ::quote::__private::push_eq(&mut _s);
                    ::quote::__private::parse(&mut _s, "32");
                    ::quote::__private::push_semi(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "const");
                    ::quote::__private::push_ident(&mut _s, "REQUIRED_SLOTS");
                    ::quote::__private::push_colon(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "usize");
                    ::quote::__private::push_eq(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "Self");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "required_slots");
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        ::quote::__private::TokenStream::new(),
                    );
                    ::quote::__private::push_semi(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "unsafe");
                    ::quote::__private::push_ident(&mut _s, "fn");
                    ::quote::__private::push_ident(&mut _s, "new");
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "mut");
                            ::quote::__private::push_ident(&mut _s, "root");
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "alloy_primitives");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "U256");
                            ::quote::__private::push_comma(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "offset");
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "u8");
                            _s
                        },
                    );
                    ::quote::__private::push_rarrow(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "Self");
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "use");
                            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "storage");
                                    ::quote::__private::push_comma(&mut _s);
                                    ::quote::__private::push_ident(&mut _s, "alloy_primitives");
                                    _s
                                },
                            );
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "debug_assert");
                            ::quote::__private::push_bang(&mut _s);
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "offset");
                                    ::quote::__private::push_eq_eq(&mut _s);
                                    ::quote::__private::parse(&mut _s, "0");
                                    _s
                                },
                            );
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "let");
                            ::quote::__private::push_ident(&mut _s, "mut");
                            ::quote::__private::push_ident(&mut _s, "space");
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "usize");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::__private::parse(&mut _s, "32");
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "let");
                            ::quote::__private::push_ident(&mut _s, "mut");
                            ::quote::__private::push_ident(&mut _s, "slot");
                            ::quote::__private::push_colon(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "usize");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::__private::parse(&mut _s, "0");
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "let");
                            ::quote::__private::push_ident(&mut _s, "accessor");
                            ::quote::__private::push_eq(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "Self");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Brace,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::ToTokens::to_tokens(&init, &mut _s);
                                    _s
                                },
                            );
                            ::quote::__private::push_semi(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "accessor");
                            _s
                        },
                    );
                    ::quote::__private::push_ident(&mut _s, "fn");
                    ::quote::__private::push_ident(&mut _s, "load");
                    ::quote::__private::push_lt(&mut _s);
                    ::quote::__private::push_lifetime(&mut _s, "\'s");
                    ::quote::__private::push_gt(&mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "self");
                            _s
                        },
                    );
                    ::quote::__private::push_rarrow(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "Self");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "Wraps");
                    ::quote::__private::push_lt(&mut _s);
                    ::quote::__private::push_lifetime(&mut _s, "\'s");
                    ::quote::__private::push_gt(&mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "storage");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "StorageGuard");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "new");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "self");
                                    _s
                                },
                            );
                            _s
                        },
                    );
                    ::quote::__private::push_ident(&mut _s, "fn");
                    ::quote::__private::push_ident(&mut _s, "load_mut");
                    ::quote::__private::push_lt(&mut _s);
                    ::quote::__private::push_lifetime(&mut _s, "\'s");
                    ::quote::__private::push_gt(&mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "self");
                            _s
                        },
                    );
                    ::quote::__private::push_rarrow(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "Self");
                    ::quote::__private::push_colon2(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "WrapsMut");
                    ::quote::__private::push_lt(&mut _s);
                    ::quote::__private::push_lifetime(&mut _s, "\'s");
                    ::quote::__private::push_gt(&mut _s);
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "storage");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "StorageGuardMut");
                            ::quote::__private::push_colon2(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "new");
                            ::quote::__private::push_group(
                                &mut _s,
                                ::quote::__private::Delimiter::Parenthesis,
                                {
                                    let mut _s = ::quote::__private::TokenStream::new();
                                    ::quote::__private::push_ident(&mut _s, "self");
                                    _s
                                },
                            );
                            _s
                        },
                    );
                    _s
                },
            );
            ::quote::ToTokens::to_tokens(&borrows, &mut _s);
            _s
        };
        expanded.into()
    }
    pub fn sol_storage(input: TokenStream) -> TokenStream {
        let SolidityStructs(decls) = match ::syn::parse_macro_input::parse::<
            SolidityStructs,
        >(input) {
            ::syn::__private::Ok(data) => data,
            ::syn::__private::Err(err) => {
                return ::syn::__private::TokenStream::from(err.to_compile_error());
            }
        };
        let mut out = ::quote::__private::TokenStream::new();
        for decl in decls {
            let SolidityStruct {
                attrs,
                vis,
                name,
                generics,
                fields: SolidityFields(fields),
            } = decl;
            let fields: Punctuated<_, ::syn::token::Comma> = fields
                .into_iter()
                .map(|SolidityField { attrs, name, ty }| {
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        {
                            use ::quote::__private::ext::*;
                            let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                            #[allow(unused_mut)]
                            let (mut attrs, i) = attrs.quote_into_iter();
                            let has_iter = has_iter | i;
                            let _: ::quote::__private::HasIterator = has_iter;
                            while true {
                                let attrs = match attrs.next() {
                                    Some(_x) => ::quote::__private::RepInterp(_x),
                                    None => break,
                                };
                                ::quote::ToTokens::to_tokens(&attrs, &mut _s);
                            }
                        }
                        ::quote::__private::push_ident(&mut _s, "pub");
                        ::quote::ToTokens::to_tokens(&name, &mut _s);
                        ::quote::__private::push_colon(&mut _s);
                        ::quote::ToTokens::to_tokens(&ty, &mut _s);
                        _s
                    }
                })
                .collect();
            out.extend({
                let mut _s = ::quote::__private::TokenStream::new();
                {
                    use ::quote::__private::ext::*;
                    let has_iter = ::quote::__private::ThereIsNoIteratorInRepetition;
                    #[allow(unused_mut)]
                    let (mut attrs, i) = attrs.quote_into_iter();
                    let has_iter = has_iter | i;
                    let _: ::quote::__private::HasIterator = has_iter;
                    while true {
                        let attrs = match attrs.next() {
                            Some(_x) => ::quote::__private::RepInterp(_x),
                            None => break,
                        };
                        ::quote::ToTokens::to_tokens(&attrs, &mut _s);
                    }
                }
                ::quote::__private::push_pound(&mut _s);
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Bracket,
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::__private::push_ident(&mut _s, "stylus_sdk");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "stylus_proc");
                        ::quote::__private::push_colon2(&mut _s);
                        ::quote::__private::push_ident(&mut _s, "solidity_storage");
                        _s
                    },
                );
                ::quote::ToTokens::to_tokens(&vis, &mut _s);
                ::quote::__private::push_ident(&mut _s, "struct");
                ::quote::ToTokens::to_tokens(&name, &mut _s);
                ::quote::ToTokens::to_tokens(&generics, &mut _s);
                ::quote::__private::push_group(
                    &mut _s,
                    ::quote::__private::Delimiter::Brace,
                    {
                        let mut _s = ::quote::__private::TokenStream::new();
                        ::quote::ToTokens::to_tokens(&fields, &mut _s);
                        _s
                    },
                );
                _s
            });
        }
        out.into()
    }
    pub fn derive_erase(input: TokenStream) -> TokenStream {
        let mut input = match ::syn::parse_macro_input::parse::<ItemStruct>(input) {
            ::syn::__private::Ok(data) => data,
            ::syn::__private::Err(err) => {
                return ::syn::__private::TokenStream::from(err.to_compile_error());
            }
        };
        let name = &input.ident;
        let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();
        let mut erase_fields = ::quote::__private::TokenStream::new();
        for field in &mut input.fields {
            let ident = &field.ident;
            erase_fields
                .extend({
                    let mut _s = ::quote::__private::TokenStream::new();
                    ::quote::__private::push_ident(&mut _s, "self");
                    ::quote::__private::push_dot(&mut _s);
                    ::quote::ToTokens::to_tokens(&ident, &mut _s);
                    ::quote::__private::push_dot(&mut _s);
                    ::quote::__private::push_ident(&mut _s, "erase");
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        ::quote::__private::TokenStream::new(),
                    );
                    ::quote::__private::push_semi(&mut _s);
                    _s
                });
        }
        {
            let mut _s = ::quote::__private::TokenStream::new();
            ::quote::__private::push_ident(&mut _s, "impl");
            ::quote::ToTokens::to_tokens(&impl_generics, &mut _s);
            ::quote::__private::push_ident(&mut _s, "stylus_sdk");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "storage");
            ::quote::__private::push_colon2(&mut _s);
            ::quote::__private::push_ident(&mut _s, "Erase");
            ::quote::__private::push_ident(&mut _s, "for");
            ::quote::ToTokens::to_tokens(&name, &mut _s);
            ::quote::ToTokens::to_tokens(&ty_generics, &mut _s);
            ::quote::ToTokens::to_tokens(&where_clause, &mut _s);
            ::quote::__private::push_group(
                &mut _s,
                ::quote::__private::Delimiter::Brace,
                {
                    let mut _s = ::quote::__private::TokenStream::new();
                    ::quote::__private::push_ident(&mut _s, "fn");
                    ::quote::__private::push_ident(&mut _s, "erase");
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Parenthesis,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::__private::push_and(&mut _s);
                            ::quote::__private::push_ident(&mut _s, "mut");
                            ::quote::__private::push_ident(&mut _s, "self");
                            _s
                        },
                    );
                    ::quote::__private::push_group(
                        &mut _s,
                        ::quote::__private::Delimiter::Brace,
                        {
                            let mut _s = ::quote::__private::TokenStream::new();
                            ::quote::ToTokens::to_tokens(&erase_fields, &mut _s);
                            _s
                        },
                    );
                    _s
                },
            );
            _s
        }
            .into()
    }
}
mod types {
    use alloy_sol_types::SolType;
    use sha3::{Digest, Keccak256};
    use std::{borrow::Cow, fmt::Display, num::NonZeroU16, str::FromStr};
    use syn::Token;
    use syn_solidity::Type;
    /// The purity of a Solidity method
    pub enum Purity {
        Pure,
        View,
        Write,
        Payable,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Purity {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Purity::Pure => "Pure",
                    Purity::View => "View",
                    Purity::Write => "Write",
                    Purity::Payable => "Payable",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Purity {
        #[inline]
        fn clone(&self) -> Purity {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Purity {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Purity {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Purity {
        #[inline]
        fn eq(&self, other: &Purity) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Purity {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Purity {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Purity {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Purity,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Purity {
        #[inline]
        fn cmp(&self, other: &Purity) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    impl Default for Purity {
        fn default() -> Self {
            Self::Pure
        }
    }
    impl FromStr for Purity {
        type Err = ();
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            Ok(
                match s {
                    "pure" => Self::Pure,
                    "view" => Self::View,
                    "write" => Self::Write,
                    "payable" => Self::Payable,
                    _ => return Err(()),
                },
            )
        }
    }
    impl Display for Purity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Self::Pure => f.write_fmt(format_args!("pure")),
                Self::View => f.write_fmt(format_args!("view")),
                Self::Write => f.write_fmt(format_args!("write")),
                Self::Payable => f.write_fmt(format_args!("payable")),
            }
        }
    }
    impl From<Option<::syn::token::Mut>> for Purity {
        fn from(value: Option<::syn::token::Mut>) -> Self {
            match value.is_some() {
                true => Self::Write,
                false => Self::View,
            }
        }
    }
    /// Returns the alloy path and ABI for a given Solidity type
    pub fn solidity_type_info(ty: &Type) -> (Cow<'static, str>, Cow<'static, str>) {
        use alloy_sol_types::sol_data;
        match ty {
            Type::Bool(_) => {
                (
                    {
                        let text = {
                            let res = ::alloc::fmt::format(format_args!("Bool"));
                            res
                        };
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "stylus_sdk::alloy_sol_types::sol_data::{0}",
                                    text,
                                ),
                            );
                            res
                        }
                            .into()
                    },
                    sol_data::Bool::SOL_NAME.into(),
                )
            }
            Type::Address(_, _) => {
                (
                    {
                        let text = {
                            let res = ::alloc::fmt::format(format_args!("Address"));
                            res
                        };
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "stylus_sdk::alloy_sol_types::sol_data::{0}",
                                    text,
                                ),
                            );
                            res
                        }
                            .into()
                    },
                    sol_data::Address::SOL_NAME.into(),
                )
            }
            Type::String(_) => {
                (
                    {
                        let text = {
                            let res = ::alloc::fmt::format(format_args!("String"));
                            res
                        };
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "stylus_sdk::alloy_sol_types::sol_data::{0}",
                                    text,
                                ),
                            );
                            res
                        }
                            .into()
                    },
                    sol_data::String::SOL_NAME.into(),
                )
            }
            Type::Bytes(_) => {
                (
                    {
                        let text = {
                            let res = ::alloc::fmt::format(format_args!("Bytes"));
                            res
                        };
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "stylus_sdk::alloy_sol_types::sol_data::{0}",
                                    text,
                                ),
                            );
                            res
                        }
                            .into()
                    },
                    sol_data::Bytes::SOL_NAME.into(),
                )
            }
            Type::FixedBytes(_, size) => {
                (
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "stylus_sdk::alloy_sol_types::sol_data::FixedBytes<{0}>",
                                size,
                            ),
                        );
                        res
                    }
                        .into(),
                    {
                        let res = ::alloc::fmt::format(format_args!("bytes[{0}]", size));
                        res
                    }
                        .into(),
                )
            }
            Type::Uint(_, size) => {
                let size = size.unwrap_or(NonZeroU16::new(256).unwrap());
                (
                    {
                        let text = {
                            let res = ::alloc::fmt::format(
                                format_args!("Uint<{0}>", size),
                            );
                            res
                        };
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "stylus_sdk::alloy_sol_types::sol_data::{0}",
                                    text,
                                ),
                            );
                            res
                        }
                            .into()
                    },
                    {
                        let res = ::alloc::fmt::format(format_args!("uint{0}", size));
                        res
                    }
                        .into(),
                )
            }
            Type::Int(_, size) => {
                let size = size.unwrap_or(NonZeroU16::new(256).unwrap());
                (
                    {
                        let text = {
                            let res = ::alloc::fmt::format(
                                format_args!("Int<{0}>", size),
                            );
                            res
                        };
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "stylus_sdk::alloy_sol_types::sol_data::{0}",
                                    text,
                                ),
                            );
                            res
                        }
                            .into()
                    },
                    {
                        let res = ::alloc::fmt::format(format_args!("int{0}", size));
                        res
                    }
                        .into(),
                )
            }
            Type::Array(ty) => {
                let (path, abi) = solidity_type_info(&ty.ty);
                match ty.size() {
                    Some(size) => {
                        (
                            {
                                let text = {
                                    let res = ::alloc::fmt::format(
                                        format_args!("FixedArray<{0}, {1}>", path, size),
                                    );
                                    res
                                };
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "stylus_sdk::alloy_sol_types::sol_data::{0}",
                                            text,
                                        ),
                                    );
                                    res
                                }
                                    .into()
                            },
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("{0}[{1}]", abi, size),
                                );
                                res
                            }
                                .into(),
                        )
                    }
                    None => {
                        (
                            {
                                let text = {
                                    let res = ::alloc::fmt::format(
                                        format_args!("Array<{0}>", path),
                                    );
                                    res
                                };
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "stylus_sdk::alloy_sol_types::sol_data::{0}",
                                            text,
                                        ),
                                    );
                                    res
                                }
                                    .into()
                            },
                            {
                                let res = ::alloc::fmt::format(format_args!("{0}[]", abi));
                                res
                            }
                                .into(),
                        )
                    }
                }
            }
            Type::Tuple(tup) => {
                if tup.types.is_empty() {
                    ("()".into(), "()".into())
                } else if tup.types.len() == 1 {
                    solidity_type_info(&tup.types[0])
                } else {
                    let mut path = "(".to_string();
                    let mut abi = "(".to_string();
                    for (i, ty) in tup.types.iter().enumerate() {
                        if i > 0 {
                            path += ", ";
                            abi += ",";
                        }
                        let (inner_path, inner_abi) = solidity_type_info(ty);
                        path += &inner_path;
                        abi += &inner_abi;
                    }
                    path += ")";
                    abi += ")";
                    (path.into(), abi.into())
                }
            }
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "not yet implemented: {0}",
                        format_args!(
                            "Solidity type {0} is not yet implemented in sol_interface!",
                            ty,
                        ),
                    ),
                );
            }
        }
    }
    pub fn keccak<T: AsRef<[u8]>>(preimage: T) -> [u8; 32] {
        let mut hasher = Keccak256::new();
        hasher.update(preimage);
        hasher.finalize().into()
    }
}
/// Allows a Rust `struct` to be used in persistent storage.
///
/// ```ignore
/// #[solidity_storage]
/// pub struct Contract {
///    owner: StorageAddress,
///    active: StorageBool,
///    sub_struct: SubStruct,
///}
///
///#[solidity_storage]
///pub struct SubStruct {
///    // types implementing the `StorageType` trait.
///}
/// ```
///
/// Each field must implement [`StorageType`]. This includes other structs, which will
/// implement the `trait` automatically when [`#[solidity_storage]`][solidity_storage] is applied.
///
/// One may even implement [`StorageType`] to define custom storage entries, though this is rarely necessary
/// since the [Stylus SDK][sdk] intends to include all standard Solidity types out-of-the-box.
///
/// Please refer to the [SDK Feature Overview][overview] for more information on defining storage.
///
/// [solidity_storage]: macro@solidity_storage
/// [`StorageType`]: https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html
/// [overview]: https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#storage
/// [sdk]: https://docs.rs/stylus-sdk/latest/stylus_sdk/index.html
#[proc_macro_attribute]
pub fn solidity_storage(attr: TokenStream, input: TokenStream) -> TokenStream {
    storage::solidity_storage(attr, input)
}
/// The types in [`#[solidity_storage]`][solidity_storage] are laid out in the EVM state trie exactly
/// as they are in [Solidity][solidity]. This means that the fields of a `struct` definition will map
/// to the same storage slots as they would in EVM programming languages. Hence, it is often nice to
/// define types using Solidity syntax, which makes this guarantee easier to see.
///
/// ```ignore
/// sol_storage! {
///     pub struct Contract {
///         address owner;                      // becomes a StorageAddress
///         bool active;                        // becomes a StorageBool
///         SubStruct sub_struct,
///     }
///
///     pub struct SubStruct {
///         // other solidity fields, such as
///         mapping(address => uint) balances;  // becomes a StorageMap
///         Delegate delegates[];               // becomes a StorageVec
///     }
/// }
/// ```
///
/// The above will expand to equivalent definitions in Rust, with each structure implementing the [`StorageType`]
/// `trait`. Many contracts, like [the ERC 20 example][erc20], do exactly this.
///
/// Because the layout is identical to [Solidity's][solidity], existing Solidity smart contracts can
/// upgrade to Rust without fear of storage slots not lining up. You simply copy-paste your type definitions.
///
/// Consequently, the order of fields will affect the JSON ABIs produced that explorers and tooling might use.
/// Most developers don't need to worry about this though and can freely order their types when working on a
/// Rust contract from scratch.
///
/// Please refer to the [SDK Feature Overview][overview] for more information on defining storage.
///
/// [solidity_storage]: macro@solidity_storage
/// [`StorageType`]: https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html
/// [solidity]: https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html
/// [overview]: https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#erase-and-deriveerase
/// [erc20]: https://github.com/OffchainLabs/stylus-sdk-rs/blob/stylus/examples/erc20/src/main.rs
#[proc_macro]
pub fn sol_storage(input: TokenStream) -> TokenStream {
    storage::sol_storage(input)
}
/// Facilitates calls to other contracts.
///
/// This macro defines a `struct` for each of the Solidity interfaces provided.
///
/// ```ignore
/// sol_interface! {
///     interface IService {
///         function makePayment(address user) payable returns (string);
///         function getConstant() pure returns (bytes32)
///     }
///
///     interface ITree {
///         // other interface methods
///     }
/// }
/// ```
///
/// The above will define `IService` and `ITree` for calling the methods of the two contracts.
///
/// For example, `IService` will have a `make_payment` method that accepts an [`Address`] and returns a [`B256`].
///
/// ```ignore
/// pub fn do_call(account: IService, user: Address) -> Result<String, Error> {
///     let config = Call::new()
///         .gas(evm::gas_left() / 2)       // limit to half the gas left
///         .value(msg::value());           // set the callvalue
///
///     account.make_payment(config, user)  // note the snake case
/// }
/// ```
///
/// Observe the casing change. [`sol_interface!`] computes the selector based on the exact name passed in,
/// which should almost always be `CamelCase`. For aesthetics, the rust functions will instead use `snake_case`.
///
/// # Reentrant calls
///
/// Contracts that opt into reentrancy via the `reentrant` feature flag require extra care.
/// When enabled, cross-contract calls must [`flush`] or [`clear`] the [`StorageCache`] to safeguard state.
/// This happens automatically via the type system.
///
/// ```ignore
/// sol_interface! {
///     interface IMethods {
///         function pureFoo() pure;
///         function viewFoo() view;
///         function writeFoo();
///         function payableFoo() payable;
///     }
/// }
///
/// #[external]
/// impl Contract {
///     pub fn call_pure(&self, methods: IMethods) -> Result<(), Vec<u8>> {
///         Ok(methods.pure_foo(self)?)    // `pure` methods might lie about not being `view`
///     }
///
///     pub fn call_view(&self, methods: IMethods) -> Result<(), Vec<u8>> {
///         Ok(methods.view_foo(self)?)
///     }
///
///     pub fn call_write(&mut self, methods: IMethods) -> Result<(), Vec<u8>> {
///         methods.view_foo(self)?;       // allows `pure` and `view` methods too
///         Ok(methods.write_foo(self)?)
///     }
///
///     #[payable]
///     pub fn call_payable(&mut self, methods: IMethods) -> Result<(), Vec<u8>> {
///         methods.write_foo(Call::new_in(self))?;   // these are the same
///         Ok(methods.payable_foo(self)?)            // ------------------
///     }
/// }
/// ```
///
/// In the above, we're able to pass `&self` and `&mut self` because `Contract` implements
/// [`TopLevelStorage`], which means that a reference to it entails access to the entirety of
/// the contract's state. This is the reason it is sound to make a call, since it ensures all
/// cached values are invalidated and/or persisted to state at the right time.
///
/// When writing Stylus libraries, a type might not be [`TopLevelStorage`] and therefore
/// `&self` or `&mut self` won't work. Building a [`Call`] from a generic parameter is the usual solution.
///
/// ```ignore
/// pub fn do_call(
///     storage: &mut impl TopLevelStorage,  // can be generic, but often just &mut self
///     account: IService,                   // serializes as an Address
///     user: Address,
/// ) -> Result<String, Error> {
///
///     let config = Call::new_in(storage)
///         .gas(evm::gas_left() / 2)        // limit to half the gas left
///         .value(msg::value());            // set the callvalue
///
///     account.make_payment(config, user)   // note the snake case
/// }
/// ```
///
/// Note that in the context of an [`#[external]`][external] call, the `&mut impl` argument will correctly
/// distinguish the method as being `write` or `payable`. This means you can write library code that will
/// work regardless of whether the `reentrant` feature flag is enabled.
///
/// [sol_interface]: macro@sol_interface
/// [external]: macro@external
/// [`TopLevelStorage`]: https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.TopLevelStorage.html
/// [`StorageCache`]: https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageCache.html
/// [`flush`]: https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageCache.html#method.flush
/// [`clear`]: https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/struct.StorageCache.html#method.clear
/// [`Address`]: https://docs.rs/alloy-primitives/latest/alloy_primitives/struct.Address.html
/// [`B256`]: https://docs.rs/alloy-primitives/latest/alloy_primitives/aliases/type.B256.html
/// [`Call`]: https://docs.rs/stylus-sdk/latest/stylus_sdk/call/struct.Call.html
#[proc_macro]
pub fn sol_interface(input: TokenStream) -> TokenStream {
    calls::sol_interface(input)
}
/// Some [`StorageType`] values implement [`Erase`], which provides an [`erase()`] method for clearing state.
/// [The Stylus SDK][sdk] implements [`Erase`] for all primitives, and for vectors of primitives, but not for maps.
/// This is because a Solidity mapping does not provide iteration, and so it's generally impossible to
/// know which slots to clear.
///
/// Structs may also be [`Erase`] if all of the fields are. `#[derive(Erase)]`
/// lets you do this automatically.
///
/// ```ignore
/// sol_storage! {
///    #[derive(Erase)]
///    pub struct Contract {
///        address owner;              // can erase primitive
///        uint256[] hashes;           // can erase vector of primitive
///    }
///
///    pub struct NotErase {
///        mapping(address => uint) balances; // can't erase a map
///        mapping(uint => uint)[] roots;     // can't erase vector of maps
///    }
/// }
/// ```
///
/// You can also implement [`Erase`] manually if desired. Note that the reason we care about [`Erase`]
/// at all is that you get storage refunds when clearing state, lowering fees. There's also
/// minor implications for storage patterns using `unsafe` Rust.
///
/// Please refer to the [SDK Feature Overview][overview] for more information on defining storage.
///
/// [`StorageType`]: https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.StorageType.html
/// [`Erase`]: https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.Erase.html
/// [`erase()`]: https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.Erase.html#tymethod.erase
/// [overview]: https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#storage
/// [sdk]: https://docs.rs/stylus-sdk/latest/stylus_sdk/index.html
#[proc_macro_derive(Erase)]
pub fn derive_erase(input: TokenStream) -> TokenStream {
    storage::derive_erase(input)
}
/// Allows an error `enum` to be used in method signatures.
///
/// ```ignore
/// sol! {
///     error InsufficientBalance(address from, uint256 have, uint256 want);
///     error InsufficientAllowance(address owner, address spender, uint256 have, uint256 want);
/// }
///
/// #[derive(SolidityError)]
/// pub enum Erc20Error {
///     InsufficientBalance(InsufficientBalance),
///     InsufficientAllowance(InsufficientAllowance),
/// }
///
/// #[external]
/// impl Contract {
///     pub fn fallible_method() -> Result<(), Erc20Error> {
///         // code that might revert
///     }
/// }
/// ```
///
/// Under the hood, the above macro works by implementing `From<Erc20Error>` for `Vec<u8>`
/// along with printing code for abi-export.
#[proc_macro_derive(SolidityError)]
pub fn derive_solidity_error(input: TokenStream) -> TokenStream {
    methods::error::derive_solidity_error(input)
}
/// Defines the entrypoint, which is where Stylus execution begins.
/// Without it the contract will fail to pass [`cargo stylus check`][check].
/// Most commonly this macro is used to annotate the top level storage `struct`.
///
/// ```ignore
/// sol_storage! {
///     #[entrypoint]
///     pub struct Contract {
///         ...
///     }
///
///     // only one entrypoint is allowed
///     pub struct SubStruct {
///         ...
///     }
/// }
/// ```
///
/// The above will make the external methods of Contract the first to consider during invocation.
/// See [`#[external]`][external] for more information on method selection.
///
/// # Bytes-in, bytes-out programming
///
/// A less common usage of [`#[entrypoint]`][entrypoint] is for low-level, bytes-in bytes-out programming.
/// When applied to a free-standing function, a different way of writing smart contracts becomes possible,
/// wherein the Stylus SDK's macros and storage types are entirely optional.
///
/// ```ignore
/// #[entrypoint]
/// fn entrypoint(calldata: Vec<u8>) -> ArbResult {
///     // bytes-in, bytes-out programming
/// }
/// ```
///
/// # Reentrancy
///
/// If a contract calls another that then calls the first, it is said to be reentrant. By default,
/// all Stylus programs revert when this happens. However, you can opt out of this behavior by
/// recompiling with the `reentrant` flag.
///
/// ```toml
/// stylus_sdk = { version = "0.3.0", features = ["reentrant"] }
/// ```
///
/// This is dangerous, and should be done only after careful review -- ideally by 3rd-party auditors.
/// Numerous exploits and hacks have in Web3 are attributable to developers misusing or not fully
/// understanding reentrant patterns.
///
/// If enabled, the Stylus SDK will flush the storage cache in between reentrant calls, persisting values
/// to state that might be used by inner calls. Note that preventing storage invalidation is only part
/// of the battle in the fight against exploits. You can tell if a call is reentrant via
/// [`msg::reentrant`][reentrant], and condition your business logic accordingly.
///
/// # [`TopLevelStorage`]
///
/// The [`#[entrypoint]`][entrypoint] macro will automatically implement the [`TopLevelStorage`] `trait`
/// for the annotated `struct`. The single type implementing [`TopLevelStorage`] is special in that
/// mutable access to it represents mutable access to the entire program's state.
/// This has implications for calls via [`sol_interface`].
///
/// [`TopLevelStorage`]: https://docs.rs/stylus-sdk/latest/stylus_sdk/storage/trait.TopLevelStorage.html
/// [`sol_interface`]: macro@sol_interface
/// [entrypoint]: macro@entrypoint
/// [reentrant]: https://docs.rs/stylus-sdk/latest/stylus_sdk/msg/fn.reentrant.html
/// [external]: macro@external
/// [check]: https://github.com/OffchainLabs/cargo-stylus#developing-with-stylus
#[proc_macro_attribute]
pub fn entrypoint(attr: TokenStream, input: TokenStream) -> TokenStream {
    methods::entrypoint::entrypoint(attr, input)
}
/// Just as with storage, Stylus SDK methods are Solidity ABI-equivalent. This means that contracts written
/// in different programming languages are fully interoperable. You can even automatically export your
/// Rust contract as a Solidity interface so that others can add it to their Solidity projects.
///
/// This macro makes methods "external" so that other contracts can call them by implementing the [`Router`] trait.
///
/// ```ignore
/// #[external]
/// impl Contract {
///     // our owner method is now callable by other contracts
///     pub fn owner(&self) -> Result<Address, Vec<u8>> {
///         Ok(self.owner.get())
///     }
/// }
///
/// impl Contract {
///     // our set_owner method is not
///     pub fn set_owner(&mut self, new_owner: Address) -> Result<(), Vec<u8>> {
///         ...
///     }
/// }
/// ```
///
/// Note that, currently, all external methods must return a [`Result`] with the error type [`Vec<u8>`].
/// We intend to change this very soon. In the current model, [`Vec<u8>`] becomes the program's revert data,
/// which we intend to both make optional and richly typed.
///
/// # [`#[payable]`][payable]
///
/// As in Solidity, methods may accept ETH as call value.
///
/// ```ignore
/// #[external]
/// impl Contract {
///     #[payable]
///     pub fn credit(&mut self) -> Result<(), Vec<u8> {
///         self.erc20.add_balance(msg::sender(), msg::value())
///     }
/// }
/// ```
///
/// In the above, [msg::value][value] is the amount of ETH passed to the contract in wei, which may be used
/// to pay for something depending on the contract's business logic. Note that you have to annotate the method
/// with [`#[payable]`][payable], or else calls to it will revert. This is required as a safety measure
/// to prevent users losing funds to methods that didn't intend to accept ether.
///
/// # [`#[pure]`][pure] [`#[view]`][view], and #[write]
///
/// For aesthetics, these additional purity attributes exist to clarify that a method is [`pure`][pure],
/// [`view`][view], or `write`. They aren't necessary though, since the [`#[external]`][external] macro
/// can figure purity out for you based on the types of the arguments.
///
/// For example, if a method includes an `&self`, it's at least [`view`][view]. If you'd prefer it be write,
/// applying `#[write]` will make it so. Note however that the reverse is not allowed. An `&mut self`
/// method cannot be made [`#[view]`][view], since it might mutate state.
///
/// Please refer to the [SDK Feature Overview][overview] for more information on defining methods.
///
/// # Inheritance, `#[inherit]`, and `#[borrow]`
///
/// Composition in Rust follows that of Solidity. Types that implement [`Router`], the trait that
/// [`#[external]`][external] provides, can be connected via inheritance.
///
/// ```ignore
/// #[external]
/// #[inherit(Erc20)]
/// impl Token {
///     pub fn mint(&mut self, amount: U256) -> Result<(), Vec<u8>> {
///         ...
///     }
/// }
///
/// #[external]
/// impl Erc20 {
///     pub fn balance_of() -> Result<U256> {
///         ...
///     }
/// }
/// ```
///
/// Because `Token` inherits `Erc20` in the above, if `Token` has the [`#[entrypoint]`][entrypoint], calls to the
/// contract will first check if the requested method exists within `Token`. If a matching function is not found,
/// it will then try the `Erc20`. Only after trying everything `Token` inherits will the call revert.
///
/// Note that because methods are checked in that order, if both implement the same method, the one in `Token`
/// will override the one in `Erc20`, which won't be callable. This allows for patterns where the developer
/// imports a crate implementing a standard, like ERC 20, and then adds or overrides just the methods they
/// want to without modifying the imported `Erc20` type.
///
/// Inheritance can also be chained. `#[inherit(Erc20, Erc721)]` will inherit both `Erc20` and `Erc721`, checking
/// for methods in that order. `Erc20` and `Erc721` may also inherit other types themselves. Method resolution
/// finds the first matching method by [`Depth First Search`][dfs].
///
/// Note that for the above to work, Token must implement [`Borrow<Erc20>`][Borrow] and
/// [`BorrowMut<Erc20>`][BorrowMut]. You can implement this yourself, but for simplicity,
/// [`#[solidity_storage]`][solidity_storage] and [`sol_storage!`][sol_storage] provide a
/// `#[borrow]` annotation.
///
/// ```ignore
/// sol_storage! {
///     #[entrypoint]
///     pub struct Token {
///         #[borrow]
///         Erc20 erc20;
///         ...
///     }
///
///     pub struct Erc20 {
///         ...
///     }
/// }
/// ```
///
/// In the future we plan to simplify the SDK so that [`Borrow`][Borrow] isn't needed and so that
/// [`Router`] composition is more configurable. The motivation for this becomes clearer in complex
/// cases of multi-level inheritance, which we intend to improve.
///
/// # Exporting a Solidity interface
///
/// Recall that Stylus contracts are fully interoperable across all languages, including Solidity.
/// The Stylus SDK provides tools for exporting a Solidity interface for your contract so that others
/// can call it. This is usually done with the cargo stylus [CLI tool][cli].
///
/// The SDK does this automatically via a feature flag called `export-abi` that causes the
/// [`#[external]`][external] and [`#[entrypoint]`][entrypoint] macros to generate a `main` function
/// that prints the Solidity ABI to the console.
///
/// ```sh
/// cargo run --features export-abi --target <triple>
/// ```
///
/// Note that because the above actually generates a `main` function that you need to run, the target
/// can't be `wasm32-unknown-unknown` like normal. Instead you'll need to pass in your target triple,
/// which cargo stylus figures out for you. This `main` function is also why the following commonly
/// appears in the `main.rs` file of Stylus contracts.
///
/// ```ignore
/// #![cfg_attr(not(feature = "export-abi"), no_main)]
/// ```
///
/// Here's an example output. Observe that the method names change from Rust's `snake_case` to Solidity's
/// `camelCase`. For compatibility reasons, onchain method selectors are always `camelCase`. We'll provide
/// the ability to customize selectors very soon. Note too that you can use argument names like "address"
/// without fear. The SDK will prepend an `_` when necessary.
///
/// ```solidity
/// interface Erc20 {
///     function name() external pure returns (string memory);
///
///     function balanceOf(address _address) external view returns (uint256);
/// }
///
/// interface Weth is Erc20 {
///     function mint() external payable;
///
///     function burn(uint256 amount) external;
/// }
/// ```
///
/// [solidity_storage]: macro@solidity_storage
/// [sol_storage]: macro@sol_storage
/// [entrypoint]: macro@entrypoint
/// [external]: macro@external
/// [overview]: https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#methods
/// [`Router`]: https://docs.rs/stylus-sdk/latest/stylus_sdk/abi/trait.Router.html
/// [Borrow]: https://doc.rust-lang.org/std/borrow/trait.Borrow.html
/// [BorrowMut]: https://doc.rust-lang.org/std/borrow/trait.BorrowMut.html
/// [value]: https://docs.rs/stylus-sdk/latest/stylus_sdk/msg/fn.value.html
/// [payable]: https://docs.alchemy.com/docs/solidity-payable-functions
/// [view]: https://docs.soliditylang.org/en/develop/contracts.html#view-functions
/// [pure]: https://docs.soliditylang.org/en/develop/contracts.html#pure-functions
/// [cli]: https://github.com/OffchainLabs/cargo-stylus#exporting-solidity-abis
/// [dfs]: https://en.wikipedia.org/wiki/Depth-first_search
#[proc_macro_attribute]
pub fn external(attr: TokenStream, input: TokenStream) -> TokenStream {
    methods::external::external(attr, input)
}
const _: () = {
    extern crate proc_macro;
    #[rustc_proc_macro_decls]
    #[used]
    #[allow(deprecated)]
    static _DECLS: &[proc_macro::bridge::client::ProcMacro] = &[
        proc_macro::bridge::client::ProcMacro::attr(
            "solidity_storage",
            solidity_storage,
        ),
        proc_macro::bridge::client::ProcMacro::bang("sol_storage", sol_storage),
        proc_macro::bridge::client::ProcMacro::bang("sol_interface", sol_interface),
        proc_macro::bridge::client::ProcMacro::custom_derive("Erase", &[], derive_erase),
        proc_macro::bridge::client::ProcMacro::custom_derive(
            "SolidityError",
            &[],
            derive_solidity_error,
        ),
        proc_macro::bridge::client::ProcMacro::attr("entrypoint", entrypoint),
        proc_macro::bridge::client::ProcMacro::attr("external", external),
    ];
};
